<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Maven 多模块项目（Multi-Module）</title>
      <link href="/2025/03/28/%E6%8A%80%E6%9C%AF/java/%E6%A1%86%E6%9E%B6/Maven/Maven%20%E5%A4%9A%E6%A8%A1%E5%9D%97%E9%A1%B9%E7%9B%AE%EF%BC%88Multi-Module%EF%BC%89/"/>
      <url>/2025/03/28/%E6%8A%80%E6%9C%AF/java/%E6%A1%86%E6%9E%B6/Maven/Maven%20%E5%A4%9A%E6%A8%A1%E5%9D%97%E9%A1%B9%E7%9B%AE%EF%BC%88Multi-Module%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="🏗️-Maven-多模块项目（Multi-Module）"><a href="#🏗️-Maven-多模块项目（Multi-Module）" class="headerlink" title="🏗️ Maven 多模块项目（Multi-Module）"></a>🏗️ Maven 多模块项目（Multi-Module）</h1><hr><h2 id="1️⃣-父子项目结构设计"><a href="#1️⃣-父子项目结构设计" class="headerlink" title="1️⃣ 父子项目结构设计"></a>1️⃣ 父子项目结构设计</h2><h3 id="✅-结构示意图："><a href="#✅-结构示意图：" class="headerlink" title="✅ 结构示意图："></a>✅ 结构示意图：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">multi-module-parent/</span><br><span class="line">├── pom.xml             ← 父模块（聚合器 + 版本控制）</span><br><span class="line">├── module-a/</span><br><span class="line">│   └── pom.xml         ← 子模块A（如 API 层）</span><br><span class="line">├── module-b/</span><br><span class="line">│   └── pom.xml         ← 子模块B（如 Service 层）</span><br></pre></td></tr></table></figure><h3 id="✅-父模块（Parent-POM）特点："><a href="#✅-父模块（Parent-POM）特点：" class="headerlink" title="✅ 父模块（Parent POM）特点："></a>✅ 父模块（Parent POM）特点：</h3><ul><li>类型为 <code>pom</code></li><li>用来统一版本管理、依赖版本、插件版本</li><li>一般不包含实际代码</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="✅-子模块的-pom-xml-需要："><a href="#✅-子模块的-pom-xml-需要：" class="headerlink" title="✅ 子模块的 pom.xml 需要："></a>✅ 子模块的 <code>pom.xml</code> 需要：</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.neo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>multi-module-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="2️⃣-聚合（Aggregation）vs-继承（Inheritance）"><a href="#2️⃣-聚合（Aggregation）vs-继承（Inheritance）" class="headerlink" title="2️⃣ 聚合（Aggregation）vs 继承（Inheritance）"></a>2️⃣ 聚合（Aggregation）vs 继承（Inheritance）</h2><table><thead><tr><th>区别点</th><th>聚合 Aggregation</th><th>继承 Inheritance</th></tr></thead><tbody><tr><td>定义</td><td>在父模块中 <code>&lt;modules&gt;</code> 声明子模块</td><td>子模块在 <code>&lt;parent&gt;</code> 指向父模块</td></tr><tr><td>作用</td><td>用于一次性构建多个模块</td><td>用于复用 POM 中的版本、依赖、插件配置</td></tr><tr><td>是否必须写</td><td>父模块需要写 <code>&lt;modules&gt;</code></td><td>子模块需要写 <code>&lt;parent&gt;</code></td></tr><tr><td>构建影响</td><td><code>mvn install</code> 会构建所有模块</td><td>仅靠继承不会构建，需要聚合才能批量构建</td></tr></tbody></table><h3 id="✅-示例（父模块）："><a href="#✅-示例（父模块）：" class="headerlink" title="✅ 示例（父模块）："></a>✅ 示例（父模块）：</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">module</span>&gt;</span>module-a<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">module</span>&gt;</span>module-b<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="3️⃣-多模块构建顺序控制"><a href="#3️⃣-多模块构建顺序控制" class="headerlink" title="3️⃣ 多模块构建顺序控制"></a>3️⃣ 多模块构建顺序控制</h2><p>Maven 默认会<strong>自动计算模块之间的依赖关系</strong>，确保：</p><blockquote><p><strong>先构建被依赖的模块，再构建依赖它的模块</strong></p></blockquote><hr><h3 id="✅-举个例子："><a href="#✅-举个例子：" class="headerlink" title="✅ 举个例子："></a>✅ 举个例子：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A（依赖 B）</span><br><span class="line">B（依赖 C）</span><br><span class="line">C（最底层）</span><br></pre></td></tr></table></figure><blockquote><p>Maven 构建顺序是：C → B → A</p></blockquote><p>📌 使用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean install</span><br></pre></td></tr></table></figure><p>就会自动按依赖关系构建好所有模块。</p><hr><h3 id="❗-注意："><a href="#❗-注意：" class="headerlink" title="❗ 注意："></a>❗ 注意：</h3><p>如果你写了 <code>&lt;modules&gt;</code> 顺序是 A、B、C，Maven 仍然会自动识别依赖关系，按正确顺序构建！</p><hr><h2 id="🛠-实用命令小结："><a href="#🛠-实用命令小结：" class="headerlink" title="🛠 实用命令小结："></a>🛠 实用命令小结：</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>mvn clean install</code></td><td>在父模块目录构建所有模块</td></tr><tr><td><code>mvn install -pl module-b</code></td><td>只构建指定模块（含依赖）</td></tr><tr><td><code>mvn install -pl module-b -am</code></td><td>同时构建模块及其依赖模块</td></tr><tr><td><code>mvn install -pl module-a -am -amd</code></td><td>同时构建依赖模块和被依赖模块</td></tr></tbody></table><hr><h2 id="✅-口诀："><a href="#✅-口诀：" class="headerlink" title="✅ 口诀："></a>✅ 口诀：</h2><blockquote><p>聚合管构建，继承管配置；<br>顺序靠依赖，声明看结构；<br>父子联动用，模块拆得巧。</p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> java </category>
          
          <category> 框架 </category>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>win10系统换成Ubuntu系统</title>
      <link href="/2025/03/28/%E6%8A%80%E6%9C%AF/%E8%BF%90%E7%BB%B4/Linux/Maven%20%E6%8F%92%E4%BB%B6%E7%AE%80%E4%BB%8B/"/>
      <url>/2025/03/28/%E6%8A%80%E6%9C%AF/%E8%BF%90%E7%BB%B4/Linux/Maven%20%E6%8F%92%E4%BB%B6%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我有一台安装了win10的电脑主机闲置，想将其换成Ubuntu系统，作为服务器使用</p><h2 id="mac下制作Ubuntu系统USB启动盘"><a href="#mac下制作Ubuntu系统USB启动盘" class="headerlink" title="mac下制作Ubuntu系统USB启动盘"></a>mac下制作Ubuntu系统USB启动盘</h2><p>准备一个U盘<br>下载Ubuntu镜像，官网下载很慢可以上阿里云华为等国内镜像网站下载<br>macos安装balenaEtcher Mac版<br><img src="https://cdn.jsdelivr.net/gh/neoisok/assets@main/images%2F2025%2F03%2F28%2F20250328215415372-780d5dbfe84e070fb561afe86c796b35.png"><br>选择镜像-&gt;选择U盘-&gt;开始烧录<br><img src="https://cdn.jsdelivr.net/gh/neoisok/assets@main/images%2F2025%2F03%2F28%2F20250328220141061-94e5ed6cbbbfa9bba49fa2aadfdcd704.png"><br><img src="https://cdn.jsdelivr.net/gh/neoisok/assets@main/images%2F2025%2F03%2F28%2F20250328220141061-94e5ed6cbbbfa9bba49fa2aadfdcd704.png" width=600px></p><h2 id="安装Ubuntu系统"><a href="#安装Ubuntu系统" class="headerlink" title="安装Ubuntu系统"></a>安装Ubuntu系统</h2><p>插入U盘重启win10系统，intel nuc 按F10 选择U盘为启动盘<br>选择安装Ubuntu系统<br>选择最小化安装 minimized</p><h2 id="配置ssh和代理"><a href="#配置ssh和代理" class="headerlink" title="配置ssh和代理"></a>配置ssh和代理</h2><p>固定ip并且</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 运维 </category>
          
          <category> Ubuntu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven 依赖管理深入理解</title>
      <link href="/2025/03/28/%E6%8A%80%E6%9C%AF/java/%E6%A1%86%E6%9E%B6/Maven/Maven%20%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
      <url>/2025/03/28/%E6%8A%80%E6%9C%AF/java/%E6%A1%86%E6%9E%B6/Maven/Maven%20%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="📦-Maven-依赖管理深入理解"><a href="#📦-Maven-依赖管理深入理解" class="headerlink" title="📦 Maven 依赖管理深入理解"></a>📦 Maven 依赖管理深入理解</h1><hr><h2 id="1️⃣-本地仓库-中央仓库-私服仓库"><a href="#1️⃣-本地仓库-中央仓库-私服仓库" class="headerlink" title="1️⃣ 本地仓库 &#x2F; 中央仓库 &#x2F; 私服仓库"></a>1️⃣ 本地仓库 &#x2F; 中央仓库 &#x2F; 私服仓库</h2><h3 id="✅-本地仓库（Local-Repository）"><a href="#✅-本地仓库（Local-Repository）" class="headerlink" title="✅ 本地仓库（Local Repository）"></a>✅ 本地仓库（Local Repository）</h3><ul><li>默认位置：<code>~/.m2/repository</code></li><li>每次执行 Maven 命令，优先从本地仓库查找依赖</li><li>下载成功的依赖将缓存在此处（不会重复下载）</li></ul><hr><h3 id="✅-中央仓库（Maven-Central）"><a href="#✅-中央仓库（Maven-Central）" class="headerlink" title="✅ 中央仓库（Maven Central）"></a>✅ 中央仓库（Maven Central）</h3><ul><li>默认远程仓库，地址：<a href="https://repo.maven.apache.org/maven2/">https://repo.maven.apache.org/maven2/</a></li><li>超级 POM 中内置，不写任何配置也能访问</li><li>缺失的依赖默认从这里下载到本地仓库</li></ul><hr><h3 id="✅-私服仓库（Nexus、Artifactory）"><a href="#✅-私服仓库（Nexus、Artifactory）" class="headerlink" title="✅ 私服仓库（Nexus、Artifactory）"></a>✅ 私服仓库（Nexus、Artifactory）</h3><ul><li>企业级常见：统一缓存、权限控制、私有发布</li><li>配置方式：写入 <code>~/.m2/settings.xml</code> 中的 <code>&lt;mirrors&gt;</code> 或 <code>&lt;profiles&gt;</code>：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://nexus.company.com/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="2️⃣-依赖传递与冲突解决"><a href="#2️⃣-依赖传递与冲突解决" class="headerlink" title="2️⃣ 依赖传递与冲突解决"></a>2️⃣ 依赖传递与冲突解决</h2><h3 id="✅-依赖传递（Transitive-Dependency）"><a href="#✅-依赖传递（Transitive-Dependency）" class="headerlink" title="✅ 依赖传递（Transitive Dependency）"></a>✅ 依赖传递（Transitive Dependency）</h3><blockquote><p>Maven 会自动引入依赖的依赖（最多支持无限级）</p></blockquote><p>🧱 示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">项目A → 引入 spring-web</span><br><span class="line">        → spring-web 自动引入 spring-core → spring-jcl</span><br></pre></td></tr></table></figure><p>你不需要手动写每一级依赖。</p><hr><h3 id="✅-冲突解决规则"><a href="#✅-冲突解决规则" class="headerlink" title="✅ 冲突解决规则"></a>✅ 冲突解决规则</h3><hr><h4 id="🔍-实际-Maven-的判定规则是："><a href="#🔍-实际-Maven-的判定规则是：" class="headerlink" title="🔍 实际 Maven 的判定规则是："></a>🔍 实际 Maven 的判定规则是：</h4><h5 id="✅-距离优先（Nearest-First）"><a href="#✅-距离优先（Nearest-First）" class="headerlink" title="✅ 距离优先（Nearest First）"></a>✅ 距离优先（Nearest First）</h5><ul><li>谁离根项目（项目 A）路径更短，谁胜</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">├── B（依赖 log4j:1.2.17）    ← 距离 = 2</span><br><span class="line">│</span><br><span class="line">└── C</span><br><span class="line">     └── D</span><br><span class="line">         └── log4j:2.17.0     ← 距离 = 4</span><br></pre></td></tr></table></figure><p>在这个例子里：</p><ul><li>log4j:1.2.17 的路径是：A → B → log4j（共 2 层）</li><li>log4j:2.17.0 的路径是：A → C → D → log4j（共 4 层）</li></ul><p>✅ 所以最终使用：<strong>log4j:1.2.17</strong>（距离近）</p><h5 id="✅-顺序优先（First-Declaration-Wins）"><a href="#✅-顺序优先（First-Declaration-Wins）" class="headerlink" title="✅ 顺序优先（First Declaration Wins）"></a>✅ 顺序优先（First Declaration Wins）</h5><ul><li>如果距离一样，谁<strong>先出现在依赖树中</strong>，谁胜出（通常是依赖声明顺序）</li></ul><p>📌 举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">项目A</span><br><span class="line">├── B（log4j:1.2.17）</span><br><span class="line">└── C（log4j:2.17.0）</span><br><span class="line"></span><br><span class="line">→ A 最终使用 log4j:1.2.17（因为 B 先出现在依赖树中）</span><br></pre></td></tr></table></figure><hr><h3 id="🔍-查看依赖冲突命令："><a href="#🔍-查看依赖冲突命令：" class="headerlink" title="🔍 查看依赖冲突命令："></a>🔍 查看依赖冲突命令：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn dependency:tree</span><br></pre></td></tr></table></figure><p>可以加 <code>-Dverbose</code> 显示冲突信息。</p><hr><h2 id="3️⃣-依赖范围（scope）"><a href="#3️⃣-依赖范围（scope）" class="headerlink" title="3️⃣ 依赖范围（scope）"></a>3️⃣ 依赖范围（scope）</h2><p>控制依赖在构建生命周期中何时可用，是否打进包里：</p><table><thead><tr><th>范围</th><th>用途</th><th>编译可用</th><th>测试可用</th><th>运行可用</th><th>打进包</th></tr></thead><tbody><tr><td><code>compile</code>（默认）</td><td>常规依赖</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td><code>provided</code></td><td>编译需要，运行由容器提供（如 Servlet）</td><td>✅</td><td>✅</td><td>❌</td><td>❌</td></tr><tr><td><code>runtime</code></td><td>编译不需要，运行需要</td><td>❌</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td><code>test</code></td><td>仅测试代码用（如 JUnit）</td><td>❌</td><td>✅</td><td>❌</td><td>❌</td></tr><tr><td><code>system</code>（不推荐）</td><td>使用本地 jar 包</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td><code>import</code></td><td>仅用于 <code>&lt;dependencyManagement&gt;</code> 引入 BOM</td><td>-</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><p>📌 示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="4️⃣-排除依赖（exclusions）"><a href="#4️⃣-排除依赖（exclusions）" class="headerlink" title="4️⃣ 排除依赖（exclusions）"></a>4️⃣ 排除依赖（exclusions）</h2><p>用来解决<strong>传递依赖冲突</strong>或剔除无用&#x2F;冲突组件。</p><p>📌 示例：排除 spring-boot-starter 中的 logback</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h2><ol><li>手动引入冲突依赖，运行 <code>mvn dependency:tree</code> 观察谁胜出</li><li>修改 <code>scope</code> 为 test，演示构建产物中是否包含</li><li>用 exclusions 排除一个传递依赖，看效果</li><li>演示切换中央仓库 → 私服仓库的 settings 配置行为</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> java </category>
          
          <category> 框架 </category>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven项目构建生命周期</title>
      <link href="/2025/03/28/%E6%8A%80%E6%9C%AF/java/%E6%A1%86%E6%9E%B6/Maven/Maven%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2025/03/28/%E6%8A%80%E6%9C%AF/java/%E6%A1%86%E6%9E%B6/Maven/Maven%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="Maven-项目构建生命周期（Build-Lifecycle）"><a href="#Maven-项目构建生命周期（Build-Lifecycle）" class="headerlink" title="Maven 项目构建生命周期（Build Lifecycle）"></a>Maven 项目构建生命周期（Build Lifecycle）</h2><hr><h3 id="一、什么是生命周期（Lifecycle）？"><a href="#一、什么是生命周期（Lifecycle）？" class="headerlink" title="一、什么是生命周期（Lifecycle）？"></a>一、什么是生命周期（Lifecycle）？</h3><blockquote><p>生命周期是 Maven 的核心机制之一，定义了 <strong>项目从清理到打包再到部署的全过程</strong>，是由一系列有序的构建阶段（Phase）组成的。</p></blockquote><p>简单理解就是：你运行一个 Maven 命令，比如 <code>mvn install</code>，Maven 会自动按照一个预定义的顺序，执行从编译、测试、打包到安装的所有阶段。</p><hr><h3 id="二、Maven-的三大内置生命周期"><a href="#二、Maven-的三大内置生命周期" class="headerlink" title="二、Maven 的三大内置生命周期"></a>二、Maven 的三大内置生命周期</h3><table><thead><tr><th>生命周期名称</th><th>作用说明</th></tr></thead><tbody><tr><td><strong>default</strong>（默认生命周期）</td><td>项目的编译、测试、打包、部署等</td></tr><tr><td><strong>clean</strong></td><td>清理项目（删除之前构建的产物）</td></tr><tr><td><strong>site</strong></td><td>生成项目文档、报告等</td></tr></tbody></table><hr><h3 id="三、默认生命周期（default-lifecycle）"><a href="#三、默认生命周期（default-lifecycle）" class="headerlink" title="三、默认生命周期（default lifecycle）"></a>三、默认生命周期（default lifecycle）</h3><p>Maven 的构建流程由多个“阶段”（Phase）组成，这些阶段是<strong>有顺序的</strong>，执行其中一个阶段会连带执行之前的所有阶段。</p><h4 id="主要构建阶段如下："><a href="#主要构建阶段如下：" class="headerlink" title="主要构建阶段如下："></a>主要构建阶段如下：</h4><table><thead><tr><th>阶段名（Phase）</th><th>功能说明</th></tr></thead><tbody><tr><td><strong>validate</strong></td><td>验证项目是否正确，例如目录结构、必要信息是否完整</td></tr><tr><td><strong>compile</strong></td><td>编译主源码（src&#x2F;main&#x2F;java）</td></tr><tr><td><strong>test</strong></td><td>编译并运行单元测试（src&#x2F;test&#x2F;java）</td></tr><tr><td><strong>package</strong></td><td>打包编译后的代码（如 jar&#x2F;war）</td></tr><tr><td><strong>verify</strong></td><td>运行集成测试，验证包是否有效</td></tr><tr><td><strong>install</strong></td><td>安装到本地 Maven 仓库，供本机其他项目使用</td></tr><tr><td><strong>deploy</strong></td><td>发布到远程仓库，供团队共享使用（通常结合 CI&#x2F;CD）</td></tr></tbody></table><blockquote><p>📝 示例：<code>mvn install</code> 会依次执行：<code>validate → compile → test → package → verify → install</code></p></blockquote><hr><h3 id="四、clean-生命周期"><a href="#四、clean-生命周期" class="headerlink" title="四、clean 生命周期"></a>四、clean 生命周期</h3><p>用于清理之前构建的文件，主要阶段：</p><table><thead><tr><th>阶段</th><th>说明</th></tr></thead><tbody><tr><td><strong>pre-clean</strong></td><td>清理前的准备工作（插件扩展用）</td></tr><tr><td><strong>clean</strong></td><td>删除 <code>target/</code> 目录（编译产物）</td></tr><tr><td><strong>post-clean</strong></td><td>清理后的收尾操作</td></tr></tbody></table><blockquote><p>常用命令：<code>mvn clean</code> — 清理旧文件，避免构建污染。</p></blockquote><hr><h3 id="五、site-生命周期（可选模块）"><a href="#五、site-生命周期（可选模块）" class="headerlink" title="五、site 生命周期（可选模块）"></a>五、site 生命周期（可选模块）</h3><p>用于生成项目站点文档（文档网站、测试覆盖率、依赖报告等）：</p><table><thead><tr><th>阶段</th><th>说明</th></tr></thead><tbody><tr><td><strong>pre-site</strong></td><td>准备生成站点</td></tr><tr><td><strong>site</strong></td><td>生成文档网站</td></tr><tr><td><strong>post-site</strong></td><td>站点生成后的处理</td></tr><tr><td><strong>site-deploy</strong></td><td>部署站点到服务器</td></tr></tbody></table><hr><h3 id="六、生命周期、阶段与插件三者关系"><a href="#六、生命周期、阶段与插件三者关系" class="headerlink" title="六、生命周期、阶段与插件三者关系"></a>六、生命周期、阶段与插件三者关系</h3><p>生命周期 ≠ 阶段 ≠ 插件<br>Maven 实际上只是框架，<strong>真正执行工作的都是插件</strong>。</p><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean</span><br></pre></td></tr></table></figure><p>执行的是 <code>clean</code> 生命周期的 <code>clean</code> 阶段，具体操作由 <code>maven-clean-plugin</code> 实现。</p><p>下面是对**“六、生命周期、阶段与插件三者关系”<strong>的</strong>详细讲解**，包括概念区分、调用机制、示例分析、常见误区等</p><hr><h4 id="1️⃣-三者核心定义"><a href="#1️⃣-三者核心定义" class="headerlink" title="1️⃣ 三者核心定义"></a>1️⃣ 三者核心定义</h4><table><thead><tr><th>概念</th><th>定义</th><th>举例</th></tr></thead><tbody><tr><td><strong>生命周期</strong>（Lifecycle）</td><td>一组预定义的构建阶段，用于组织项目构建过程</td><td><code>default</code>、<code>clean</code>、<code>site</code></td></tr><tr><td><strong>阶段</strong>（Phase）</td><td>生命周期中的一个构建步骤，会被按顺序执行</td><td><code>compile</code>、<code>test</code>、<code>package</code>、<code>install</code> 等</td></tr><tr><td><strong>插件</strong>（Plugin）</td><td>执行具体构建行为的工具，是 Maven 的扩展机制</td><td><code>maven-compiler-plugin</code>、<code>maven-surefire-plugin</code> 等</td></tr></tbody></table><p>➡️ <strong>阶段是生命周期的一部分，插件是实际干活的角色。</strong></p><hr><h4 id="2️⃣-三者调用关系：你执行阶段，Maven调用插件"><a href="#2️⃣-三者调用关系：你执行阶段，Maven调用插件" class="headerlink" title="2️⃣ 三者调用关系：你执行阶段，Maven调用插件"></a>2️⃣ 三者调用关系：<strong>你执行阶段，Maven调用插件</strong></h4><p>比如执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn package</span><br></pre></td></tr></table></figure><ul><li>触发的是 <code>default</code> 生命周期中的 <code>package</code> 阶段</li><li>Maven 会找该阶段默认绑定的插件和目标（goal）</li><li>执行 <code>maven-jar-plugin:jar</code> 来打包生成 <code>.jar</code> 文件</li></ul><hr><h4 id="3️⃣-插件中的目标（Goal）"><a href="#3️⃣-插件中的目标（Goal）" class="headerlink" title="3️⃣ 插件中的目标（Goal）"></a>3️⃣ 插件中的目标（Goal）</h4><p>每个插件有一个或多个 <strong>目标（goal）</strong>，是插件中的具体任务单位。</p><p>例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">phase</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>表示：在 <code>compile</code> 阶段执行 <code>maven-compiler-plugin</code> 插件的 <code>compile</code> 目标。</p><hr><h4 id="4️⃣-阶段与插件绑定关系（默认）"><a href="#4️⃣-阶段与插件绑定关系（默认）" class="headerlink" title="4️⃣ 阶段与插件绑定关系（默认）"></a>4️⃣ 阶段与插件绑定关系（默认）</h4><table><thead><tr><th>阶段（Phase）</th><th>默认绑定插件及目标（Goal）</th></tr></thead><tbody><tr><td>compile</td><td><code>maven-compiler-plugin:compile</code></td></tr><tr><td>test</td><td><code>maven-surefire-plugin:test</code></td></tr><tr><td>package</td><td><code>maven-jar-plugin:jar</code> &#x2F; <code>maven-war-plugin:war</code></td></tr><tr><td>install</td><td><code>maven-install-plugin:install</code></td></tr><tr><td>deploy</td><td><code>maven-deploy-plugin:deploy</code></td></tr></tbody></table><p>这些绑定都是<strong>默认绑定</strong>，也可以在 POM 中自定义绑定其他插件或替换默认插件。</p><hr><h4 id="5️⃣-可视化总结关系图："><a href="#5️⃣-可视化总结关系图：" class="headerlink" title="5️⃣ 可视化总结关系图："></a>5️⃣ 可视化总结关系图：</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[生命周期 Lifecycle]</span><br><span class="line">         ↓</span><br><span class="line"> ┌──────────────┐</span><br><span class="line"> │    阶段 Phase   │ → 按顺序执行（compile → test → package）</span><br><span class="line"> └──────────────┘</span><br><span class="line">         ↓</span><br><span class="line">[插件 Plugin + 目标 Goal]  ← 真正执行具体操作</span><br></pre></td></tr></table></figure><hr><h4 id="6️⃣-常见误区澄清"><a href="#6️⃣-常见误区澄清" class="headerlink" title="6️⃣ 常见误区澄清"></a>6️⃣ 常见误区澄清</h4><table><thead><tr><th>误区</th><th>正确认知</th></tr></thead><tbody><tr><td>以为 <code>mvn compile</code> 是插件命令</td><td>❌ 不是插件，而是执行“阶段”</td></tr><tr><td>插件必须写在 POM 里才执行</td><td>❌ 有默认插件绑定，非必须</td></tr><tr><td>执行某阶段只执行该阶段</td><td>❌ 会连带执行前面所有阶段</td></tr></tbody></table><hr><h4 id="7️⃣-实践建议：查看阶段与插件绑定关系"><a href="#7️⃣-实践建议：查看阶段与插件绑定关系" class="headerlink" title="7️⃣ 实践建议：查看阶段与插件绑定关系"></a>7️⃣ 实践建议：查看阶段与插件绑定关系</h4><p>你可以通过以下命令查看完整的生命周期绑定：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn <span class="built_in">help</span>:describe -Dcmd=compile</span><br></pre></td></tr></table></figure><p>或查看某个插件目标的详细信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn <span class="built_in">help</span>:describe -Dplugin=compiler -Dfull</span><br></pre></td></tr></table></figure><hr><h3 id="七、常用构建命令速查表"><a href="#七、常用构建命令速查表" class="headerlink" title="七、常用构建命令速查表"></a>七、常用构建命令速查表</h3><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td><code>mvn clean</code></td><td>清理项目</td></tr><tr><td><code>mvn compile</code></td><td>编译源代码</td></tr><tr><td><code>mvn test</code></td><td>执行单元测试</td></tr><tr><td><code>mvn package</code></td><td>打包</td></tr><tr><td><code>mvn install</code></td><td>安装到本地仓库</td></tr><tr><td><code>mvn deploy</code></td><td>发布到远程仓库</td></tr></tbody></table><hr>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> java </category>
          
          <category> 框架 </category>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven 插件简介</title>
      <link href="/2025/03/28/%E6%8A%80%E6%9C%AF/java/%E6%A1%86%E6%9E%B6/Maven/Maven%20%E6%8F%92%E4%BB%B6%E7%AE%80%E4%BB%8B/"/>
      <url>/2025/03/28/%E6%8A%80%E6%9C%AF/java/%E6%A1%86%E6%9E%B6/Maven/Maven%20%E6%8F%92%E4%BB%B6%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="插件执行时机"><a href="#插件执行时机" class="headerlink" title="插件执行时机"></a>插件执行时机</h1><blockquote><p>插件是怎么被“触发执行”的？需要什么条件？执行时机是什么？</p></blockquote><h2 id="🔑-一、插件的两种执行方式"><a href="#🔑-一、插件的两种执行方式" class="headerlink" title="🔑 一、插件的两种执行方式"></a>🔑 一、插件的两种执行方式</h2><h3 id="✅-方式一：命令行直接调用插件目标（goal）"><a href="#✅-方式一：命令行直接调用插件目标（goal）" class="headerlink" title="✅ 方式一：命令行直接调用插件目标（goal）"></a>✅ 方式一：<strong>命令行直接调用插件目标（goal）</strong></h3><p>你手动执行插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mvn [plugin-name]:[goal-name]</span><br><span class="line">mvn <span class="built_in">exec</span>:java -Dexec.mainClass=com.example.Main</span><br><span class="line">mvn antrun:run</span><br><span class="line">mvn myplugin:mygoal</span><br></pre></td></tr></table></figure><blockquote><p>这种方式叫做：<strong>直接调用目标（Direct goal invocation）</strong></p></blockquote><p>插件在命令执行时立即触发，仅执行该插件目标，不涉及生命周期。</p><hr><h3 id="✅-方式二：插件绑定到生命周期阶段自动执行"><a href="#✅-方式二：插件绑定到生命周期阶段自动执行" class="headerlink" title="✅ 方式二：插件绑定到生命周期阶段自动执行"></a>✅ 方式二：<strong>插件绑定到生命周期阶段自动执行</strong></h3><p>你执行生命周期命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mvn compile</span><br><span class="line">mvn package</span><br><span class="line">mvn install</span><br></pre></td></tr></table></figure><blockquote><p>Maven 会自动执行 <strong>绑定到这些阶段的插件目标</strong></p></blockquote><h4 id="举个例子："><a href="#举个例子：" class="headerlink" title="举个例子："></a>举个例子：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn package</span><br></pre></td></tr></table></figure><p>Maven 会自动执行这些阶段（生命周期）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">validate → compile → test → package</span><br></pre></td></tr></table></figure><p>而每个阶段都有绑定的插件目标，例如：</p><table><thead><tr><th>阶段</th><th>执行插件</th><th>执行目标</th></tr></thead><tbody><tr><td><code>compile</code></td><td><code>maven-compiler-plugin</code></td><td><code>compile</code></td></tr><tr><td><code>test</code></td><td><code>maven-surefire-plugin</code></td><td><code>test</code></td></tr><tr><td><code>package</code></td><td><code>maven-jar-plugin</code>（或 war）</td><td><code>jar</code> &#x2F; <code>war</code></td></tr></tbody></table><p>这些插件是在<strong>执行阶段时自动被触发的</strong>。</p><hr><h2 id="🧱-二、插件执行条件一览表"><a href="#🧱-二、插件执行条件一览表" class="headerlink" title="🧱 二、插件执行条件一览表"></a>🧱 二、插件执行条件一览表</h2><table><thead><tr><th>插件配置方式</th><th>插件何时执行？</th><th>举例</th></tr></thead><tbody><tr><td>未绑定生命周期、命令行直接调用</td><td>只有你手动执行时才会运行</td><td><code>mvn exec:java</code></td></tr><tr><td>默认绑定（生命周期绑定了默认插件）</td><td>执行生命周期阶段命令时自动执行</td><td><code>mvn compile</code> 会调用 <code>maven-compiler-plugin</code></td></tr><tr><td>自定义绑定（通过 <code>&lt;executions&gt;</code> 配置）</td><td>绑定的阶段触发时执行该插件</td><td><code>mvn package</code> 会触发你绑定到 package 的插件</td></tr><tr><td>没有绑定也没有调用</td><td>永远不会执行</td><td>插件写了但没人用</td></tr></tbody></table><hr><ol><li>配置一个 <code>antrun</code> 插件，不绑定生命周期</li><li>执行 <code>mvn compile</code> → 不会执行插件</li><li>改成绑定到 <code>compile</code> 阶段</li><li>再执行 <code>mvn compile</code> → 插件被自动执行！</li></ol><hr><h1 id="插件分类"><a href="#插件分类" class="headerlink" title="插件分类"></a>插件分类</h1><h2 id="🧩-一、从功能维度分：Maven-插件的两大类"><a href="#🧩-一、从功能维度分：Maven-插件的两大类" class="headerlink" title="🧩 一、从功能维度分：Maven 插件的两大类"></a>🧩 一、从功能维度分：Maven 插件的两大类</h2><table><thead><tr><th>分类</th><th>配置位置</th><th>何时执行</th><th>说明</th></tr></thead><tbody><tr><td><strong>构建插件（Build Plugins）</strong></td><td><code>&lt;build&gt;&lt;plugins&gt;</code></td><td>构建时执行（compile、test、package 等）</td><td>参与生命周期流程</td></tr><tr><td><strong>报告插件（Reporting Plugins）</strong></td><td><code>&lt;reporting&gt;</code></td><td>执行 <code>mvn site</code> 时执行</td><td>生成项目文档和报告</td></tr></tbody></table><hr><h3 id="✅-构建插件（Build-Plugin）"><a href="#✅-构建插件（Build-Plugin）" class="headerlink" title="✅ 构建插件（Build Plugin）"></a>✅ 构建插件（Build Plugin）</h3><ul><li>执行时机：构建生命周期中，如 <code>mvn compile</code>、<code>mvn test</code>、<code>mvn package</code></li><li>配置位置：<code>&lt;build&gt;&lt;plugins&gt;</code></li><li>可通过 <code>&lt;executions&gt;</code> 绑定生命周期阶段</li><li>可以通过命令行手动调用目标（如 <code>mvn exec:java</code>）</li></ul><p>📌 示例插件：</p><table><thead><tr><th>插件</th><th>功能</th></tr></thead><tbody><tr><td><code>maven-compiler-plugin</code></td><td>编译 Java 代码</td></tr><tr><td><code>maven-surefire-plugin</code></td><td>运行单元测试</td></tr><tr><td><code>maven-jar-plugin</code> &#x2F; <code>maven-war-plugin</code></td><td>打包成 jar&#x2F;war</td></tr><tr><td><code>exec-maven-plugin</code></td><td>运行 Java 程序</td></tr><tr><td><code>maven-deploy-plugin</code></td><td>发布构建产物到远程仓库</td></tr></tbody></table><hr><h3 id="✅-报告插件（Reporting-Plugin）"><a href="#✅-报告插件（Reporting-Plugin）" class="headerlink" title="✅ 报告插件（Reporting Plugin）"></a>✅ 报告插件（Reporting Plugin）</h3><ul><li>执行时机：<code>mvn site</code> 执行时</li><li>配置位置：<code>&lt;reporting&gt;</code> 标签下</li><li>主要用于生成站点报告（依赖树、测试覆盖率、项目信息等）</li></ul><p>📌 示例插件：</p><table><thead><tr><th>插件</th><th>功能</th></tr></thead><tbody><tr><td><code>maven-project-info-reports-plugin</code></td><td>生成项目信息报告（依赖树、开发者、许可证等）</td></tr><tr><td><code>maven-surefire-report-plugin</code></td><td>测试报告</td></tr><tr><td><code>maven-javadoc-plugin</code></td><td>JavaDoc API 文档</td></tr><tr><td><code>maven-pmd-plugin</code></td><td>代码质量检查报告</td></tr></tbody></table><blockquote><p>注意：如果你用命令行执行报告插件的某个目标（如 <code>mvn javadoc:javadoc</code>），它不会使用 <code>&lt;reporting&gt;</code> 中的配置，而是使用 <code>&lt;build&gt;</code> 中的。</p></blockquote><hr><h2 id="🧠-二、从触发方式维度分：Maven-插件的执行分类"><a href="#🧠-二、从触发方式维度分：Maven-插件的执行分类" class="headerlink" title="🧠 二、从触发方式维度分：Maven 插件的执行分类"></a>🧠 二、从触发方式维度分：Maven 插件的执行分类</h2><table><thead><tr><th>类别</th><th>特点</th><th>触发方式</th><th>示例</th></tr></thead><tbody><tr><td><strong>生命周期绑定插件</strong></td><td>被绑定到某个阶段自动执行</td><td><code>mvn compile</code> <code>mvn package</code></td><td><code>maven-compiler-plugin</code>, <code>maven-surefire-plugin</code></td></tr><tr><td><strong>手动调用插件</strong></td><td>只能通过命令行手动调用目标</td><td><code>mvn dependency:tree</code></td><td><code>maven-dependency-plugin</code>, <code>exec-maven-plugin</code></td></tr><tr><td><strong>报告生成插件</strong></td><td>用于生成 HTML 报告</td><td><code>mvn site</code></td><td><code>maven-project-info-reports-plugin</code></td></tr></tbody></table><hr><h2 id="🔍-三、特殊分类（按功能细分）"><a href="#🔍-三、特殊分类（按功能细分）" class="headerlink" title="🔍 三、特殊分类（按功能细分）"></a>🔍 三、特殊分类（按功能细分）</h2><h3 id="🔨-编译与打包类"><a href="#🔨-编译与打包类" class="headerlink" title="🔨 编译与打包类"></a>🔨 编译与打包类</h3><ul><li><code>maven-compiler-plugin</code></li><li><code>maven-jar-plugin</code></li><li><code>maven-war-plugin</code></li><li><code>maven-assembly-plugin</code></li><li><code>maven-shade-plugin</code></li></ul><h3 id="🧪-测试类"><a href="#🧪-测试类" class="headerlink" title="🧪 测试类"></a>🧪 测试类</h3><ul><li><code>maven-surefire-plugin</code>（单元测试）</li><li><code>maven-failsafe-plugin</code>（集成测试）</li></ul><h3 id="📦-发布与依赖管理类"><a href="#📦-发布与依赖管理类" class="headerlink" title="📦 发布与依赖管理类"></a>📦 发布与依赖管理类</h3><ul><li><code>maven-install-plugin</code></li><li><code>maven-deploy-plugin</code></li><li><code>maven-dependency-plugin</code></li></ul><h3 id="📊-报告与文档类"><a href="#📊-报告与文档类" class="headerlink" title="📊 报告与文档类"></a>📊 报告与文档类</h3><ul><li><code>maven-javadoc-plugin</code></li><li><code>maven-site-plugin</code></li><li><code>maven-pmd-plugin</code></li><li><code>maven-checkstyle-plugin</code></li></ul><h3 id="🛠️-运行执行类"><a href="#🛠️-运行执行类" class="headerlink" title="🛠️ 运行执行类"></a>🛠️ 运行执行类</h3><ul><li><code>exec-maven-plugin</code></li><li><code>antrun-maven-plugin</code></li></ul><hr><h2 id="✅-总结一句话："><a href="#✅-总结一句话：" class="headerlink" title="✅ 总结一句话："></a>✅ 总结一句话：</h2><blockquote><p>Maven 插件从大的方向分为：</p><ul><li><strong>构建插件</strong>（参与 lifecycle）</li><li><strong>报告插件</strong>（参与 site 报告）</li></ul><p>然后又可以按功能细分为：编译、测试、打包、文档、发布、执行类等。</p></blockquote><hr><h1 id="插件CLI执行"><a href="#插件CLI执行" class="headerlink" title="插件CLI执行"></a>插件CLI执行</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mvn [plugin-prefix]:[goal]</span><br><span class="line">mvn javadoc:javadoc </span><br></pre></td></tr></table></figure><p>它的结构是：</p><table><thead><tr><th>部分</th><th>含义</th></tr></thead><tbody><tr><td><code>javadoc</code>（前半）</td><td>插件前缀（plugin prefix）</td></tr><tr><td><code>javadoc</code>（后半）</td><td>插件目标（goal）</td></tr></tbody></table><p>javadoc 这个前缀，是 Maven 根据 插件的 artifactId 映射的默认前缀<br>实际使用的插件是：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-javadoc-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br></pre></td></tr></table></figure><p>你没有写 <code>maven-javadoc-plugin:javadoc</code>，但 Maven 会自动通过前缀 <code>javadoc</code> 去找这个插件。</p><h2 id="🔍-Maven-是怎么知道-javadoc-前缀对应哪个插件的？"><a href="#🔍-Maven-是怎么知道-javadoc-前缀对应哪个插件的？" class="headerlink" title="🔍 Maven 是怎么知道 javadoc 前缀对应哪个插件的？"></a>🔍 Maven 是怎么知道 <code>javadoc</code> 前缀对应哪个插件的？</h2><p>它查的是插件 <code>META-INF/maven/plugin.xml</code> 中的 <code>&lt;goalPrefix&gt;</code> 字段。</p><p>比如 <code>maven-javadoc-plugin</code> 插件里就定义了：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">goalPrefix</span>&gt;</span>javadoc<span class="tag">&lt;/<span class="name">goalPrefix</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所以你才能用 <code>mvn javadoc:javadoc</code> 简写命令。</p><hr><h2 id="✅-怎么确认某个前缀对应哪个插件？"><a href="#✅-怎么确认某个前缀对应哪个插件？" class="headerlink" title="✅ 怎么确认某个前缀对应哪个插件？"></a>✅ 怎么确认某个前缀对应哪个插件？</h2><p>使用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn <span class="built_in">help</span>:describe -Dplugin=javadoc</span><br></pre></td></tr></table></figure><p>输出中你会看到：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Name: Maven Javadoc Plugin</span><br><span class="line">Prefix: javadoc</span><br><span class="line">Group Id: org.apache.maven.plugins</span><br><span class="line">Artifact Id: maven-javadoc-plugin</span><br><span class="line">Version: ...</span><br></pre></td></tr></table></figure><hr><h1 id="查询插件详细信息"><a href="#查询插件详细信息" class="headerlink" title="查询插件详细信息"></a>查询插件详细信息</h1><p>当需要查询某个插件的信息时候执行，执行完会输出一堆信息代表什么意思呢<br>mvn help:describe -Dplugin&#x3D;javadoc</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">(base) ➜  ~ mvn help:describe -Dplugin=javadoc</span><br><span class="line"></span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] ------------------&lt; org.apache.maven:standalone-pom &gt;-------------------</span><br><span class="line">[INFO] Building Maven Stub Project (No POM) 1</span><br><span class="line">[INFO] --------------------------------[ pom ]---------------------------------</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- help:3.5.1:describe (default-cli) @ standalone-pom ---</span><br><span class="line">Downloading from central: https://repo.maven.apache.org/maven2/org/apache/maven/plugins/maven-javadoc-plugin/maven-metadata.xml</span><br><span class="line">Downloaded from central: https://repo.maven.apache.org/maven2/org/apache/maven/plugins/maven-javadoc-plugin/maven-metadata.xml (1.6 kB at 4.7 kB/s)</span><br><span class="line">Downloading from central: https://repo.maven.apache.org/maven2/org/apache/maven/plugins/maven-javadoc-plugin/3.11.2/maven-javadoc-plugin-3.11.2.pom</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line">Name: Apache Maven Javadoc Plugin</span><br><span class="line">Description: The Apache Maven Javadoc Plugin is a plugin that uses the</span><br><span class="line">  javadoc tool for generating javadocs for the specified project.</span><br><span class="line">Group Id: org.apache.maven.plugins</span><br><span class="line">Artifact Id: maven-javadoc-plugin</span><br><span class="line">Version: 3.11.2</span><br><span class="line">Goal Prefix: javadoc</span><br><span class="line"></span><br><span class="line">This plugin has 17 goals:</span><br><span class="line"></span><br><span class="line">javadoc:aggregate</span><br><span class="line">  Description: Generates documentation for the Java code in an aggregator</span><br><span class="line">    project using the standard Javadoc Tool . Since version 3.1.0 an aggregated</span><br><span class="line">    report is created for every module of a Maven multimodule project.</span><br><span class="line">  Note: This goal should be used as a Maven report.</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">For more information, run &#x27;mvn help:describe [...] -Ddetail&#x27;</span><br><span class="line"></span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  7.184 s</span><br><span class="line">[INFO] Finished at: 2025-03-28T10:25:41+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><hr><h2 id="🔍-一、Scanning-for-projects-是在干嘛？"><a href="#🔍-一、Scanning-for-projects-是在干嘛？" class="headerlink" title="🔍 一、Scanning for projects... 是在干嘛？"></a>🔍 一、<code>Scanning for projects...</code> 是在干嘛？</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[INFO] Scanning for projects...</span><br></pre></td></tr></table></figure><p>这是 Maven 的标准启动流程中的第一步，它会：</p><h3 id="✅-尝试在当前目录下查找是否存在一个-Maven-项目"><a href="#✅-尝试在当前目录下查找是否存在一个-Maven-项目" class="headerlink" title="✅ 尝试在当前目录下查找是否存在一个 Maven 项目"></a>✅ 尝试在<strong>当前目录下</strong>查找是否存在一个 Maven 项目</h3><ul><li>它会扫描当前目录及其父目录，看有没有 <code>pom.xml</code></li><li>如果没有，就会创建一个 <strong>默认的占位项目（Stub Project）</strong>，这个项目是虚拟的，不写磁盘，不留痕迹，不用删除。输出你看到的：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[INFO] Building Maven Stub Project (No POM) 1</span><br></pre></td></tr></table></figure><p>📌 你当前目录下<strong>没有 <code>pom.xml</code></strong>，所以 Maven就自动构造了一个“空项目”来执行你的 <code>help</code> 命令。</p><hr><h2 id="📦-二、为什么要从中央仓库下载插件？"><a href="#📦-二、为什么要从中央仓库下载插件？" class="headerlink" title="📦 二、为什么要从中央仓库下载插件？"></a>📦 二、为什么要从中央仓库下载插件？</h2><p>你执行的命令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn <span class="built_in">help</span>:describe -Dplugin=javadoc</span><br></pre></td></tr></table></figure><p>这条命令的含义是：</p><blockquote><p>👉 请告诉我 <strong>前缀为 <code>javadoc</code></strong> 的插件信息（如它绑定的目标、支持的参数等）</p></blockquote><h3 id="🔽-于是-Maven-要做什么？"><a href="#🔽-于是-Maven-要做什么？" class="headerlink" title="🔽 于是 Maven 要做什么？"></a>🔽 于是 Maven 要做什么？</h3><ol><li>先查你本地仓库（<code>~/.m2/repository</code>）有没有 <code>maven-javadoc-plugin</code></li><li>没有找到或版本不完整，就会去 <strong>中央仓库</strong> 下载</li><li>下载的是：</li></ol><table><thead><tr><th>下载内容</th><th>作用</th></tr></thead><tbody><tr><td><code>maven-metadata.xml</code></td><td>获取该插件的可用版本列表</td></tr><tr><td><code>maven-javadoc-plugin-3.11.2.pom</code></td><td>获取插件描述文件，包括 <code>&lt;goalPrefix&gt;</code></td></tr><tr><td><code>plugin.xml</code>（在 jar 包内）</td><td>提供目标、参数等详细信息，Maven 会读取它生成 describe 输出</td></tr></tbody></table><hr><h2 id="📂-三、下载的这些文件保存到哪里？"><a href="#📂-三、下载的这些文件保存到哪里？" class="headerlink" title="📂 三、下载的这些文件保存到哪里？"></a>📂 三、下载的这些文件保存到哪里？</h2><p>下载到你本地的 Maven 仓库路径：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.m2/repository/org/apache/maven/plugins/maven-javadoc-plugin/3.11.2/</span><br></pre></td></tr></table></figure><p>你可以直接去这个路径下看到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">maven-javadoc-plugin-3.11.2.jar</span><br><span class="line">maven-javadoc-plugin-3.11.2.pom</span><br></pre></td></tr></table></figure><hr><h2 id="✅-四、补充说明：即使你只是查个帮助，它也需要插件本体"><a href="#✅-四、补充说明：即使你只是查个帮助，它也需要插件本体" class="headerlink" title="✅ 四、补充说明：即使你只是查个帮助，它也需要插件本体"></a>✅ 四、补充说明：即使你只是查个帮助，它也需要插件本体</h2><p>这是因为：</p><ul><li><code>help:describe</code> 命令要解析插件的 <code>plugin.xml</code>（包含所有参数说明）</li><li>这个文件在插件 jar 包中</li><li>所以必须下载插件本体</li></ul><hr><h2 id="✅-总结一句话"><a href="#✅-总结一句话" class="headerlink" title="✅ 总结一句话"></a>✅ 总结一句话</h2><blockquote><p>Maven 每次执行命令前，都会扫描当前目录查找项目（<code>pom.xml</code>）<br>如果没有，就创建临时项目继续执行<br>如果你请求插件信息，而本地没有插件，就会从中央仓库下载<br>下载内容默认存储在本地仓库：<code>~/.m2/repository</code>，下次不会重复下载</p></blockquote><hr><h2 id="🎯-问题：为什么执行-mvn-help-describe-没有构建项目，最后还显示："><a href="#🎯-问题：为什么执行-mvn-help-describe-没有构建项目，最后还显示：" class="headerlink" title="🎯 问题：为什么执行 mvn help:describe 没有构建项目，最后还显示："></a>🎯 问题：为什么执行 <code>mvn help:describe</code> 没有构建项目，最后还显示：</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[INFO] BUILD SUCCESS</span><br></pre></td></tr></table></figure><p>是不是很像你做了一件“没啥好构建”的事，结果却说“构建成功”？那这个“BUILD”到底构建了啥？</p><hr><h2 id="✅-实际上，这个-BUILD-SUCCESS-是-Maven-的通用提示语"><a href="#✅-实际上，这个-BUILD-SUCCESS-是-Maven-的通用提示语" class="headerlink" title="✅ 实际上，这个 BUILD SUCCESS 是 Maven 的通用提示语"></a>✅ 实际上，这个 <strong>BUILD SUCCESS 是 Maven 的通用提示语</strong></h2><p>无论你执行的命令是不是构建类命令（如 <code>compile</code>、<code>package</code>），Maven 在整个流程顺利完成时，都会统一输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[INFO] BUILD SUCCESS</span><br></pre></td></tr></table></figure><p>它的含义其实更接近于：</p><blockquote><p>🟢 “这条 Maven 命令执行成功，没有错误发生。”</p></blockquote><p>并不代表你“真的构建了一个项目”或“打了个包”。</p><hr><h2 id="🧠-举个例子帮助你理解："><a href="#🧠-举个例子帮助你理解：" class="headerlink" title="🧠 举个例子帮助你理解："></a>🧠 举个例子帮助你理解：</h2><table><thead><tr><th>执行命令</th><th>实际干的事</th><th>是否输出 BUILD SUCCESS</th></tr></thead><tbody><tr><td><code>mvn compile</code></td><td>编译项目代码</td><td>✅</td></tr><tr><td><code>mvn package</code></td><td>打包成 jar&#x2F;war</td><td>✅</td></tr><tr><td><code>mvn help:describe -Dplugin=compiler</code></td><td>查询插件信息</td><td>✅</td></tr><tr><td><code>mvn dependency:tree</code></td><td>打印依赖树</td><td>✅</td></tr><tr><td><code>mvn clean</code></td><td>删除 <code>target</code> 目录</td><td>✅</td></tr></tbody></table><p>只要命令执行<strong>没有报错、退出码为 0</strong>，就会显示 <code>BUILD SUCCESS</code>。</p><hr><h2 id="🛠️-那如果出错会看到什么？"><a href="#🛠️-那如果出错会看到什么？" class="headerlink" title="🛠️ 那如果出错会看到什么？"></a>🛠️ 那如果出错会看到什么？</h2><p>比如拼错插件名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn foo:bar</span><br></pre></td></tr></table></figure><p>你会看到：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ERROR] No plugin found for prefix &#x27;foo&#x27;...</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD FAILURE</span><br></pre></td></tr></table></figure><hr><blockquote><p><code>BUILD SUCCESS</code> ≠ 真正构建了项目，而是表示：<strong>Maven 本次命令流程执行成功，没出错。</strong></p></blockquote><hr><h1 id="🧰-mvn-help-describe-常用命令速查"><a href="#🧰-mvn-help-describe-常用命令速查" class="headerlink" title="🧰 mvn help:describe 常用命令速查"></a>🧰 <code>mvn help:describe</code> 常用命令速查</h1><hr><h2 id="✅-1-查看某个插件的基本信息（不指定目标）"><a href="#✅-1-查看某个插件的基本信息（不指定目标）" class="headerlink" title="✅ 1. 查看某个插件的基本信息（不指定目标）"></a>✅ 1. 查看某个插件的基本信息（不指定目标）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn <span class="built_in">help</span>:describe -Dplugin=compiler</span><br></pre></td></tr></table></figure><p>输出内容：</p><ul><li>插件名称、前缀（prefix）</li><li>groupId &#x2F; artifactId &#x2F; version</li><li>支持的目标（goals）</li></ul><hr><h2 id="✅-2-查看插件某个目标（goal）的详细参数（常用）"><a href="#✅-2-查看插件某个目标（goal）的详细参数（常用）" class="headerlink" title="✅ 2. 查看插件某个目标（goal）的详细参数（常用）"></a>✅ 2. 查看插件某个目标（goal）的详细参数（常用）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn <span class="built_in">help</span>:describe -Dplugin=compiler -Dgoal=compile -Ddetail</span><br></pre></td></tr></table></figure><p>输出内容：</p><ul><li><code>compile</code> 目标的参数列表</li><li>参数名、类型、是否必填、默认值、配置方式（CLI or POM）</li><li>有效的表达式（如 <code>$&#123;project.build.sourceDirectory&#125;</code>）</li></ul><hr><h2 id="✅-3-查看插件使用的版本（你当前项目中实际使用的）"><a href="#✅-3-查看插件使用的版本（你当前项目中实际使用的）" class="headerlink" title="✅ 3. 查看插件使用的版本（你当前项目中实际使用的）"></a>✅ 3. 查看插件使用的版本（你当前项目中实际使用的）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn <span class="built_in">help</span>:describe -Dplugin=compiler -Ddetail</span><br></pre></td></tr></table></figure><p>Maven 会自动解析插件来自哪里，显示当前版本。</p><p>🧠 如果你没有手动指定 <code>&lt;version&gt;</code>，它也会显示默认使用的版本（来自超级 POM 或 pluginManagement）</p><hr><h2 id="✅-4-查某个插件命令的完整结构"><a href="#✅-4-查某个插件命令的完整结构" class="headerlink" title="✅ 4. 查某个插件命令的完整结构"></a>✅ 4. 查某个插件命令的完整结构</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn <span class="built_in">help</span>:describe -Dplugin=<span class="built_in">exec</span> -Dgoal=java -Ddetail</span><br></pre></td></tr></table></figure><p>可以看到 <code>exec:java</code> 的所有支持参数，比如 <code>mainClass</code>、<code>arguments</code> 等，非常适合调试 CLI 运行问题。</p><hr><h2 id="✅-5-查命令背后的插件是谁（前缀映射）"><a href="#✅-5-查命令背后的插件是谁（前缀映射）" class="headerlink" title="✅ 5. 查命令背后的插件是谁（前缀映射）"></a>✅ 5. 查命令背后的插件是谁（前缀映射）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn <span class="built_in">help</span>:describe -Dplugin=javadoc</span><br></pre></td></tr></table></figure><p>输出内容包含：</p><ul><li>plugin prefix：javadoc</li><li>groupId&#x2F;artifactId：<code>org.apache.maven.plugins:maven-javadoc-plugin</code></li><li>所有目标（goals）</li></ul><p>📌 适合解释 “mvn javadoc:javadoc” 背后到底是谁在干活。</p><hr><h2 id="只知道-artifactId-时的处理技巧"><a href="#只知道-artifactId-时的处理技巧" class="headerlink" title="只知道 artifactId 时的处理技巧"></a>只知道 artifactId 时的处理技巧</h2><p>你知道它叫 <code>maven-compiler-plugin</code>，Maven 默认插件都在同一个 group 下，可以写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn <span class="built_in">help</span>:describe -Dplugin=org.apache.maven.plugins:maven-compiler-plugin</span><br></pre></td></tr></table></figure><p>🔍 输出会告诉你：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Name: Maven Compiler Plugin</span><br><span class="line">Prefix: compiler</span><br><span class="line">Group Id: org.apache.maven.plugins</span><br><span class="line">Artifact Id: maven-compiler-plugin</span><br></pre></td></tr></table></figure><p>现在你就知道它的前缀是 <code>compiler</code> 了，可以写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn <span class="built_in">help</span>:describe -Dplugin=compiler -Dgoal=compile -Ddetail</span><br></pre></td></tr></table></figure><hr><h2 id="📋-进阶技巧提示"><a href="#📋-进阶技巧提示" class="headerlink" title="📋 进阶技巧提示"></a>📋 进阶技巧提示</h2><h3 id="✅-想查询多个插件？循环执行："><a href="#✅-想查询多个插件？循环执行：" class="headerlink" title="✅ 想查询多个插件？循环执行："></a>✅ 想查询多个插件？循环执行：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> plugin <span class="keyword">in</span> compiler surefire jar site; <span class="keyword">do</span></span><br><span class="line">  mvn <span class="built_in">help</span>:describe -Dplugin=<span class="variable">$plugin</span> -Ddetail</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h3 id="✅-搭配-mvn-help-effective-pom-使用"><a href="#✅-搭配-mvn-help-effective-pom-使用" class="headerlink" title="✅ 搭配 mvn help:effective-pom 使用"></a>✅ 搭配 <code>mvn help:effective-pom</code> 使用</h3><p>先查看实际插件版本，再查该插件的参数定义。</p><hr><h2 id="🧠-总结一句话："><a href="#🧠-总结一句话：" class="headerlink" title="🧠 总结一句话："></a>🧠 总结一句话：</h2><blockquote><p><code>mvn help:describe</code> 是调试 Maven 插件的利器，能帮你：</p><ul><li>查插件来源</li><li>看支持哪些目标（goals）</li><li>每个目标支持哪些参数（含默认值、表达式）</li><li>判断插件版本是否匹配</li></ul></blockquote><hr><h1 id="mvn-命令参数的含义"><a href="#mvn-命令参数的含义" class="headerlink" title="mvn 命令参数的含义"></a>mvn 命令参数的含义</h1><h2 id="🧩-一、-D-参数到底是什么？"><a href="#🧩-一、-D-参数到底是什么？" class="headerlink" title="🧩 一、-D 参数到底是什么？"></a>🧩 一、<code>-D</code> 参数到底是什么？</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn compile -Dkey=value</span><br></pre></td></tr></table></figure><p>这个 <code>-D</code> 是 JVM 的标准参数格式，在 Maven 中：</p><blockquote><p>✅ 用于向 Maven 或插件传递<strong>系统属性（System Property）</strong></p></blockquote><p>常见用途：</p><ul><li>给插件传递参数（如 <code>-Dexec.mainClass=...</code>）</li><li>控制 profile 激活（如 <code>-Denv=prod</code>）</li><li>覆盖 POM 中的 <code>$&#123;property&#125;</code> 变量</li></ul><p>📌 例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mvn <span class="built_in">exec</span>:java -Dexec.mainClass=com.example.Main</span><br><span class="line">mvn <span class="built_in">help</span>:describe -Dplugin=compiler</span><br></pre></td></tr></table></figure><hr><h2 id="🔍-二、除了-D，Maven-命令还支持哪些参数？"><a href="#🔍-二、除了-D，Maven-命令还支持哪些参数？" class="headerlink" title="🔍 二、除了 -D，Maven 命令还支持哪些参数？"></a>🔍 二、除了 <code>-D</code>，Maven 命令还支持哪些参数？</h2><h3 id="✅-常用参数分类速查表："><a href="#✅-常用参数分类速查表：" class="headerlink" title="✅ 常用参数分类速查表："></a>✅ 常用参数分类速查表：</h3><table><thead><tr><th>参数</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td><code>-D</code></td><td>设置系统属性</td><td><code>-DskipTests=true</code></td></tr><tr><td><code>-P</code></td><td>激活 Profile</td><td><code>-Pdev</code></td></tr><tr><td><code>-pl</code></td><td>指定模块构建（multi-module 项目）</td><td><code>-pl service-a</code></td></tr><tr><td><code>-am</code></td><td>同时构建依赖模块</td><td><code>-pl web -am</code></td></tr><tr><td><code>-f</code></td><td>指定 POM 文件路径</td><td><code>-f ../some-other-pom.xml</code></td></tr><tr><td><code>-U</code></td><td>强制更新远程仓库 SNAPSHOT</td><td><code>-U</code></td></tr><tr><td><code>-X</code></td><td>打印调试日志</td><td><code>-X</code></td></tr><tr><td><code>-e</code></td><td>显示完整异常栈</td><td><code>-e</code></td></tr><tr><td><code>-B</code></td><td>批处理模式（适合脚本中使用）</td><td><code>-B</code></td></tr><tr><td><code>-q</code></td><td>静默模式（Quiet）</td><td><code>-q</code></td></tr><tr><td><code>-s</code></td><td>指定 <code>settings.xml</code> 文件</td><td><code>-s ~/.m2/mysettings.xml</code></td></tr><tr><td><code>-gs</code></td><td>指定全局 <code>settings.xml</code> 文件</td><td><code>-gs /path/to/settings.xml</code></td></tr><tr><td><code>-rf</code></td><td>从指定模块重新构建</td><td><code>-rf service-a</code></td></tr><tr><td><code>-T</code></td><td>并行构建线程数（如 <code>-T 4C</code>）</td><td><code>-T 2</code>、<code>-T 1C</code></td></tr><tr><td><code>--fail-at-end</code></td><td>构建失败后继续剩下模块</td><td>-</td></tr></tbody></table><hr><h2 id="🛠️-四、实用组合示例："><a href="#🛠️-四、实用组合示例：" class="headerlink" title="🛠️ 四、实用组合示例："></a>🛠️ 四、实用组合示例：</h2><table><thead><tr><th>目的</th><th>示例</th></tr></thead><tbody><tr><td>跳过测试打包</td><td><code>mvn clean package -DskipTests=true</code></td></tr><tr><td>运行指定 profile 的打包流程</td><td><code>mvn package -Pprod</code></td></tr><tr><td>执行 main 方法</td><td><code>mvn exec:java -Dexec.mainClass=com.example.Main</code></td></tr><tr><td>查看插件信息</td><td><code>mvn help:describe -Dplugin=compiler -Dgoal=compile -Ddetail</code></td></tr><tr><td>多模块只构建一部分</td><td><code>mvn install -pl api -am</code></td></tr><tr><td>用测试 settings 构建</td><td><code>mvn deploy -s test-settings.xml</code></td></tr></tbody></table><hr><h2 id="✅-总结"><a href="#✅-总结" class="headerlink" title="✅ 总结"></a>✅ 总结</h2><blockquote><p><code>-D</code> 是最常用的系统属性传参，但 Maven 命令支持 <strong>丰富的参数组合</strong>，你可以控制 profile、模块、线程数、输出模式等，非常适合灵活构建和调试。</p></blockquote><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><hr><h2 id="超级POM在哪个目录"><a href="#超级POM在哪个目录" class="headerlink" title="超级POM在哪个目录"></a>超级POM在哪个目录</h2><p>超级 POM 并不直接以文件形式存储在你的磁盘中。<br>它是 Maven 内部的默认资源，打包在 Maven 的核心 Jar 包里。</p><h2 id="在当前项目下执行mvn命令和在任何一个其他地方执行mvn命令有什么区别"><a href="#在当前项目下执行mvn命令和在任何一个其他地方执行mvn命令有什么区别" class="headerlink" title="在当前项目下执行mvn命令和在任何一个其他地方执行mvn命令有什么区别"></a>在当前项目下执行mvn命令和在任何一个其他地方执行mvn命令有什么区别</h2><p>✅ 在项目目录下执行 mvn 命令：<br>Maven 会读取当前目录的 pom.xml，按你的项目配置执行构建、依赖管理、插件绑定等。</p><p>✅ 在非项目目录下执行：<br>Maven 没找到 pom.xml，只能执行不依赖项目结构的命令（如 help:describe、dependency:get），否则会报错或生成一个临时的“Stub 项目”。</p><p>有 POM 就构建你的项目，没 POM 就只能玩工具命令。</p><h2 id="settings文件和超级POM和普通的POM什么关系"><a href="#settings文件和超级POM和普通的POM什么关系" class="headerlink" title="settings文件和超级POM和普通的POM什么关系"></a>settings文件和超级POM和普通的POM什么关系</h2><p>✅ settings.xml 是用户级 &#x2F; 全局配置文件<br>✅ 超级 POM 是 Maven 提供的默认项目模板<br>✅ 项目 POM 是你当前项目自己的构建定义<br>👉 真正的 Maven 构建行为，是这三者共同作用、分工明确，而且有明确的优先级关系</p><hr><h3 id="🧠-三者核心作用对比表"><a href="#🧠-三者核心作用对比表" class="headerlink" title="🧠 三者核心作用对比表"></a>🧠 三者核心作用对比表</h3><table><thead><tr><th>维度</th><th><code>settings.xml</code></th><th><strong>超级 POM</strong></th><th><strong>项目 POM (<code>pom.xml</code>)</strong></th></tr></thead><tbody><tr><td>角色</td><td>用户或环境级配置</td><td>Maven 内置默认模板</td><td>项目自定义配置</td></tr><tr><td>控制范围</td><td>仓库、代理、镜像、profile 激活等</td><td>生命周期默认配置、插件绑定、中央仓库</td><td>项目的依赖、插件、模块、构建</td></tr><tr><td>配置位置</td><td><code>~/.m2/settings.xml</code> 或 Maven 安装目录</td><td>Maven 的内部 JAR 包中</td><td>当前项目根目录</td></tr><tr><td>是否可见</td><td>✅ 可以编辑</td><td>❌ 不可直接编辑</td><td>✅ 你自己写的</td></tr><tr><td>是否必须</td><td>❌ 可选</td><td>✅ 始终存在</td><td>✅ Maven 项目的核心</td></tr><tr><td>典型用途</td><td>配置私服仓库、镜像源、激活 profile</td><td>定义默认插件行为、目录结构</td><td>声明依赖、执行目标、构建产物等</td></tr></tbody></table><hr><h3 id="🔄-三者的继承-覆盖关系（优先级）"><a href="#🔄-三者的继承-覆盖关系（优先级）" class="headerlink" title="🔄 三者的继承 &#x2F; 覆盖关系（优先级）"></a>🔄 三者的继承 &#x2F; 覆盖关系（优先级）</h3><p>Maven 的执行逻辑中，这三者有如下关系：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+</span><br><span class="line">|  settings.xml      | ← 环境控制（镜像、私服、Profile 激活）</span><br><span class="line">+--------------------+</span><br><span class="line">          ↓</span><br><span class="line">+--------------------+</span><br><span class="line">|  超级 POM          | ← 默认行为（中央仓库、默认插件绑定）</span><br><span class="line">+--------------------+</span><br><span class="line">          ↓</span><br><span class="line">+--------------------+</span><br><span class="line">|  项目 POM (你写的) | ← 构建计划、依赖声明、插件配置</span><br><span class="line">+--------------------+</span><br></pre></td></tr></table></figure><p>👉 项目 POM 可以覆盖超级 POM 的设置<br>👉 settings.xml 可以控制环境行为，但<strong>不能声明依赖</strong></p><hr><h3 id="🎯-举几个典型对比场景："><a href="#🎯-举几个典型对比场景：" class="headerlink" title="🎯 举几个典型对比场景："></a>🎯 举几个典型对比场景：</h3><table><thead><tr><th>配置项</th><th>写在哪里</th><th>说明</th></tr></thead><tbody><tr><td>使用私服 Nexus</td><td>✅ <code>settings.xml</code> → 配置 <code>&lt;mirrors&gt;</code></td><td></td></tr><tr><td>默认构建插件行为（如 jar）</td><td>🧩 超级 POM 已绑定</td><td>项目 POM 可以覆盖插件版本</td></tr><tr><td>引入某个依赖（如 Spring Boot）</td><td>✅ 项目 POM</td><td>不能写在 <code>settings.xml</code></td></tr><tr><td>使用 JDK 版本</td><td>✅ 项目 POM <code>&lt;properties&gt;</code></td><td><code>settings.xml</code> 不负责构建参数</td></tr></tbody></table><hr><h2 id="怎么看当前项目用了哪些插件？”"><a href="#怎么看当前项目用了哪些插件？”" class="headerlink" title="怎么看当前项目用了哪些插件？”"></a>怎么看当前项目用了哪些插件？”</h2><h3 id="✅-一句话速答："><a href="#✅-一句话速答：" class="headerlink" title="✅ 一句话速答："></a>✅ 一句话速答：</h3><blockquote><p>使用 <code>mvn help:effective-pom</code> 命令，可以看到当前项目<strong>生效的所有插件</strong>（包括显式写的 + 继承的 + 默认的）。</p></blockquote><hr><h3 id="🧩-方法一：用-mvn-help-effective-pom"><a href="#🧩-方法一：用-mvn-help-effective-pom" class="headerlink" title="🧩 方法一：用 mvn help:effective-pom"></a>🧩 方法一：用 <code>mvn help:effective-pom</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn <span class="built_in">help</span>:effective-pom</span><br></pre></td></tr></table></figure><p>它会输出合并后的完整 POM 内容，包括：</p><ul><li>你自己写在 <code>&lt;plugins&gt;</code> 和 <code>&lt;pluginManagement&gt;</code> 中的插件</li><li>父 POM 中继承的插件</li><li>超级 POM 自动引入的插件（如 <code>maven-compiler-plugin</code>, <code>maven-jar-plugin</code>）</li></ul><p>📌 搜索关键词：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugins&gt;</span><br></pre></td></tr></table></figure><p>可以快速定位所有插件配置。</p><hr><h3 id="🛠-方法二：从-target-目录的-effective-pom-xml-查看（如果生成了）"><a href="#🛠-方法二：从-target-目录的-effective-pom-xml-查看（如果生成了）" class="headerlink" title="🛠 方法二：从 target 目录的 effective-pom.xml 查看（如果生成了）"></a>🛠 方法二：从 <code>target</code> 目录的 <code>effective-pom.xml</code> 查看（如果生成了）</h3><p>部分构建工具（如 IDEA）或 CI 流水线也可能会生成合并后的 POM：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target/effective-pom.xml</span><br></pre></td></tr></table></figure><p>可以直接查看里面所有 plugin 配置。</p><hr><h3 id="🔍-方法三：查看构建日志时的插件调用（动态观察）"><a href="#🔍-方法三：查看构建日志时的插件调用（动态观察）" class="headerlink" title="🔍 方法三：查看构建日志时的插件调用（动态观察）"></a>🔍 方法三：查看构建日志时的插件调用（动态观察）</h3><p>执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn package -X</span><br></pre></td></tr></table></figure><p>或加 <code>-X</code> 查看完整日志，控制台中会显示：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[INFO] --- maven-compiler-plugin:3.10.1:compile (default-compile) @ your-project ---</span><br><span class="line">[INFO] --- maven-jar-plugin:3.2.2:jar (default-jar) @ your-project ---</span><br></pre></td></tr></table></figure><p>这能看到<strong>哪些插件在生命周期中被调用了、调用的是哪个目标</strong>，非常适合观察实际构建流程。</p><hr><h3 id="✅-实践："><a href="#✅-实践：" class="headerlink" title="✅ 实践："></a>✅ 实践：</h3><ol><li>写一个最简单的 POM（不配置任何插件）</li><li>执行：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn <span class="built_in">help</span>:effective-pom</span><br></pre></td></tr></table></figure></li><li>观察仍然有很多插件（默认从超级 POM继承）</li><li>加上自定义插件，观察插件列表发生变化</li></ol><hr><h3 id="✅-总结-1"><a href="#✅-总结-1" class="headerlink" title="✅ 总结"></a>✅ 总结</h3><blockquote><p>查看当前项目用了哪些插件，最权威的方式是用：<br><strong><code>mvn help:effective-pom</code> → 查看 <code>&lt;plugins&gt;</code> 部分</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> java </category>
          
          <category> 框架 </category>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test1</title>
      <link href="/2025/03/27/test1/"/>
      <url>/2025/03/27/test1/</url>
      
        <content type="html"><![CDATA[<p>Mybatis是一个orm框架</p>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2025/03/27/test/"/>
      <url>/2025/03/27/test/</url>
      
        <content type="html"><![CDATA[<p>11223<br>Springboot 是一个开箱即用的框架</p>]]></content>
      
      
      <categories>
          
          <category> Springboot </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Snipaste + Hexo + GitHub + jsDelivr CDN 图床方案</title>
      <link href="/2025/03/27/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/Snipaste%20+%20Hexo%20+%20GitHub%20+%20jsDelivr%20CDN%20%E5%9B%BE%E5%BA%8A%E6%96%B9%E6%A1%88/"/>
      <url>/2025/03/27/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/Snipaste%20+%20Hexo%20+%20GitHub%20+%20jsDelivr%20CDN%20%E5%9B%BE%E5%BA%8A%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>完美的组合来了！你想在 <strong>macOS</strong> 上打造一个：</p><p>🚀 高效截图 → 自动上传 GitHub → 自动生成 CDN 图链 → Markdown 直接贴图</p><p>我为你设计了一套完整的 “Snipaste + Hexo + GitHub + jsDelivr CDN 图床方案”，让你<strong>截图即图床，图链即插用！</strong></p><hr><h2 id="✅-一图概览"><a href="#✅-一图概览" class="headerlink" title="✅ 一图概览"></a>✅ 一图概览</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Snipaste（截图标注）📸</span><br><span class="line">   ↓（复制到剪贴板）</span><br><span class="line">PicGo（自动上传）🚀</span><br><span class="line">   ↓（上传到 GitHub 图床）</span><br><span class="line">jsDelivr（CDN 加速）⚡</span><br><span class="line">   ↓</span><br><span class="line">Hexo Markdown 插图 ✅</span><br></pre></td></tr></table></figure><hr><h2 id="🧱-你需要的工具（全免费）"><a href="#🧱-你需要的工具（全免费）" class="headerlink" title="🧱 你需要的工具（全免费）"></a>🧱 你需要的工具（全免费）</h2><table><thead><tr><th>工具</th><th>用途</th><th>是否必须</th></tr></thead><tbody><tr><td><strong>Snipaste</strong></td><td>截图 + 标记（带贴图）</td><td>✅</td></tr><tr><td><strong>PicGo</strong></td><td>图床上传工具</td><td>✅</td></tr><tr><td><strong>GitHub</strong></td><td>图床存储（公开仓库）</td><td>✅</td></tr><tr><td><strong>jsDelivr</strong></td><td>CDN 加速 GitHub 图链</td><td>✅</td></tr><tr><td><strong>Hexo</strong></td><td>博客系统</td><td>✅</td></tr></tbody></table><hr><h2 id="🛠️-Step-by-Step-全流程配置"><a href="#🛠️-Step-by-Step-全流程配置" class="headerlink" title="🛠️ Step-by-Step 全流程配置"></a>🛠️ Step-by-Step 全流程配置</h2><hr><h3 id="📸-Step-1：安装-Snipaste-for-macOS"><a href="#📸-Step-1：安装-Snipaste-for-macOS" class="headerlink" title="📸 Step 1：安装 Snipaste for macOS"></a>📸 Step 1：安装 Snipaste for macOS</h3><ul><li>官网：<a href="https://snipaste.com/">https://snipaste.com</a></li><li>支持快捷键截图、标注、钉图</li><li>设置截图快捷键（如 <code>⌘ + Shift + A</code>）</li></ul><p>✅ <strong>截图后可自动复制到剪贴板（设置中开启）</strong></p><hr><h3 id="🚀-Step-2：安装-PicGo-配置-GitHub-图床"><a href="#🚀-Step-2：安装-PicGo-配置-GitHub-图床" class="headerlink" title="🚀 Step 2：安装 PicGo + 配置 GitHub 图床"></a>🚀 Step 2：安装 PicGo + 配置 GitHub 图床</h3><h4 id="安装-PicGo："><a href="#安装-PicGo：" class="headerlink" title="安装 PicGo："></a>安装 PicGo：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install --cask picgo</span><br></pre></td></tr></table></figure><p>或从官网下载：<a href="https://picgo.github.io/">https://picgo.github.io/</a></p><p>最近PicGo打开后一直提示安装更新的版本，于是去<code>gitHub</code>下载了最新版本，安装后打开，弹窗提示信息：<code>**文件已损坏，您应该将它移到废纸篓。**</code></p><h3 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h3><h4 id="1-打开终端输入"><a href="#1-打开终端输入" class="headerlink" title="1.打开终端输入"></a>1.打开终端输入</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> xattr -d com.apple.quarantine <span class="string">&quot;/Applications/PicGo.app&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># /Applications/PicGo.app 为程序安装的路径</span></span><br></pre></td></tr></table></figure><h4 id="2-根据终端提示输入登录密码，重新打开就可以了"><a href="#2-根据终端提示输入登录密码，重新打开就可以了" class="headerlink" title="2.根据终端提示输入登录密码，重新打开就可以了"></a>2.根据终端提示输入登录密码，重新打开就可以了</h4><h4 id="配置图床："><a href="#配置图床：" class="headerlink" title="配置图床："></a>配置图床：</h4><p>打开 PicGo → 图床设置 → 选择 <code>GitHub 图床</code>，填写以下信息：</p><table><thead><tr><th>项目</th><th>示例</th></tr></thead><tbody><tr><td>仓库名</td><td><code>你的用户名/hexo-img</code>（新建公开仓库）</td></tr><tr><td>分支</td><td><code>main</code></td></tr><tr><td>Token</td><td>GitHub Personal Access Token（含 repo 权限）</td></tr><tr><td>存储路径</td><td><code>img/</code>（可选）</td></tr><tr><td>自定义域名（CDN）不配CDN不用写</td><td><code>https://cdn.jsdelivr.net/gh/你的用户名/hexo-img@main</code></td></tr></tbody></table><p>👉 设置完成后，上传的每张图都会用 jsDelivr 加速图链 ✅</p><hr><h3 id="🎯-Step-3：绑定上传快捷键"><a href="#🎯-Step-3：绑定上传快捷键" class="headerlink" title="🎯 Step 3：绑定上传快捷键"></a>🎯 Step 3：绑定上传快捷键</h3><ul><li>打开 PicGo → 快捷键设置 → 设置「上传剪贴板图片」快捷键，例如：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Control + Option + P</span><br></pre></td></tr></table></figure><hr><h3 id="🧪-Step-4：测试上传"><a href="#🧪-Step-4：测试上传" class="headerlink" title="🧪 Step 4：测试上传"></a>🧪 Step 4：测试上传</h3><ol><li>用 Snipaste 截图 + 标注，完成后复制到剪贴板</li><li>按快捷键 <code>Ctrl + Opt + P</code></li><li>图片自动上传 GitHub，返回加速图链！</li></ol><p>示例输出图链：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](<span class="link">https://cdn.jsdelivr.net/gh/yourname/hexo-img@main/img/2025-03-27-hello.png</span>)</span><br></pre></td></tr></table></figure><p>粘贴到 Hexo Markdown 即可插图！</p><hr><h2 id="🧠-Tips：图片更新怎么处理？"><a href="#🧠-Tips：图片更新怎么处理？" class="headerlink" title="🧠 Tips：图片更新怎么处理？"></a>🧠 Tips：图片更新怎么处理？</h2><p>CDN 有缓存，如果你更新了图片但地址没变，可使用以下方式刷新：</p><table><thead><tr><th>方法</th><th>示例</th></tr></thead><tbody><tr><td>改文件名</td><td><code>cover-v2.png</code> 或 <code>cover-20250328.png</code></td></tr><tr><td>加参数</td><td><code>?v=2</code> → <code>cover.png?v=2</code>，可强制刷新</td></tr><tr><td>删除重传</td><td>直接从 GitHub 删除旧图，再上传新图</td></tr></tbody></table><hr><h2 id="🧰-Bonus：图床仓库推荐结构"><a href="#🧰-Bonus：图床仓库推荐结构" class="headerlink" title="🧰 Bonus：图床仓库推荐结构"></a>🧰 Bonus：图床仓库推荐结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo-img/</span><br><span class="line">├── img/</span><br><span class="line">│   ├── 2025-03/</span><br><span class="line">│   │   ├── pic-01.png</span><br><span class="line">│   │   └── cover-v2.png</span><br></pre></td></tr></table></figure><p>这样路径结构清晰，适合长期管理。</p><p>PicGo 支持动态路径！你可以设置路径自动按日期分类：</p><h4 id="🔧-PicGo-设置示例："><a href="#🔧-PicGo-设置示例：" class="headerlink" title="🔧 PicGo 设置示例："></a>🔧 PicGo 设置示例：</h4><p>打开 PicGo → 图床设置 → GitHub 图床 → 存储路径 填写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img/$&#123;year&#125;-$&#123;month&#125;/</span><br></pre></td></tr></table></figure><p>上面这个方法不靠谱，需要用到一个插件<a href="https://github.com/melon95/picgo-plugin-custom-path"><strong>picgo-plugin-custom-path</strong></a></p><p><strong>但是文件名有点长</strong></p><p><img src="https://cdn.jsdelivr.net/gh/neoisok/assets@main/images%2F2025%2F03%2F27%2F20250327234848693-f76bf6ed2a29672c38cd6101f3aaad75.png"></p><p>文件重命名开启<br><img src="https://cdn.jsdelivr.net/gh/neoisok/assets@main/images%2F2025%2F03%2F27%2F20250327234915338-5714bb2951fc86c47ab288ce853fe1fc.png" width=600></p><h2 id="📦-最终使用体验"><a href="#📦-最终使用体验" class="headerlink" title="📦 最终使用体验"></a>📦 最终使用体验</h2><table><thead><tr><th>动作</th><th>操作方式</th></tr></thead><tbody><tr><td>截图 + 标注</td><td>用 Snipaste <code>⌘ + Shift + A</code></td></tr><tr><td>上传图床</td><td><code>Ctrl + Option + P</code>（剪贴板上传）</td></tr><tr><td>粘贴图链</td><td>⌘ + V 粘贴 → Hexo 文章即可显示 ✅</td></tr><tr><td>图链走 CDN 加速</td><td>jsDelivr 提供全球 CDN，国内速度飞快</td></tr></tbody></table><hr><h2 id="✅-总结配置清单"><a href="#✅-总结配置清单" class="headerlink" title="✅ 总结配置清单"></a>✅ 总结配置清单</h2><table><thead><tr><th>工具</th><th>下载地址</th></tr></thead><tbody><tr><td>Snipaste</td><td><a href="https://snipaste.com/">https://snipaste.com</a></td></tr><tr><td>PicGo</td><td><a href="https://picgo.github.io/">https://picgo.github.io</a></td></tr><tr><td>GitHub 图床</td><td><a href="https://github.com/">https://github.com</a></td></tr><tr><td>jsDelivr CDN</td><td><a href="https://www.jsdelivr.com/">https://www.jsdelivr.com</a></td></tr></tbody></table><hr>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 图床 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git 操作详解</title>
      <link href="/2025/03/27/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/git%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3/"/>
      <url>/2025/03/27/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/git%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="git清除缓存"><a href="#git清除缓存" class="headerlink" title="git清除缓存"></a>git清除缓存</h1><p>你遇到的这个问题，是由于之前<strong>嵌套了 git 仓库</strong>，删除了 <code>themes/butterfly/.git</code> 后，又执行了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add themes/butterfly</span><br><span class="line">git commit -m &quot;添加 Butterfly 主题（非子模块）&quot;</span><br></pre></td></tr></table></figure><p>此时你的本地仓库正常了，但在 GitHub 上仍显示 Butterfly 文件夹为空，这是因为：</p><ul><li>Git 对嵌套仓库只保存了一个指针（子模块链接）。</li><li>当你删除 <code>.git</code> 文件夹后，实际上内容<strong>并未真正提交</strong>到远程仓库，Git 仍然只记录了主题文件夹的引用。</li></ul><p><strong>出现奇怪问题之后</strong></p><ul><li>彻底从 git 的缓存中移除旧引用。</li><li>然后重新执行 <code>git add</code> 和 <code>git commit</code> 提交所有文件。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached themes/butterfly -r</span><br><span class="line">git add themes/butterfly</span><br><span class="line">git commit -m &quot;重新添加 Butterfly 主题文件&quot;</span><br><span class="line">git push origin main</span><br></pre></td></tr></table></figure><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><hr><h2 id="🧱-一、仓库初始化-基础操作"><a href="#🧱-一、仓库初始化-基础操作" class="headerlink" title="🧱 一、仓库初始化 &amp; 基础操作"></a>🧱 一、仓库初始化 &amp; 基础操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git init                      <span class="comment"># 初始化本地 Git 仓库</span></span><br><span class="line">git <span class="built_in">clone</span> &lt;repo_url&gt;         <span class="comment"># 克隆远程仓库</span></span><br><span class="line">git status                   <span class="comment"># 查看当前状态（改动、未提交）</span></span><br><span class="line">git add &lt;file&gt;               <span class="comment"># 将文件加入暂存区（可以 . 表示全部）</span></span><br><span class="line">git commit -m <span class="string">&quot;备注信息&quot;</span>     <span class="comment"># 提交代码并添加说明</span></span><br></pre></td></tr></table></figure><hr><h2 id="🌿-二、分支操作"><a href="#🌿-二、分支操作" class="headerlink" title="🌿 二、分支操作"></a>🌿 二、分支操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git branch                   <span class="comment"># 查看本地所有分支</span></span><br><span class="line">git branch &lt;branch-name&gt;     <span class="comment"># 新建分支</span></span><br><span class="line">git checkout &lt;branch-name&gt;   <span class="comment"># 切换到分支</span></span><br><span class="line">git checkout -b &lt;branch-name&gt; <span class="comment"># 新建并切换</span></span><br><span class="line">git merge &lt;branch-name&gt;      <span class="comment"># 合并某分支到当前分支</span></span><br><span class="line">git branch -d &lt;branch-name&gt;  <span class="comment"># 删除本地分支</span></span><br></pre></td></tr></table></figure><hr><h2 id="🔁-三、远程操作"><a href="#🔁-三、远程操作" class="headerlink" title="🔁 三、远程操作"></a>🔁 三、远程操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git remote -v                                <span class="comment"># 查看远程仓库地址</span></span><br><span class="line">git remote add origin &lt;url&gt;                  <span class="comment"># 添加远程仓库地址</span></span><br><span class="line">git push origin &lt;branch&gt;                     <span class="comment"># 推送当前分支到远程仓库</span></span><br><span class="line">git pull origin &lt;branch&gt;                     <span class="comment"># 拉取远程分支并合并</span></span><br><span class="line">git fetch                                    <span class="comment"># 拉取远程所有更新（不合并）</span></span><br><span class="line">git push -u origin &lt;branch&gt;                  <span class="comment"># 首次推送并关联分支</span></span><br></pre></td></tr></table></figure><hr><h2 id="🔍-四、查看历史-差异"><a href="#🔍-四、查看历史-差异" class="headerlink" title="🔍 四、查看历史 &amp; 差异"></a>🔍 四、查看历史 &amp; 差异</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span>                          <span class="comment"># 查看提交历史</span></span><br><span class="line">git <span class="built_in">log</span> --oneline --graph        <span class="comment"># 简洁的图形化提交历史</span></span><br><span class="line">git diff                         <span class="comment"># 查看工作区与暂存区差异</span></span><br><span class="line">git diff &lt;branch1&gt; &lt;branch2&gt;     <span class="comment"># 比较两个分支差异</span></span><br></pre></td></tr></table></figure><hr><h2 id="🧼-五、撤销操作（常用救命命令）"><a href="#🧼-五、撤销操作（常用救命命令）" class="headerlink" title="🧼 五、撤销操作（常用救命命令）"></a>🧼 五、撤销操作（常用救命命令）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- &lt;file&gt;           <span class="comment"># 撤销对某文件的修改</span></span><br><span class="line">git reset HEAD &lt;file&gt;            <span class="comment"># 取消暂存（撤回 git add）</span></span><br><span class="line">git reset --hard HEAD            <span class="comment"># 撤销所有修改并恢复到最后一次提交状态 ❗危险</span></span><br><span class="line">git clean -fd                    <span class="comment"># 删除所有未追踪文件（慎用）</span></span><br></pre></td></tr></table></figure><hr><h2 id="💥-六、冲突解决"><a href="#💥-六、冲突解决" class="headerlink" title="💥 六、冲突解决"></a>💥 六、冲突解决</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 出现冲突时：</span></span><br><span class="line"><span class="comment"># 1. 手动修改冲突文件</span></span><br><span class="line"><span class="comment"># 2. 然后：</span></span><br><span class="line">git add &lt;file&gt;                   <span class="comment"># 标记冲突已解决</span></span><br><span class="line">git commit                      <span class="comment"># 提交合并后的结果</span></span><br></pre></td></tr></table></figure><hr><h2 id="🪄-七、标签（打版本）"><a href="#🪄-七、标签（打版本）" class="headerlink" title="🪄 七、标签（打版本）"></a>🪄 七、标签（打版本）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git tag                          <span class="comment"># 查看标签</span></span><br><span class="line">git tag v1.0.0                   <span class="comment"># 创建标签</span></span><br><span class="line">git tag -d v1.0.0                <span class="comment"># 删除标签</span></span><br><span class="line">git push origin v1.0.0           <span class="comment"># 推送标签</span></span><br></pre></td></tr></table></figure><hr><h2 id="🔐-八、配置常用信息"><a href="#🔐-八、配置常用信息" class="headerlink" title="🔐 八、配置常用信息"></a>🔐 八、配置常用信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;Neo&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;neo@example.com&quot;</span></span><br><span class="line">git config --global core.editor <span class="string">&quot;code --wait&quot;</span>  <span class="comment"># 设置默认编辑器为 VSCode</span></span><br></pre></td></tr></table></figure><hr><h2 id="🧠-Bonus：推荐-Git-分支命名规范（可用于多人协作）"><a href="#🧠-Bonus：推荐-Git-分支命名规范（可用于多人协作）" class="headerlink" title="🧠 Bonus：推荐 Git 分支命名规范（可用于多人协作）"></a>🧠 Bonus：推荐 Git 分支命名规范（可用于多人协作）</h2><table><thead><tr><th>类型</th><th>示例</th><th>用途</th></tr></thead><tbody><tr><td><code>feat/xxx</code></td><td><code>feat/login-api</code></td><td>新功能</td></tr><tr><td><code>fix/xxx</code></td><td><code>fix/login-bug</code></td><td>修复 bug</td></tr><tr><td><code>hotfix/xxx</code></td><td><code>hotfix/crash-on-launch</code></td><td>紧急修复</td></tr><tr><td><code>test/xxx</code></td><td><code>test/new-framework</code></td><td>实验性分支</td></tr><tr><td><code>release/x.y.z</code></td><td><code>release/1.0.0</code></td><td>预发版本</td></tr><tr><td><code>docs/xxx</code></td><td><code>docs/api-readme</code></td><td>文档修改</td></tr></tbody></table><hr><h1 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title="cherry pick"></a>cherry pick</h1><p>嘿嘿 Neo，问得太准了！<code>cherry-pick</code> 是 Git 中非常实用、<strong>但又稍微高级一点的命令</strong>，用于把<strong>某个提交（commit）从一个分支“精确复制”到另一个分支</strong>。</p><hr><h2 id="🍒-一、什么是-git-cherry-pick？"><a href="#🍒-一、什么是-git-cherry-pick？" class="headerlink" title="🍒 一、什么是 git cherry-pick？"></a>🍒 一、什么是 <code>git cherry-pick</code>？</h2><p><code>git cherry-pick</code> 的作用是：<br>👉 <strong>选择一个或多个特定提交（commit），应用到当前分支上</strong>，而不是整个分支的 merge。</p><p>非常适用于这样的场景：</p><p>💡“我在 <code>dev</code> 分支修了一个 bug，现在想把这个修复也同步到 <code>release</code> 分支，但不想把整个 dev 分支合并过来。”</p><hr><h2 id="✅-二、基本语法"><a href="#✅-二、基本语法" class="headerlink" title="✅ 二、基本语法"></a>✅ 二、基本语法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick &lt;commit-id&gt;</span><br></pre></td></tr></table></figure><p>比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout release</span><br><span class="line">git cherry-pick a1b2c3d4</span><br></pre></td></tr></table></figure><p>这会把 <code>a1b2c3d4</code> 这个提交“复制”一份应用到 <code>release</code> 分支上。</p><hr><h2 id="🧩-三、进阶用法"><a href="#🧩-三、进阶用法" class="headerlink" title="🧩 三、进阶用法"></a>🧩 三、进阶用法</h2><h3 id="1-多个-commit-一起-cherry-pick："><a href="#1-多个-commit-一起-cherry-pick：" class="headerlink" title="1. 多个 commit 一起 cherry-pick："></a>1. 多个 commit 一起 cherry-pick：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick &lt;commit1&gt; &lt;commit2&gt; &lt;commit3&gt;</span><br></pre></td></tr></table></figure><h3 id="2-范围-cherry-pick（不包含起始-commit）："><a href="#2-范围-cherry-pick（不包含起始-commit）：" class="headerlink" title="2. 范围 cherry-pick（不包含起始 commit）："></a>2. 范围 cherry-pick（不包含起始 commit）：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick A^..C</span><br></pre></td></tr></table></figure><p>意思是：从 A 的下一个 commit 到 C（包括 C）</p><hr><h2 id="⚔️-四、cherry-pick-时可能遇到冲突怎么办？"><a href="#⚔️-四、cherry-pick-时可能遇到冲突怎么办？" class="headerlink" title="⚔️ 四、cherry-pick 时可能遇到冲突怎么办？"></a>⚔️ 四、cherry-pick 时可能遇到冲突怎么办？</h2><ol><li>如果冲突了，Git 会提示你冲突文件</li><li>手动修改这些文件，解决冲突</li><li>然后执行：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git cherry-pick --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure><ol><li>如果想放弃这次 cherry-pick：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick --abort</span><br></pre></td></tr></table></figure><hr><h2 id="💡-五、常见使用场景总结"><a href="#💡-五、常见使用场景总结" class="headerlink" title="💡 五、常见使用场景总结"></a>💡 五、常见使用场景总结</h2><table><thead><tr><th>场景</th><th>是否适合 cherry-pick</th></tr></thead><tbody><tr><td>从 <code>dev</code> 拿一个修复提交到 <code>release</code></td><td>✅ 非常适合</td></tr><tr><td>拿多个提交跨分支迁移</td><td>✅ OK，但注意顺序和冲突</td></tr><tr><td>想同步整个分支</td><td>❌ 应该用 <code>merge</code> 或 <code>rebase</code></td></tr><tr><td>做热修复 patch</td><td>✅ 用 cherry-pick 很自然</td></tr></tbody></table><hr><h2 id="👀-六、如何找-commit-id？"><a href="#👀-六、如何找-commit-id？" class="headerlink" title="👀 六、如何找 commit-id？"></a>👀 六、如何找 commit-id？</h2><p>执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --graph --oneline --all</span><br></pre></td></tr></table></figure><p>可以看到所有提交的 ID（短哈希），然后 cherry-pick 你需要的那个。</p><hr><h2 id="✨-七、IDEA-中如何-cherry-pick？"><a href="#✨-七、IDEA-中如何-cherry-pick？" class="headerlink" title="✨ 七、IDEA 中如何 cherry-pick？"></a>✨ 七、IDEA 中如何 cherry-pick？</h2><ol><li>打开 <code>Git &gt; Log</code></li><li>右键某个提交 → <code>Cherry-pick</code></li><li>自动切换到当前分支并执行 cherry-pick</li><li>有冲突的话 IDEA 会提示你合并</li></ol><hr><h2 id="✅-小结"><a href="#✅-小结" class="headerlink" title="✅ 小结"></a>✅ 小结</h2><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><code>git cherry-pick &lt;commit&gt;</code></td><td>把某个提交复制到当前分支</td></tr><tr><td><code>git cherry-pick --abort</code></td><td>取消 cherry-pick 操作</td></tr><tr><td><code>git cherry-pick --continue</code></td><td>解决冲突后继续操作</td></tr></tbody></table><hr><h1 id="🧠-Git-高阶命令合集（推荐收藏）"><a href="#🧠-Git-高阶命令合集（推荐收藏）" class="headerlink" title="🧠 Git 高阶命令合集（推荐收藏）"></a>🧠 Git 高阶命令合集（推荐收藏）</h1><hr><h3 id="1️⃣-git-rebase（变基）"><a href="#1️⃣-git-rebase（变基）" class="headerlink" title="1️⃣ git rebase（变基）"></a>1️⃣ <code>git rebase</code>（变基）</h3><p>✨ 让提交历史更干净，线性合并分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature</span><br><span class="line">git rebase main</span><br></pre></td></tr></table></figure><p>意思是：把 feature 分支的提交“搬到” main 分支后面。</p><p>配合交互式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~5   <span class="comment"># 交互式 rebase 最近 5 次提交</span></span><br></pre></td></tr></table></figure><p>可做：</p><ul><li>合并多个提交（squash）</li><li>修改提交说明（reword）</li><li>删除提交（drop）</li><li>改提交顺序</li></ul><hr><h3 id="2️⃣-git-stash（临时保存工作区）"><a href="#2️⃣-git-stash（临时保存工作区）" class="headerlink" title="2️⃣ git stash（临时保存工作区）"></a>2️⃣ <code>git stash</code>（临时保存工作区）</h3><p>🔧 当你工作一半，突然要切分支处理 bug，但又不想提交</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git stash         <span class="comment"># 保存当前改动</span></span><br><span class="line">git stash list    <span class="comment"># 查看所有 stash</span></span><br><span class="line">git stash pop     <span class="comment"># 恢复最近一次 stash 并删除</span></span><br><span class="line">git stash apply   <span class="comment"># 恢复但不删除</span></span><br></pre></td></tr></table></figure><hr><h3 id="3️⃣-git-reflog（Git-的后悔药）"><a href="#3️⃣-git-reflog（Git-的后悔药）" class="headerlink" title="3️⃣ git reflog（Git 的后悔药）"></a>3️⃣ <code>git reflog</code>（Git 的后悔药）</h3><p>🧠 误删分支、误 reset 后的救命命令！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure><ul><li>能看到所有 HEAD 的移动记录</li><li>例如：你误删了分支或重置了 HEAD，可以找回 commit：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard &lt;某个旧的commit-id&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="4️⃣-git-reset（强力撤销）"><a href="#4️⃣-git-reset（强力撤销）" class="headerlink" title="4️⃣ git reset（强力撤销）"></a>4️⃣ <code>git reset</code>（强力撤销）</h3><p>🚨 撤销提交、回退代码、回滚状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft HEAD~1     <span class="comment"># 撤销最近一次提交（保留代码）</span></span><br><span class="line">git reset --mixed HEAD~1    <span class="comment"># 撤销提交+取消暂存</span></span><br><span class="line">git reset --hard HEAD~1     <span class="comment"># 撤销提交+取消暂存+还原代码</span></span><br></pre></td></tr></table></figure><p>❗ <code>--hard</code> 是最危险的，别轻易动！</p><hr><h3 id="5️⃣-git-clean（清理未跟踪文件）"><a href="#5️⃣-git-clean（清理未跟踪文件）" class="headerlink" title="5️⃣ git clean（清理未跟踪文件）"></a>5️⃣ <code>git clean</code>（清理未跟踪文件）</h3><p>🧹 删除所有没被 Git 跟踪的文件，比如 <code>.DS_Store</code>、缓存等</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean -fd</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>-f</code> force</li><li><code>-d</code> 目录也删</li></ul><hr><h3 id="6️⃣-git-blame（谁改的）"><a href="#6️⃣-git-blame（谁改的）" class="headerlink" title="6️⃣ git blame（谁改的）"></a>6️⃣ <code>git blame</code>（谁改的）</h3><p>🕵️ 查某一行是谁在什么时候提交的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git blame 文件名</span><br></pre></td></tr></table></figure><p>也可以查某一行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git blame -L 15,25 文件名   <span class="comment"># 查第15到25行</span></span><br></pre></td></tr></table></figure><hr><h3 id="7️⃣-git-bisect（二分定位-bug）"><a href="#7️⃣-git-bisect（二分定位-bug）" class="headerlink" title="7️⃣ git bisect（二分定位 bug）"></a>7️⃣ <code>git bisect</code>（二分定位 bug）</h3><p>🪓 自动帮你在一堆提交中定位是哪次提交引入了 bug</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git bisect start</span><br><span class="line">git bisect bad              <span class="comment"># 当前是有 bug 的版本</span></span><br><span class="line">git bisect good v1.0.0      <span class="comment"># v1.0.0 是正常的版本</span></span><br></pre></td></tr></table></figure><p>之后 Git 会一步步二分你历史的提交，让你判断哪个是好哪个是坏，直到定位到“坏提交”。</p><hr><h3 id="8️⃣-git-log-高级玩法（格式化历史）"><a href="#8️⃣-git-log-高级玩法（格式化历史）" class="headerlink" title="8️⃣ git log 高级玩法（格式化历史）"></a>8️⃣ <code>git log</code> 高级玩法（格式化历史）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline --graph --decorate --all</span><br></pre></td></tr></table></figure><p>🌳 查看完整分支图，非常清晰直观：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* a1b2c3 (HEAD -&gt; feature)</span><br><span class="line">| * d4e5f6 (main)</span><br><span class="line">|/</span><br><span class="line">* 123abc</span><br></pre></td></tr></table></figure><hr><h3 id="9️⃣-git-commit-amend（修改上一次提交）"><a href="#9️⃣-git-commit-amend（修改上一次提交）" class="headerlink" title="9️⃣ git commit --amend（修改上一次提交）"></a>9️⃣ <code>git commit --amend</code>（修改上一次提交）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><ul><li>修改提交说明</li><li>或者补加文件（漏了个文件）</li></ul><hr><h3 id="🔟-git-remote-prune-origin（清理无效远程分支）"><a href="#🔟-git-remote-prune-origin（清理无效远程分支）" class="headerlink" title="🔟 git remote prune origin（清理无效远程分支）"></a>🔟 <code>git remote prune origin</code>（清理无效远程分支）</h3><p>🔪 删除那些远程已经删了但本地还看的见的“残影分支”</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote prune origin</span><br></pre></td></tr></table></figure><hr><h2 id="🚀-Bonus：别忘了-Git-的命令可以组合！"><a href="#🚀-Bonus：别忘了-Git-的命令可以组合！" class="headerlink" title="🚀 Bonus：别忘了 Git 的命令可以组合！"></a>🚀 Bonus：别忘了 Git 的命令可以组合！</h2><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --author=neo --since=<span class="string">&quot;1 week ago&quot;</span> --oneline</span><br></pre></td></tr></table></figure><p>看一周内 Neo 提交了什么 👀</p><hr><p>Neo，这个问题问得非常到位，<code>.gitignore</code> 的行为有点“套路”，咱来给你彻底讲透 👇</p><hr><h1 id="😵-为什么-DS-Store-已经写进-gitignore-了，git-status-里还是有？"><a href="#😵-为什么-DS-Store-已经写进-gitignore-了，git-status-里还是有？" class="headerlink" title="😵 为什么 .DS_Store 已经写进 .gitignore 了，git status 里还是有？"></a>😵 为什么 <code>.DS_Store</code> 已经写进 <code>.gitignore</code> 了，<code>git status</code> 里还是有？</h1><hr><h3 id="✅-所以有两种情况你得分清楚："><a href="#✅-所以有两种情况你得分清楚：" class="headerlink" title="✅ 所以有两种情况你得分清楚："></a>✅ 所以有两种情况你得分清楚：</h3><table><thead><tr><th>情况</th><th>会不会被忽略？</th></tr></thead><tbody><tr><td>文件还没被 Git 跟踪过</td><td>✅ 会忽略（git status 不显示）</td></tr><tr><td>文件 <strong>已经被 Git 跟踪过（add 或 commit 过）</strong></td><td>❌ 不会忽略，必须手动移除！</td></tr></tbody></table><hr><h2 id="🔍-判断-DS-Store-是否已经被-Git-跟踪："><a href="#🔍-判断-DS-Store-是否已经被-Git-跟踪：" class="headerlink" title="🔍 判断 .DS_Store 是否已经被 Git 跟踪："></a>🔍 判断 <code>.DS_Store</code> 是否已经被 Git 跟踪：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git ls-files | grep .DS_Store</span><br></pre></td></tr></table></figure><p>如果输出有 <code>.DS_Store</code>，说明它<strong>已经被 Git 加进版本库</strong>，就算你 <code>.gitignore</code> 了也没用。</p><hr><h2 id="✅-解决方案：从-Git-跟踪中移除-DS-Store"><a href="#✅-解决方案：从-Git-跟踪中移除-DS-Store" class="headerlink" title="✅ 解决方案：从 Git 跟踪中移除 .DS_Store"></a>✅ 解决方案：从 Git 跟踪中移除 <code>.DS_Store</code></h2><p>这一步可以“清洗干净”旧的 <code>.DS_Store</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从 Git 索引中移除，但保留文件本身（不删除磁盘文件）</span></span><br><span class="line">git <span class="built_in">rm</span> -r --cached .DS_Store</span><br></pre></td></tr></table></figure><p>如果你项目中很多地方有 <code>.DS_Store</code>，可以这么来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name .DS_Store -print0 | xargs -0 git <span class="built_in">rm</span> --cached</span><br></pre></td></tr></table></figure><p>然后：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;chore: remove tracked .DS_Store files&quot;</span></span><br></pre></td></tr></table></figure><p><strong>之后就不会再出现在 git status 了！</strong></p><hr><h2 id="✅-最终你需要这两件事配套完成："><a href="#✅-最终你需要这两件事配套完成：" class="headerlink" title="✅ 最终你需要这两件事配套完成："></a>✅ 最终你需要这两件事配套完成：</h2><h3 id="1-gitignore-文件中写："><a href="#1-gitignore-文件中写：" class="headerlink" title="1. .gitignore 文件中写："></a>1. <code>.gitignore</code> 文件中写：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">**/.DS_Store</span><br></pre></td></tr></table></figure><h3 id="2-手动移除已跟踪的-DS-Store："><a href="#2-手动移除已跟踪的-DS-Store：" class="headerlink" title="2. 手动移除已跟踪的 .DS_Store："></a>2. 手动移除已跟踪的 <code>.DS_Store</code>：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> -r --cached .DS_Store</span><br><span class="line">git commit -m <span class="string">&quot;remove .DS_Store from repo&quot;</span></span><br></pre></td></tr></table></figure><hr><h1 id="有不同的分支，需要指定如何调和它们"><a href="#有不同的分支，需要指定如何调和它们" class="headerlink" title="有不同的分支，需要指定如何调和它们"></a>有不同的分支，需要指定如何调和它们</h1><p>以下报错解决方案</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">hint: You have divergent branches and need to specify how to reconcile them.</span><br><span class="line">hint: You can do so by running one of the following commands sometime before</span><br><span class="line">hint: your next pull:</span><br><span class="line">hint: </span><br><span class="line">hint:   git config pull.rebase false  # merge</span><br><span class="line">hint:   git config pull.rebase true   # rebase</span><br><span class="line">hint:   git config pull.ff only       # fast-forward only</span><br><span class="line">hint: </span><br><span class="line">hint: You can replace &quot;git config&quot; with &quot;git config --global&quot; to set a default</span><br><span class="line">hint: preference for all repositories. You can also pass --rebase, --no-rebase,</span><br><span class="line">hint: or --ff-only on the command line to override the configured default per</span><br><span class="line">hint: invocation.</span><br><span class="line">fatal: Need to specify how to reconcile divergent branches.</span><br></pre></td></tr></table></figure><h2 id="🧼-最后建议：也别让以后生成-DS-Store"><a href="#🧼-最后建议：也别让以后生成-DS-Store" class="headerlink" title="🧼 最后建议：也别让以后生成 .DS_Store"></a>🧼 最后建议：也别让以后生成 <code>.DS_Store</code></h2><p>你可以加一个全局 <code>.gitignore</code>，让所有 Git 项目都忽略它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.excludesfile ~/.gitignore_global</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;.DS_Store&quot;</span> &gt;&gt; ~/.gitignore_global</span><br></pre></td></tr></table></figure><hr><h2 id="✅-解决方案一：自动合并（推荐，适合大多数情况）"><a href="#✅-解决方案一：自动合并（推荐，适合大多数情况）" class="headerlink" title="✅ 解决方案一：自动合并（推荐，适合大多数情况）"></a>✅ 解决方案一：自动合并（推荐，适合大多数情况）</h2><p>你可以设置默认的 pull 策略为 <strong>merge</strong>（合并）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config pull.rebase <span class="literal">false</span>   <span class="comment"># 当前项目设置为 merge</span></span><br><span class="line"><span class="comment"># 或全局设置：</span></span><br><span class="line">git config --global pull.rebase <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>然后重新执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><p>Git 会帮你合并远程分支和你的本地分支，然后你就能正常 push 了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><hr><h2 id="✅-解决方案二：使用-rebase（更清爽的提交历史）"><a href="#✅-解决方案二：使用-rebase（更清爽的提交历史）" class="headerlink" title="✅ 解决方案二：使用 rebase（更清爽的提交历史）"></a>✅ 解决方案二：使用 <code>rebase</code>（更清爽的提交历史）</h2><p>你也可以选择用 <code>rebase</code>，意思是“把你的提交放在远程的提交后面”。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config pull.rebase <span class="literal">true</span></span><br><span class="line">git pull</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>✅ 提交历史更线性，没有多余的 merge commit<br>❗ 如果代码冲突，手动解决后要 <code>git rebase --continue</code></p><hr><h2 id="✅-解决方案三：强推（不建议，除非你知道你在干啥）"><a href="#✅-解决方案三：强推（不建议，除非你知道你在干啥）" class="headerlink" title="✅ 解决方案三：强推（不建议，除非你知道你在干啥）"></a>✅ 解决方案三：强推（不建议，除非你知道你在干啥）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master --force</span><br></pre></td></tr></table></figure><p>🚨 这会把远程的历史 <strong>强制替换成你本地的版本</strong>，可能会覆盖别人提交的内容。仅适用于你自己完全控制的分支！</p><hr><h2 id="🧠-小知识：为什么会-divergent？"><a href="#🧠-小知识：为什么会-divergent？" class="headerlink" title="🧠 小知识：为什么会 divergent？"></a>🧠 小知识：为什么会 divergent？</h2><p>Divergent branches 意思是：</p><ul><li>你本地有提交</li><li>远程也有提交</li><li>两边提交历史不一致，Git 不知道该怎么合并</li></ul><hr><h2 id="💡-你现在该怎么做？"><a href="#💡-你现在该怎么做？" class="headerlink" title="💡 你现在该怎么做？"></a>💡 你现在该怎么做？</h2><ol><li><strong>推荐做法：合并式 pull → push</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config pull.rebase <span class="literal">false</span></span><br><span class="line">git pull</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><ol><li><strong>如果喜欢更干净的历史（高级玩家）：rebase 后再 push</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config pull.rebase <span class="literal">true</span></span><br><span class="line">git pull</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><hr><h2 id="✅-最后推荐（全局设置一劳永逸）"><a href="#✅-最后推荐（全局设置一劳永逸）" class="headerlink" title="✅ 最后推荐（全局设置一劳永逸）"></a>✅ 最后推荐（全局设置一劳永逸）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global pull.rebase <span class="literal">false</span>   <span class="comment"># 默认用 merge 模式</span></span><br></pre></td></tr></table></figure><p>太棒啦 Neo！既然你都提出了这个需求，那我就直接给你整一份干净利落的 🎯<strong>Git 高级命令实战训练营清单</strong>，包含：</p><ul><li>场景设定 ✅</li><li>命令目标 ✅</li><li>练手任务 ✅</li><li>附带注意事项 ✅</li></ul><hr><h1 id="🚀-场景实战"><a href="#🚀-场景实战" class="headerlink" title="🚀 场景实战"></a>🚀 场景实战</h1><hr><h2 id="1️⃣-场景：合并冲突后撤销操作"><a href="#1️⃣-场景：合并冲突后撤销操作" class="headerlink" title="1️⃣ 场景：合并冲突后撤销操作"></a>1️⃣ 场景：<strong>合并冲突后撤销操作</strong></h2><p>💥 你执行了 <code>git merge feature</code>，结果一堆文件冲突，还没开始改就后悔了……</p><h3 id="🎯-目标："><a href="#🎯-目标：" class="headerlink" title="🎯 目标："></a>🎯 目标：</h3><ul><li>撤销 merge 操作</li><li>回到合并之前的状态</li></ul><h3 id="🛠-操作："><a href="#🛠-操作：" class="headerlink" title="🛠 操作："></a>🛠 操作：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git merge feature         <span class="comment"># 模拟合并产生冲突</span></span><br><span class="line">git merge --abort         <span class="comment"># 🧨 立刻撤销合并，回到之前状态</span></span><br></pre></td></tr></table></figure><h3 id="📌-注意事项："><a href="#📌-注意事项：" class="headerlink" title="📌 注意事项："></a>📌 注意事项：</h3><ul><li>只适用于<strong>还没解决冲突前</strong>的撤销</li><li>如果你已经解决了一部分冲突，要用：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD</span><br></pre></td></tr></table></figure><hr><h2 id="2️⃣-场景：找回误删分支或回滚版本"><a href="#2️⃣-场景：找回误删分支或回滚版本" class="headerlink" title="2️⃣ 场景：找回误删分支或回滚版本"></a>2️⃣ 场景：<strong>找回误删分支或回滚版本</strong></h2><p>😭 手滑 <code>git branch -D bugfix-xxx</code>，现在想要找回</p><h3 id="🎯-目标：-1"><a href="#🎯-目标：-1" class="headerlink" title="🎯 目标："></a>🎯 目标：</h3><ul><li>找回你删掉的分支或误操作的提交</li></ul><h3 id="🛠-操作：-1"><a href="#🛠-操作：-1" class="headerlink" title="🛠 操作："></a>🛠 操作：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reflog                <span class="comment"># 找到分支最后的 commit 哈希</span></span><br><span class="line">git checkout -b bugfix-xxx &lt;commit-id&gt;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b bugfix-xxx d4f2a7c</span><br></pre></td></tr></table></figure><h3 id="📌-小贴士："><a href="#📌-小贴士：" class="headerlink" title="📌 小贴士："></a>📌 小贴士：</h3><ul><li><code>git reflog</code> 是 Git 的黑匣子，啥都能找回来（只要还没 gc）</li></ul><hr><h2 id="3️⃣-场景：多人协作开发时同步主分支并-rebase-提交"><a href="#3️⃣-场景：多人协作开发时同步主分支并-rebase-提交" class="headerlink" title="3️⃣ 场景：多人协作开发时同步主分支并 rebase 提交"></a>3️⃣ 场景：<strong>多人协作开发时同步主分支并 rebase 提交</strong></h2><p>🧑‍🤝‍🧑 你在 <code>feature-xxx</code> 上开发，结果 <code>main</code> 分支更新了，想保持历史干净就不能直接 merge</p><h3 id="🎯-目标：-2"><a href="#🎯-目标：-2" class="headerlink" title="🎯 目标："></a>🎯 目标：</h3><ul><li>把主分支的最新提交合并进你的功能分支</li><li>使用 <code>rebase</code> 而不是 <code>merge</code></li></ul><h3 id="🛠-操作：-2"><a href="#🛠-操作：-2" class="headerlink" title="🛠 操作："></a>🛠 操作：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature-xxx</span><br><span class="line">git fetch origin</span><br><span class="line">git rebase origin/main</span><br></pre></td></tr></table></figure><p>如果有冲突：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解决冲突后：</span></span><br><span class="line">git add .</span><br><span class="line">git rebase --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure><h3 id="📌-注意事项：-1"><a href="#📌-注意事项：-1" class="headerlink" title="📌 注意事项："></a>📌 注意事项：</h3><ul><li>不要在公共分支 rebase（会让别人 history 混乱）</li><li>rebase 是让提交更“像一条直线”，但操作前建议备份一份分支</li></ul><hr><h2 id="4️⃣-场景：Cherry-pick-热修复-commit-到多个分支"><a href="#4️⃣-场景：Cherry-pick-热修复-commit-到多个分支" class="headerlink" title="4️⃣ 场景：Cherry-pick 热修复 commit 到多个分支"></a>4️⃣ 场景：<strong>Cherry-pick 热修复 commit 到多个分支</strong></h2><p>🚨 线上生产出了问题，你在 <code>hotfix/fix-404</code> 分支修好了，现在要把这个 bugfix 提交同步到 <code>main</code> 和 <code>release/1.0</code></p><h3 id="🎯-目标：-3"><a href="#🎯-目标：-3" class="headerlink" title="🎯 目标："></a>🎯 目标：</h3><ul><li>精确复制某个提交到其他分支</li></ul><h3 id="🛠-操作：-3"><a href="#🛠-操作：-3" class="headerlink" title="🛠 操作："></a>🛠 操作：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline             <span class="comment"># 找到那个 fix 的 commit id</span></span><br><span class="line">git checkout main</span><br><span class="line">git cherry-pick &lt;commit-id&gt;</span><br><span class="line">git checkout release/1.0</span><br><span class="line">git cherry-pick &lt;commit-id&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="5️⃣-场景：多个小-commit-打成一个，准备发-PR"><a href="#5️⃣-场景：多个小-commit-打成一个，准备发-PR" class="headerlink" title="5️⃣ 场景：多个小 commit 打成一个，准备发 PR"></a>5️⃣ 场景：<strong>多个小 commit 打成一个，准备发 PR</strong></h2><p>✅ 你在开发中提交了 5 个小碎提交，现在准备发 PR，想压缩成一个漂亮的 commit</p><h3 id="🎯-目标：-4"><a href="#🎯-目标：-4" class="headerlink" title="🎯 目标："></a>🎯 目标：</h3><ul><li>squash 压缩多个 commit</li><li>美化提交历史</li></ul><h3 id="🛠-操作：-4"><a href="#🛠-操作：-4" class="headerlink" title="🛠 操作："></a>🛠 操作：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline            <span class="comment"># 看你要压缩几个</span></span><br><span class="line">git rebase -i HEAD~5         <span class="comment"># 交互式 rebase 最近5个提交</span></span><br></pre></td></tr></table></figure><p>然后在编辑界面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pick  123abc  初始提交</span><br><span class="line">squash 456def  修复 typo</span><br><span class="line">squash 789aaa  增加校验</span><br><span class="line">squash abc999  重构函数</span><br><span class="line">squash xyz333  修改注释</span><br></pre></td></tr></table></figure><p>保存后输入新的 commit message，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">feat: 完善登录功能 &amp; 代码优化</span><br></pre></td></tr></table></figure><p>然后：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -f origin feature/login</span><br></pre></td></tr></table></figure><p>注意：你改了历史，需要用 <code>-f</code> 强推 ⚠️</p><hr><h2 id="✅-速查表："><a href="#✅-速查表：" class="headerlink" title="✅ 速查表："></a>✅ 速查表：</h2><table><thead><tr><th>场景</th><th>关键命令</th></tr></thead><tbody><tr><td>撤销冲突合并</td><td><code>git merge --abort</code></td></tr><tr><td>找回误删分支</td><td><code>git reflog</code> + <code>git checkout -b</code></td></tr><tr><td>同步主分支 + Rebase</td><td><code>git rebase origin/main</code></td></tr><tr><td>精确复制修复 commit</td><td><code>git cherry-pick &lt;id&gt;</code></td></tr><tr><td>多个提交压缩成一个提交</td><td><code>git rebase -i HEAD~N</code></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring整合mybatis</title>
      <link href="/2025/03/27/%E6%8A%80%E6%9C%AF/java/%E6%A1%86%E6%9E%B6/SpringBoot%E6%95%B4%E5%90%88mybatis/"/>
      <url>/2025/03/27/%E6%8A%80%E6%9C%AF/java/%E6%A1%86%E6%9E%B6/SpringBoot%E6%95%B4%E5%90%88mybatis/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring整合mybatis简单配置"><a href="#Spring整合mybatis简单配置" class="headerlink" title="Spring整合mybatis简单配置"></a>Spring整合mybatis简单配置</h2><ol><li>pom引入mybatis的starter</li><li>配置数据库连接池</li><li>Springboot配置文件里配置mybatis相关参数</li><li>编写自己的dao以及mapper配置文件</li></ol><p>配置datasource，比如用druid链接池配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    #druid相关配置</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">    driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">    #配置数据库连接</span><br><span class="line">    druid:</span><br><span class="line">      url: jdbc:mysql://localhost:3306/test-db?useUnicode=true&amp;allowMultiQueries=true&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">      username: root</span><br><span class="line">      password: 123456</span><br><span class="line">      initial-size: 10</span><br><span class="line">      max-active: 100</span><br><span class="line">      min-idle: 10</span><br><span class="line">      max-wait: 60000</span><br><span class="line">      pool-prepared-statements: true</span><br><span class="line">      max-pool-prepared-statement-per-connection-size: 20</span><br><span class="line">      time-between-eviction-runs-millis: 60000</span><br><span class="line">      min-evictable-idle-time-millis: 300000</span><br><span class="line">      validation-query: SELECT 1 FROM DUAL</span><br><span class="line">      test-while-idle: true</span><br><span class="line">      test-on-borrow: false</span><br><span class="line">      test-on-return: false</span><br><span class="line">      connectionInitSqls: set names utf8mb4</span><br></pre></td></tr></table></figure><p>配置mybatis参数，指定mapper文件路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mybatis:</span><br><span class="line">  mapper-locations: classpath:mapper/*.xml</span><br></pre></td></tr></table></figure><p>定义dao接口，并加上@Mapper注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserInfoDao</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">insert</span><span class="params">(UserInfoDO userInfoDO)</span></span><br><span class="line">    </span><br><span class="line">    UserInfoDO <span class="title function_">getById</span><span class="params">(<span class="type">long</span> id)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">update</span><span class="params">(UserInfoDO userInfoDO)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="type">long</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置mapper文件，写好sql与dao接口的映射关系，其中namespace是对应的dao接口完整类名。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.hj.dao.UserInfoDao&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.hj.DO.UserInfoDO&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;userId&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userId&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.hhdd.DO.UserInfoDO&quot;</span>&gt;</span></span><br><span class="line">      insert ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getById&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.Long&quot;</span>&gt;</span></span><br><span class="line">        select ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.hj.DO.UserInfoDO&quot;</span>&gt;</span></span><br><span class="line">        update ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;delete&quot;</span>&gt;</span></span><br><span class="line">        delete ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>想spring容器中注册SqlSessionFactory，并根据mapper配置文件解析出dao与具体jdbc操作、resultMap与实体类的映射关系。</p><p>注册实现了CRUD的SqlSessionTemplate类</p><img src="https://cdn.jsdelivr.net/gh/neoisok/assets@main/images%2F2025%2F03%2F27%2FMyBatis%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" width="600">]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> java </category>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven 的基本原理与核心概念</title>
      <link href="/2025/03/27/%E6%8A%80%E6%9C%AF/java/%E6%A1%86%E6%9E%B6/Maven/%E7%90%86%E8%A7%A3Maven%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E4%B8%8E%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/"/>
      <url>/2025/03/27/%E6%8A%80%E6%9C%AF/java/%E6%A1%86%E6%9E%B6/Maven/%E7%90%86%E8%A7%A3Maven%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E4%B8%8E%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Maven-的基本原理与核心概念"><a href="#一、Maven-的基本原理与核心概念" class="headerlink" title="一、Maven 的基本原理与核心概念"></a>一、Maven 的基本原理与核心概念</h2><h3 id="1-Maven-是什么？"><a href="#1-Maven-是什么？" class="headerlink" title="1. Maven 是什么？"></a>1. Maven 是什么？</h3><blockquote><p>Maven 是一个基于 POM（Project Object Model）的项目管理与构建自动化工具，主要用于 Java 项目的依赖管理、构建流程、插件系统和生命周期管理。</p></blockquote><ul><li><strong>构建工具</strong>：可以将源码编译、打包、测试、部署。</li><li><strong>依赖管理工具</strong>：自动下载项目依赖（jar 包），并解决依赖冲突。</li><li><strong>项目标准化工具</strong>：统一项目结构与构建流程，提升团队协作效率。</li></ul><hr><h3 id="2-Maven-的三大核心功能"><a href="#2-Maven-的三大核心功能" class="headerlink" title="2. Maven 的三大核心功能"></a>2. Maven 的三大核心功能</h3><table><thead><tr><th>功能模块</th><th>说明</th></tr></thead><tbody><tr><td><strong>依赖管理</strong></td><td>自动下载、更新、版本控制 Jar 包，解决依赖传递</td></tr><tr><td><strong>生命周期管理</strong></td><td>定义项目构建的标准流程，如编译、测试、打包、部署</td></tr><tr><td><strong>插件机制</strong></td><td>插件实现所有构建行为，例如编译、测试、生成文档等</td></tr></tbody></table><hr><h3 id="3-Maven-的核心概念"><a href="#3-Maven-的核心概念" class="headerlink" title="3. Maven 的核心概念"></a>3. Maven 的核心概念</h3><h4 id="3-1-POM（Project-Object-Model）"><a href="#3-1-POM（Project-Object-Model）" class="headerlink" title="3.1 POM（Project Object Model）"></a>3.1 POM（Project Object Model）</h4><ul><li>Maven 项目的核心配置文件是 <code>pom.xml</code></li><li>使用 XML 结构描述项目依赖、插件、版本、构建方式等</li></ul><p>示例结构（简化版）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 添加依赖 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h4 id="3-2-坐标（Coordinates）"><a href="#3-2-坐标（Coordinates）" class="headerlink" title="3.2 坐标（Coordinates）"></a>3.2 坐标（Coordinates）</h4><p>Maven 使用一组坐标唯一标识一个构件（artifact）：</p><ul><li><code>groupId</code>：组织 ID（例如公司或开源组织）</li><li><code>artifactId</code>：项目名称或模块名称</li><li><code>version</code>：版本号</li><li><code>packaging</code>：打包类型（默认是 jar，也可以是 war）</li></ul><hr><h4 id="3-3-仓库（Repository）"><a href="#3-3-仓库（Repository）" class="headerlink" title="3.3 仓库（Repository）"></a>3.3 仓库（Repository）</h4><p>Maven 下载依赖的地方称为仓库，分为：</p><ul><li><strong>本地仓库</strong>：<code>~/.m2/repository</code>，首次下载后缓存</li><li><strong>中央仓库</strong>：默认公共仓库，<a href="https://repo.maven.apache.org/">https://repo.maven.apache.org</a></li><li><strong>私服仓库</strong>：企业内部搭建，如 Nexus、Artifactory</li></ul><hr><h4 id="3-4-生命周期（Lifecycle）"><a href="#3-4-生命周期（Lifecycle）" class="headerlink" title="3.4 生命周期（Lifecycle）"></a>3.4 生命周期（Lifecycle）</h4><p>Maven 构建项目遵循一定的生命周期，最常用的是默认生命周期：</p><table><thead><tr><th>阶段（Phase）</th><th>说明</th></tr></thead><tbody><tr><td><code>validate</code></td><td>验证项目结构是否完整</td></tr><tr><td><code>compile</code></td><td>编译 Java 源码</td></tr><tr><td><code>test</code></td><td>执行单元测试</td></tr><tr><td><code>package</code></td><td>打包成 jar&#x2F;war</td></tr><tr><td><code>install</code></td><td>安装到本地仓库</td></tr><tr><td><code>deploy</code></td><td>发布到远程仓库</td></tr></tbody></table><p>执行命令如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package</span><br></pre></td></tr></table></figure><hr><h4 id="3-5-插件（Plugin）"><a href="#3-5-插件（Plugin）" class="headerlink" title="3.5 插件（Plugin）"></a>3.5 插件（Plugin）</h4><p>插件是 Maven 的功能实现者，例如：</p><ul><li><code>maven-compiler-plugin</code>：编译 Java 源码</li><li><code>maven-surefire-plugin</code>：运行单元测试</li><li><code>maven-jar-plugin</code>：打包成 jar 文件</li></ul><hr><h4 id="3-6-依赖传递与范围（Scope）"><a href="#3-6-依赖传递与范围（Scope）" class="headerlink" title="3.6 依赖传递与范围（Scope）"></a>3.6 依赖传递与范围（Scope）</h4><p>依赖管理中常见问题：</p><ul><li>依赖传递：A 依赖 B，B 又依赖 C → A 自动引入 C</li><li>范围控制：<ul><li><code>compile</code>：默认，编译&#x2F;运行&#x2F;打包都可用</li><li><code>provided</code>：编译需要，运行时由容器提供（如 Servlet）</li><li><code>runtime</code>：运行时需要，如 JDBC 驱动</li><li><code>test</code>：只在测试阶段使用</li></ul></li></ul><hr><h3 id="4-Maven-的标准项目结构"><a href="#4-Maven-的标准项目结构" class="headerlink" title="4. Maven 的标准项目结构"></a>4. Maven 的标准项目结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">demo-app/</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src/</span><br><span class="line">    ├── main/</span><br><span class="line">    │   ├── java/        # 源码目录</span><br><span class="line">    │   └── resources/   # 配置文件目录</span><br><span class="line">    └── test/</span><br><span class="line">        └── java/        # 测试代码目录</span><br></pre></td></tr></table></figure><hr><h3 id="5-Maven-的工作流程（构建过程）"><a href="#5-Maven-的工作流程（构建过程）" class="headerlink" title="5. Maven 的工作流程（构建过程）"></a>5. Maven 的工作流程（构建过程）</h3><blockquote><p>开发者执行 Maven 命令 → 读取 pom.xml → 下载依赖 → 执行生命周期 → 生成产物</p></blockquote><p>流程图（建议制作成教学图）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[开发者执行命令]</span><br><span class="line">        ↓</span><br><span class="line"> [读取 pom.xml]</span><br><span class="line">        ↓</span><br><span class="line">[解析依赖关系树]</span><br><span class="line">        ↓</span><br><span class="line">[执行生命周期中各阶段]</span><br><span class="line">        ↓</span><br><span class="line"> [输出 jar/war 文件]</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> java </category>
          
          <category> 框架 </category>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 常用命令</title>
      <link href="/2025/03/19/%E6%8A%80%E6%9C%AF/%E8%BF%90%E7%BB%B4/%E5%AE%B9%E5%99%A8/Docker-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2025/03/19/%E6%8A%80%E6%9C%AF/%E8%BF%90%E7%BB%B4/%E5%AE%B9%E5%99%A8/Docker-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="windows下利用docker-搭建ubuntu-环境"><a href="#windows下利用docker-搭建ubuntu-环境" class="headerlink" title="windows下利用docker 搭建ubuntu 环境"></a>windows下利用docker 搭建ubuntu 环境</h2><h3 id="1、首先安装docker"><a href="#1、首先安装docker" class="headerlink" title="1、首先安装docker"></a><strong>1、首先安装docker</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker system df # 查看镜像、容器、数据卷占用空间</span><br><span class="line">docker images # 查看docker镜像 </span><br><span class="line">docker image ls # 查看镜像</span><br><span class="line">docker ps # 查看所有启动的容器</span><br><span class="line">docker ps -a # 查看所有容器</span><br><span class="line">docker rm -f id/name # 删除容器</span><br><span class="line">docker image rm ID # 删除镜像</span><br><span class="line">docker image prune # 删除虚悬镜像(dangling image)，由于新旧镜像同名，旧镜像名被取消，导致仓库名和标签均为&lt;none&gt;</span><br><span class="line"></span><br><span class="line">docker commit 26ea8c57c7bf ubuntupython3 # 从容器创建一个新的镜像，可以自己搭建一个ubuntu+python的开发环境，作为一个镜像，这样再次新建容器时可以以此为基础</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2、获取镜像"><a href="#2、获取镜像" class="headerlink" title="2、获取镜像"></a><strong>2、获取镜像</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker search ubuntu # 查找ubuntu镜像</span><br><span class="line">docker pull ubuntu # 默认安装latest版本</span><br><span class="line">docker pull ubuntu:16.04 # 指定版本</span><br></pre></td></tr></table></figure><h3 id="3、以镜像为基础启动并运行一个容器-：https-docs-docker-com-engine-reference-commandline-container-start"><a href="#3、以镜像为基础启动并运行一个容器-：https-docs-docker-com-engine-reference-commandline-container-start" class="headerlink" title="3、以镜像为基础启动并运行一个容器 ：https://docs.docker.com/engine/reference/commandline/container_start/"></a><strong>3、以镜像为基础启动并运行一个容器 ：<a href="https://docs.docker.com/engine/reference/commandline/container_start/">https://docs.docker.com/engine/reference/commandline/container_start/</a></strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm ubuntu:16.04 bash # -i 交互式操作 -t 终端 --rm 容器退出后将其删除</span><br><span class="line">docker run -itd ubuntu bash # 后台运行</span><br><span class="line">docker run --name=openvino -it ubuntu:18.04 # 指定名字</span><br><span class="line">docker run -it -v E:/data:/home/data ubuntu bash # 挂在宿主机文件目录，实现文件共享</span><br><span class="line">exit # 退出容器</span><br><span class="line">docker container start -i container_name # 重新启动</span><br><span class="line">docker container stop # 终止容器</span><br><span class="line">docker exec -it id/name bash # 进入容器</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker attach 必须attach 到一个已经运行的容器, 使用<span class="built_in">exit</span>会导致容器停止</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入退出的容器</span></span><br><span class="line">docker start openvino</span><br><span class="line">docker attach openvino</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">移除容器及其挂载卷，不会对镜像造成影响</span></span><br><span class="line">docker rm -v container_id</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">批量删除停止的容器</span></span><br><span class="line">docker rm -v $(docker ps -a -q -f status=exited)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改容器的挂载目录:提交现有容器为新镜像，然后重新运行它</span></span><br><span class="line">docker commit 5a3422adeead newimagename</span><br><span class="line">docker run -ti -v &quot;$PWD/dir1&quot;:/dir1 -v &quot;$PWD/dir2&quot;:/dir2 newimagename /bin/bash</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Docker文件系统和数据卷:https://zhuanlan.zhihu.com/p/73288338</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Docker中的数据可以存储在类似于虚拟机磁盘的介质中，称为数据卷（Data Volume）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通常存储在容器中的一般文件随着容器的删除而消失，而数据卷独立于容器存在，并不会随着容器的删除而删除</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">数据卷除了延长数据的生命周期，还可以用于容器间的数据共享</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建数据卷</span></span><br><span class="line">docker volume create volume_name</span><br><span class="line">docker run -it -v /data3 --name=volume2 image_id/image_name # 启动容器并创建一个数据卷</span><br><span class="line">docker run -it -v volume_name:/data4 --name=volume3 image_id/image_name # 指定数据卷挂载容器目录</span><br><span class="line">docker run -it -volumes_from 容器ID --name=volume4 image_id # 挂载其他容器的数据卷</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看所有数据卷</span></span><br><span class="line">docker volume ls</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除数据卷</span></span><br><span class="line">docker volume rm 数据卷名</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除所有无主的数据卷</span></span><br><span class="line">docker volume prune</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">挂载宿主机目录</span></span><br><span class="line">docker run -it --name=test -v /宿主机目录:/容器目录 image_id</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将数据卷的数据同步到宿主机：可以创建一个新容器挂载数据卷容器，同时挂载一个本地目录，通过<span class="built_in">cp</span>命名将数据拷贝到本地目录</span></span><br><span class="line">docker run –rm –volumes-from=volume2 –name=“volume8” -v /data/www/fjh3:/fjh3:rw 镜像ID cp –rf /data1 /fjh3</span><br><span class="line"></span><br><span class="line">ps # 显示进程信息</span><br><span class="line">top # 实时显示进程动态，输入q或者按ctrl c 退出</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4、ubuntu部分"><a href="#4、ubuntu部分" class="headerlink" title="4、ubuntu部分"></a><strong>4、ubuntu部分</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/os-release # 查看ubuntu版本</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">https://man.linuxde.net/apt-get apt-get命令</span></span><br><span class="line">apt-get update # 更新apt-get</span><br><span class="line">apt-get remove packagename # 保留配置文件</span><br><span class="line">apt-get purge packagename # 删除配置文件</span><br><span class="line">apt-get autoclean apt # 删除已删掉软件的备份</span><br><span class="line">apt-get clean # 删除安装软件的备份</span><br><span class="line">apt-get upgrade # 更新已安装的软件包</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装常用工具</span></span><br><span class="line">apt-get install -y vim</span><br><span class="line">apt-get install -y python3</span><br><span class="line">apt-get install -y python3-pip</span><br><span class="line">apt-get install -y git # 安装git　 git --version 查看版本</span><br><span class="line">apt-get install wget # wget 用于从指定的url下载文件</span><br><span class="line">apt-get install -y dos2unix</span><br></pre></td></tr></table></figure><h3 id="5、搭建开发环境"><a href="#5、搭建开发环境" class="headerlink" title="5、搭建开发环境"></a><strong>5、搭建开发环境</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Python环境：https://blog.csdn.net/m0_38124502/article/details/78090902</span></span><br><span class="line">pip freeze &gt;requirements.txt # 将当前项目的python环境导出</span><br><span class="line">pip install -r requirements.txt # 安装</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 源码安装主要有三个步骤：配置(configure)、编译(make)、安装(make install)</span></span></span><br><span class="line">./configure --help</span><br><span class="line">./configure --prefix=/usr/local # 指定安装目录</span><br><span class="line"></span><br><span class="line">pip3 install opencv-python</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 运维 </category>
          
          <category> 容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>管理</title>
      <link href="/2025/03/19/%E7%AE%A1%E7%90%86/%E7%AE%A1%E7%90%86/"/>
      <url>/2025/03/19/%E7%AE%A1%E7%90%86/%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>这里写管理博客</p>]]></content>
      
      
      <categories>
          
          <category> 管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/03/18/hello-world/"/>
      <url>/2025/03/18/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h3 id="categorys"><a href="#categorys" class="headerlink" title="categorys"></a>categorys</h3><ul><li>技术&#x2F;架构</li><li>技术&#x2F;前端</li><li>技术&#x2F;数据库</li><li>技术&#x2F;运维</li><li>技术&#x2F;java</li><li>技术&#x2F;java&#x2F;基础</li><li>技术&#x2F;java&#x2F;框架</li></ul>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
