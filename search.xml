<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>前端大扫盲</title>
      <link href="/2025/04/03/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%A4%A7%E6%89%AB%E7%9B%B2/"/>
      <url>/2025/04/03/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%A4%A7%E6%89%AB%E7%9B%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="Nodejs是什么"><a href="#Nodejs是什么" class="headerlink" title="Nodejs是什么"></a>Nodejs是什么</h1><p>👀 Node.js 不是一种语言，它是一个 JavaScript 运行环境。</p><p>Node.js 是用 C++ 和 JavaScript 开发的，用来在浏览器外运行 JavaScript 的运行时环境。</p><p>它让 JavaScript 也能在 服务器端 或 命令行里 执行，而不仅仅只能在浏览器里跑。</p><hr><h2 id="🧠-Node-js-是什么？"><a href="#🧠-Node-js-是什么？" class="headerlink" title="🧠 Node.js 是什么？"></a>🧠 Node.js 是什么？</h2><ul><li><p>是一个开源的、跨平台的 JavaScript 运行环境</p></li><li><p>底层基于：</p></li><li><p>V8 引擎：Google Chrome 用的 JS 引擎，用 C++ 写的</p></li><li><p>libuv：一个跨平台的异步 I&#x2F;O 库（也用 C 写的）</p></li><li><p>Node 自己封装了很多模块（比如 fs、http、path 等）</p></li></ul><hr><h2 id="👇-Node-js-用什么写出来的？"><a href="#👇-Node-js-用什么写出来的？" class="headerlink" title="👇 Node.js 用什么写出来的？"></a>👇 Node.js 用什么写出来的？</h2><table><thead><tr><th>组成部分</th><th>语言</th></tr></thead><tbody><tr><td>V8 引擎</td><td>C++（谷歌的 JavaScript 引擎）</td></tr><tr><td>Node 核心 API</td><td>C&#x2F;C++（比如文件系统、网络模块）</td></tr><tr><td>内部工具</td><td>JavaScript（REPL、模块系统）</td></tr></tbody></table><p>所以可以说：</p><p>💡 Node.js 是用 C++ + JS 写的运行时平台，专门用来让 JavaScript 能在浏览器之外运行。</p><hr><h2 id="✅-用-Node-js-写代码时用什么语言？"><a href="#✅-用-Node-js-写代码时用什么语言？" class="headerlink" title="✅ 用 Node.js 写代码时用什么语言？"></a>✅ 用 Node.js 写代码时用什么语言？</h2><p>💡 用的还是 JavaScript！（也可以用 TypeScript 等转译成 JS）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// hello.js</span><br><span class="line">console.log(&#x27;Hello from Node!&#x27;);</span><br></pre></td></tr></table></figure><p>然后运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node hello.js</span><br></pre></td></tr></table></figure><p>你写的是 JS，运行在 Node 的平台上。</p><hr><p>所以，Node.js 不是一门语言，它是 JavaScript 的“服务器运行平台”，本身是用 C++ 和 JavaScript 写的，但你用它写代码还是写 JavaScript。</p><p>🧠 Node.js 是怎么让 JavaScript 在浏览器之外运行，还能读文件、连数据库、建服务器的！</p><hr><h2 id="🧩-Node-js-内部结构图"><a href="#🧩-Node-js-内部结构图" class="headerlink" title="🧩 Node.js 内部结构图"></a>🧩 Node.js 内部结构图</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">       JS 代码（.js 文件）</span><br><span class="line">            ↓</span><br><span class="line">      ┌─────────────┐</span><br><span class="line">      │  Node.js    │ ←←←←←←←←←←←←←←←←←←←←←←←←</span><br><span class="line">      └─────────────┘             用 C++ + JS 实现</span><br><span class="line">            ↓</span><br><span class="line">┌────────────────────────────┐</span><br><span class="line">│      Node 核心模块层       │ ← 你写的 JS 会调用这些模块</span><br><span class="line">│ ─ fs、http、net、child_process │</span><br><span class="line">└────────────────────────────┘</span><br><span class="line">            ↓</span><br><span class="line">  ┌────────────────────┐</span><br><span class="line">  │  libuv（事件循环库）│ ← C 实现，跨平台异步 I/O</span><br><span class="line">  └────────────────────┘</span><br><span class="line">            ↓</span><br><span class="line">     ┌────────────┐</span><br><span class="line">     │ 操作系统API │ ← 文件系统、网络端口、CPU、内存等</span><br><span class="line">     └────────────┘</span><br></pre></td></tr></table></figure><hr><h2 id="💡-各层详解："><a href="#💡-各层详解：" class="headerlink" title="💡 各层详解："></a>💡 各层详解：</h2><table><thead><tr><th>层级</th><th>作用</th><th>开发语言</th></tr></thead><tbody><tr><td>✅ 你写的 JavaScript</td><td>使用 Node API，比如 fs.readFile()</td><td>JavaScript</td></tr><tr><td>✅ Node.js 核心模块</td><td>封装操作系统功能给 JS 用</td><td>C++ + JS</td></tr><tr><td>✅ libuv</td><td>管理事件循环、非阻塞 I&#x2F;O</td><td>C</td></tr><tr><td>✅ OS 层</td><td>实际读文件、开端口等</td><td>操作系统调用</td></tr></tbody></table><hr><h2 id="🚀-举个例子：你写了一行-JS-读文件"><a href="#🚀-举个例子：你写了一行-JS-读文件" class="headerlink" title="🚀 举个例子：你写了一行 JS 读文件"></a>🚀 举个例子：你写了一行 JS 读文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&#x27;fs&#x27;);</span><br><span class="line">fs.readFile(&#x27;./a.txt&#x27;, (err, data) =&gt; &#123;</span><br><span class="line">  console.log(data.toString());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>执行流程是：</p><ol><li>你调用 fs.readFile（Node 核心模块提供的接口）</li><li>Node 内部通过 C++ 调用 libuv 发起异步读文件请求</li><li>libuv 异步调用 OS 的 read() 系统调用</li><li>文件读完后，触发回调 → 再回到你 JS 代码中输出内容</li></ol><p>💡 所以你写的是 JS，但幕后都是 Node 和 libuv 帮你“打下手”。</p><hr><h2 id="🧠-Node-js-为什么强大？"><a href="#🧠-Node-js-为什么强大？" class="headerlink" title="🧠 Node.js 为什么强大？"></a>🧠 Node.js 为什么强大？</h2><ul><li>借助 V8，它执行 JS 超快</li><li>借助 libuv，它能做异步非阻塞 I&#x2F;O（读写、网络都快）</li><li>用 JavaScript 写全栈（前端 + 后端）也变得可能</li></ul><hr><h1 id="Nodejs和vue的关系"><a href="#Nodejs和vue的关系" class="headerlink" title="Nodejs和vue的关系"></a>Nodejs和vue的关系</h1><h2 id="Node-js-的两个角色"><a href="#Node-js-的两个角色" class="headerlink" title="Node.js 的两个角色"></a>Node.js 的两个角色</h2><table><thead><tr><th>Node.js 可以干啥？</th><th>举个例子</th></tr></thead><tbody><tr><td>✅ 写后端（服务器）</td><td>接口、登录验证、数据库</td></tr><tr><td>✅ 做前端开发工具链</td><td>脚手架、打包器、开发服务器（vite&#x2F;webpack）</td></tr></tbody></table><p>👉 所以 Node.js 并不只是写后端，它其实是「运行 JS 的平台」，能跑任意 JS 脚本（不局限浏览器）</p><hr><h2 id="🎯-Vue-项目用-Node-js-干了什么？"><a href="#🎯-Vue-项目用-Node-js-干了什么？" class="headerlink" title="🎯 Vue 项目用 Node.js 干了什么？"></a>🎯 Vue 项目用 Node.js 干了什么？</h2><p>Vue 项目虽然是前端的，但它的开发环境、构建工具、依赖管理全部都依赖于 Node.js 提供的生态工具链，而这些工具都通过 npm 来安装和管理。</p><p>打个比喻写 Vue 是“做饭”（前端页面），但你需要一些“厨具”（构建工具，比如 webpack、vite、eslint），这些厨具是基于 Node.js 的。</p><p>而 npm 就是“厨具商城”，负责给你送工具来。</p><p>虽然你写的是前端 Vue 项目，但你的开发环境其实是这样的：</p><table><thead><tr><th>任务</th><th>Node.js 在干啥</th></tr></thead><tbody><tr><td>安装依赖</td><td>用 npm 下载第三方包</td></tr><tr><td>启动项目</td><td>用 vite &#x2F; webpack 提供本地服务器</td></tr><tr><td>编译打包</td><td>把 .vue 文件打包成浏览器能识别的 HTML&#x2F;CSS&#x2F;JS</td></tr><tr><td>热更新</td><td>改一行代码浏览器自动刷新（HMR）也是 Node 服务提供的</td></tr><tr><td>脚手架</td><td>vue create 就是 Node 工具生成的项目结构</td></tr></tbody></table><p>总结一句话：Vue 项目开发时的所有辅助工作，几乎都是由 Node.js 帮你完成的。</p><hr><h2 id="📦-Vue-依赖-Node-js-的点包括："><a href="#📦-Vue-依赖-Node-js-的点包括：" class="headerlink" title="📦 Vue 依赖 Node.js 的点包括："></a>📦 Vue 依赖 Node.js 的点包括：</h2><table><thead><tr><th>功能</th><th>依赖</th></tr></thead><tbody><tr><td>vue-cli 脚手架</td><td>Node 环境</td></tr><tr><td>npm &#x2F; yarn 安装依赖</td><td>Node 提供</td></tr><tr><td>构建工具（webpack、vite）</td><td>用 Node 写的</td></tr><tr><td>dev server 开发服务器</td><td>用 Node 起的本地服务</td></tr></tbody></table><hr><h2 id="✅-那什么时候-Node-js-才是“写后端”？"><a href="#✅-那什么时候-Node-js-才是“写后端”？" class="headerlink" title="✅ 那什么时候 Node.js 才是“写后端”？"></a>✅ 那什么时候 Node.js 才是“写后端”？</h2><p>如果你用 Node.js + Express&#x2F;Koa 写接口、数据库、登录注册等功能 —— 那就是写后端。</p><p>和你前端 Vue 项目不是一回事！</p><hr><h2 id="🔥-Vue-项目中“用到-Node-js”和“用-Node-写后端”是两回事！"><a href="#🔥-Vue-项目中“用到-Node-js”和“用-Node-写后端”是两回事！" class="headerlink" title="🔥 Vue 项目中“用到 Node.js”和“用 Node 写后端”是两回事！"></a>🔥 Vue 项目中“用到 Node.js”和“用 Node 写后端”是两回事！</h2><table><thead><tr><th>场景</th><th>是否算后端开发？</th><th>是否需要 Node.js</th></tr></thead><tbody><tr><td>Vue 项目开发 + 构建</td><td>❌</td><td>✅</td></tr><tr><td>写接口、连接数据库</td><td>✅</td><td>✅</td></tr><tr><td>网页运行在浏览器</td><td>❌</td><td>❌（构建完 Node 可不参与）</td></tr></tbody></table><p>你用 Vue 写前端页面时，是在用 Node.js 当“工具人”；</p><p>你用 Node.js 写接口时，才是在用它当“后端服务器”。</p><hr><h2 id="🔍-那-Vue-项目中到底用了哪些“Node-的东西”？"><a href="#🔍-那-Vue-项目中到底用了哪些“Node-的东西”？" class="headerlink" title="🔍 那 Vue 项目中到底用了哪些“Node 的东西”？"></a>🔍 那 Vue 项目中到底用了哪些“Node 的东西”？</h2><h3 id="✅-1-项目脚手架（Vue-CLI-Vite）"><a href="#✅-1-项目脚手架（Vue-CLI-Vite）" class="headerlink" title="✅ 1. 项目脚手架（Vue CLI &#x2F; Vite）"></a>✅ 1. 项目脚手架（Vue CLI &#x2F; Vite）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br><span class="line">vue create my-project</span><br></pre></td></tr></table></figure><p>这个 CLI 就是 Node.js 写的工具，用 npm 安装。</p><hr><h3 id="✅-2-构建打包工具（Webpack-Vite-Rollup）"><a href="#✅-2-构建打包工具（Webpack-Vite-Rollup）" class="headerlink" title="✅ 2. 构建打包工具（Webpack &#x2F; Vite &#x2F; Rollup）"></a>✅ 2. 构建打包工具（Webpack &#x2F; Vite &#x2F; Rollup）</h3><ul><li>Vue 单文件组件（.vue）不能直接在浏览器跑，要用这些工具把它们打包成浏览器能识别的 HTML&#x2F;CSS&#x2F;JS。</li><li>这些工具都基于 Node.js 写的，都是 npm 包。</li></ul><hr><h3 id="✅-3-各种开发依赖"><a href="#✅-3-各种开发依赖" class="headerlink" title="✅ 3. 各种开发依赖"></a>✅ 3. 各种开发依赖</h3><ul><li>比如：eslint、prettier、sass-loader、postcss、babel、typescript…</li><li>这些都是 npm 包，不能在浏览器里直接用，必须 Node 运行</li></ul><hr><h3 id="✅-4-npm-也能装前端库（比如-Vue、axios）"><a href="#✅-4-npm-也能装前端库（比如-Vue、axios）" class="headerlink" title="✅ 4. npm 也能装前端库（比如 Vue、axios）"></a>✅ 4. npm 也能装前端库（比如 Vue、axios）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue axios</span><br></pre></td></tr></table></figure><p>这些最终会被打包进浏览器运行，但你依然用 npm 来统一管理它们版本和依赖。</p><p>虽然你的 Vue 项目最终运行在浏览器，但：</p><table><thead><tr><th>阶段</th><th>依赖 Node 吗？</th><th>原因</th></tr></thead><tbody><tr><td>开发阶段</td><td>✅ 必须</td><td>使用 npm 安装工具、运行构建命令、调试等</td></tr><tr><td>构建阶段</td><td>✅ 必须</td><td>用 webpack&#x2F;vite 将项目打包成浏览器可运行的文件</td></tr><tr><td>运行阶段（浏览器）</td><td>❌ 不需要</td><td>最终只加载打包后的 JS、CSS、HTML</td></tr></tbody></table><h1 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h1><p>了解 npm 的原理和常用命令，对前端开发非常有帮助 💡</p><p>以下是简明易懂版，适合快速掌握和日常开发使用！</p><hr><h2 id="🧠-一、npm-是什么？"><a href="#🧠-一、npm-是什么？" class="headerlink" title="🧠 一、npm 是什么？"></a>🧠 一、npm 是什么？</h2><p>npm（Node Package Manager） 是 Node.js 的包管理工具，用来：</p><ul><li>下载 &#x2F; 安装第三方包（比如 axios、vue、lodash）</li><li>管理项目依赖</li><li>执行项目脚本（如 npm run serve）</li></ul><hr><h2 id="⚙️-二、npm-的核心原理"><a href="#⚙️-二、npm-的核心原理" class="headerlink" title="⚙️ 二、npm 的核心原理"></a>⚙️ 二、npm 的核心原理</h2><table><thead><tr><th>原理</th><th>简述</th></tr></thead><tbody><tr><td>📦 package.json</td><td>项目依赖说明文件，npm 安装时会按这个文件下载包</td></tr><tr><td>📁 node_modules</td><td>存放安装好的包</td></tr><tr><td>📄 package-lock.json</td><td>记录依赖包的确切版本，确保项目一致性</td></tr><tr><td>🌍 npm registry</td><td>包服务器地址（默认是 <a href="https://registry.npmjs.org)/">https://registry.npmjs.org）</a></td></tr></tbody></table><h3 id="✅-安装依赖的流程大概是："><a href="#✅-安装依赖的流程大概是：" class="headerlink" title="✅ 安装依赖的流程大概是："></a>✅ 安装依赖的流程大概是：</h3><ol><li>你运行 npm install</li><li>它读取 package.json</li><li>根据依赖树从 npm 官方仓库下载包</li><li>存到 node_modules 中</li><li>生成或更新 package-lock.json</li></ol><hr><h2 id="📚-三、npm-常用命令大全（最实用）"><a href="#📚-三、npm-常用命令大全（最实用）" class="headerlink" title="📚 三、npm 常用命令大全（最实用）"></a>📚 三、npm 常用命令大全（最实用）</h2><h3 id="📥-安装类"><a href="#📥-安装类" class="headerlink" title="📥 安装类"></a>📥 安装类</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>npm install 或 npm i</td><td>安装 package.json 中所有依赖</td></tr><tr><td>npm install xxx</td><td>安装某个包（默认加到 dependencies）</td></tr><tr><td>npm install xxx –save</td><td>显式加到 dependencies（生产依赖）</td></tr><tr><td>npm install xxx –save-dev</td><td>安装到 devDependencies（开发依赖）</td></tr><tr><td>npm install xxx@版本号</td><td>指定版本安装</td></tr><tr><td>npm install –force</td><td>强制安装依赖，忽略冲突</td></tr><tr><td>npm install –legacy-peer-deps</td><td>忽略 peerDependencies 冲突（常用于 React&#x2F;Vue 项目）</td></tr></tbody></table><hr><h3 id="🗑️-卸载类"><a href="#🗑️-卸载类" class="headerlink" title="🗑️ 卸载类"></a>🗑️ 卸载类</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>npm uninstall xxx</td><td>卸载包，并从依赖中移除</td></tr><tr><td>npm remove xxx</td><td>等同于 uninstall</td></tr></tbody></table><hr><h3 id="📋-查看类"><a href="#📋-查看类" class="headerlink" title="📋 查看类"></a>📋 查看类</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>npm list</td><td>查看当前项目已安装的依赖树</td></tr><tr><td>npm list -g</td><td>查看全局安装的依赖</td></tr><tr><td>npm outdated</td><td>查看哪些依赖有新版本</td></tr><tr><td>npm view 包名</td><td>查看包的元信息（如版本、作者）</td></tr></tbody></table><hr><h3 id="🚀-启动类（脚本执行）"><a href="#🚀-启动类（脚本执行）" class="headerlink" title="🚀 启动类（脚本执行）"></a>🚀 启动类（脚本执行）</h3><p>在 package.json 中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;serve&quot;: &quot;vue-cli-service serve&quot;,</span><br><span class="line">  &quot;build&quot;: &quot;vue-cli-service build&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以执行：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>npm run serve</td><td>运行 dev 服务器</td></tr><tr><td>npm run build</td><td>打包构建</td></tr><tr><td>npm run xxx</td><td>运行自定义脚本</td></tr></tbody></table><hr><h3 id="🧹-清理类"><a href="#🧹-清理类" class="headerlink" title="🧹 清理类"></a>🧹 清理类</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>rm -rf node_modules</td><td>删除依赖目录（Mac&#x2F;Linux）</td></tr><tr><td>npm cache clean –force</td><td>清空 npm 缓存</td></tr><tr><td>npm rebuild</td><td>重新编译所有依赖</td></tr></tbody></table><hr><h3 id="🌐-源管理类"><a href="#🌐-源管理类" class="headerlink" title="🌐 源管理类"></a>🌐 源管理类</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>npm config get registry</td><td>查看当前源</td></tr><tr><td>npm config set registry <a href="https://registry.npmmirror.com/">https://registry.npmmirror.com</a></td><td>设置为淘宝镜像（更快）</td></tr><tr><td>npm config delete registry</td><td>恢复默认源</td></tr></tbody></table><hr><h2 id="🧠-常见-npm-问题排查技巧"><a href="#🧠-常见-npm-问题排查技巧" class="headerlink" title="🧠 常见 npm 问题排查技巧"></a>🧠 常见 npm 问题排查技巧</h2><table><thead><tr><th>问题</th><th>解决方式</th></tr></thead><tbody><tr><td>command not found: vue-cli-service</td><td>缺少依赖 → npm install</td></tr><tr><td>Cannot find module ‘xxx’</td><td>安装缺失包 → npm install xxx</td></tr><tr><td>包冲突或报错</td><td>尝试 npm install –legacy-peer-deps</td></tr></tbody></table><hr><h2 id="✅-总结："><a href="#✅-总结：" class="headerlink" title="✅ 总结："></a>✅ 总结：</h2><p>npm 是前端开发的“包管理大管家”，会帮你管理依赖、版本、安装逻辑、脚本执行，配合 package.json 使用才是核心。</p><p>当项目出现依赖混乱、报错或版本冲突时，清理依赖并重新安装是非常常见且有效的做法。下面给你一套稳妥又彻底的清理+重装命令清单 👇</p><hr><h2 id="✅-一键清理并重装依赖的标准流程"><a href="#✅-一键清理并重装依赖的标准流程" class="headerlink" title="✅ 一键清理并重装依赖的标准流程"></a>✅ 一键清理并重装依赖的标准流程</h2><h3 id="📦-Step-1：删除旧的依赖"><a href="#📦-Step-1：删除旧的依赖" class="headerlink" title="📦 Step 1：删除旧的依赖"></a>📦 Step 1：删除旧的依赖</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf node_modules package-lock.json</span><br></pre></td></tr></table></figure><p>这两项分别是：</p><ul><li>node_modules：依赖实际安装的位置</li><li>package-lock.json：锁定的版本清单（不是必删，但推荐一起删）</li></ul><hr><h3 id="🧹-Step-2：清空-npm-缓存（可选，但推荐）"><a href="#🧹-Step-2：清空-npm-缓存（可选，但推荐）" class="headerlink" title="🧹 Step 2：清空 npm 缓存（可选，但推荐）"></a>🧹 Step 2：清空 npm 缓存（可选，但推荐）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm cache clean --force</span><br></pre></td></tr></table></figure><p>用于清理本地缓存文件，防止缓存损坏影响安装</p><hr><h3 id="🔄-Step-3：重新安装依赖"><a href="#🔄-Step-3：重新安装依赖" class="headerlink" title="🔄 Step 3：重新安装依赖"></a>🔄 Step 3：重新安装依赖</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>npm 会重新读取 package.json，把依赖全部安装回来，并重新生成 package-lock.json。</p><hr><h3 id="👌-一步到位命令（适合老手）："><a href="#👌-一步到位命令（适合老手）：" class="headerlink" title="👌 一步到位命令（适合老手）："></a>👌 一步到位命令（适合老手）：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf node_modules package-lock.json &amp;&amp; npm cache clean --force &amp;&amp; npm install</span><br></pre></td></tr></table></figure><hr><h2 id="🧠-如果你用的是"><a href="#🧠-如果你用的是" class="headerlink" title="🧠 如果你用的是"></a>🧠 如果你用的是</h2><h2 id="yarn或-pnpm"><a href="#yarn或-pnpm" class="headerlink" title="yarn或 pnpm"></a>yarn或 pnpm</h2><table><thead><tr><th>包管理器</th><th>清理命令</th><th>安装命令</th></tr></thead><tbody><tr><td>yarn</td><td>rm -rf node_modules yarn.lock</td><td>yarn</td></tr><tr><td>pnpm</td><td>pnpm install –force</td><td>pnpm install</td></tr></tbody></table><hr><h2 id="⚠️-清理依赖常见适用场景"><a href="#⚠️-清理依赖常见适用场景" class="headerlink" title="⚠️ 清理依赖常见适用场景"></a>⚠️ 清理依赖常见适用场景</h2><ul><li>npm run serve 报依赖错误</li><li>模块找不到（Cannot find module）</li><li>vue&#x2F;webpack&#x2F;react 插件报版本冲突</li><li>项目长时间未维护，首次拉代码构建失败</li></ul><hr><h1 id="yarn和npm对比"><a href="#yarn和npm对比" class="headerlink" title="yarn和npm对比"></a>yarn和npm对比</h1><h2 id="🧠-一、Yarn-是什么？"><a href="#🧠-一、Yarn-是什么？" class="headerlink" title="🧠 一、Yarn 是什么？"></a>🧠 一、Yarn 是什么？</h2><p>Yarn 是由 Facebook 开发的 JS 包管理工具，是 npm 的一个替代品，解决了 npm 早期的速度慢、版本不一致、并发差等问题。</p><p>它和 npm 的作用一样——安装&#x2F;管理项目依赖包，但更加快速、安全。</p><hr><h2 id="⚙️-二、Yarn-的工作原理（核心理解）"><a href="#⚙️-二、Yarn-的工作原理（核心理解）" class="headerlink" title="⚙️ 二、Yarn 的工作原理（核心理解）"></a>⚙️ 二、Yarn 的工作原理（核心理解）</h2><p>Yarn 通过以下几个机制提升效率和稳定性：</p><table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td>📦 离线缓存</td><td>安装过一次的包会缓存，下一次无需联网安装</td></tr><tr><td>🧩 确定性安装</td><td>使用 yarn.lock 锁定精确依赖，确保团队一致</td></tr><tr><td>⚡ 并行安装</td><td>多个依赖一起装，比 npm 串行快很多</td></tr><tr><td>✅ 一致性校验</td><td>通过 integrity 字段校验包完整性</td></tr></tbody></table><hr><h2 id="🔧-三、Yarn-和-npm-的区别对照表"><a href="#🔧-三、Yarn-和-npm-的区别对照表" class="headerlink" title="🔧 三、Yarn 和 npm 的区别对照表"></a>🔧 三、Yarn 和 npm 的区别对照表</h2><table><thead><tr><th>功能</th><th>npm</th><th>yarn</th></tr></thead><tbody><tr><td>安装命令</td><td>npm install</td><td>yarn install</td></tr><tr><td>添加依赖</td><td>npm install xxx</td><td>yarn add xxx</td></tr><tr><td>删除依赖</td><td>npm uninstall xxx</td><td>yarn remove xxx</td></tr><tr><td>锁文件名</td><td>package-lock.json</td><td>yarn.lock</td></tr><tr><td>缓存清理</td><td>npm cache clean –force</td><td>yarn cache clean</td></tr></tbody></table><hr><h2 id="🧪-四、Yarn-常用命令大全（实用高频）"><a href="#🧪-四、Yarn-常用命令大全（实用高频）" class="headerlink" title="🧪 四、Yarn 常用命令大全（实用高频）"></a>🧪 四、Yarn 常用命令大全（实用高频）</h2><h3 id="📥-安装依赖"><a href="#📥-安装依赖" class="headerlink" title="📥 安装依赖"></a>📥 安装依赖</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>yarn</td><td>安装所有依赖（读取 package.json 和 yarn.lock）</td></tr><tr><td>yarn add 包名</td><td>安装并写入 dependencies</td></tr><tr><td>yarn add 包名@版本</td><td>安装指定版本</td></tr><tr><td>yarn add 包名 -D</td><td>安装到 devDependencies（开发依赖）</td></tr><tr><td>yarn add 包名 -P</td><td>安装到 peerDependencies</td></tr><tr><td>yarn global add 包名</td><td>全局安装</td></tr></tbody></table><hr><h3 id="🧹-卸载依赖"><a href="#🧹-卸载依赖" class="headerlink" title="🧹 卸载依赖"></a>🧹 卸载依赖</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn remove 包名</span><br></pre></td></tr></table></figure><hr><h3 id="🔄-更新依赖"><a href="#🔄-更新依赖" class="headerlink" title="🔄 更新依赖"></a>🔄 更新依赖</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn upgrade 包名@版本</span><br></pre></td></tr></table></figure><hr><h3 id="🏃-执行脚本命令"><a href="#🏃-执行脚本命令" class="headerlink" title="🏃 执行脚本命令"></a>🏃 执行脚本命令</h3><p>和 npm run 类似：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn serve</span><br><span class="line">yarn build</span><br><span class="line">yarn dev</span><br></pre></td></tr></table></figure><hr><h3 id="📦-缓存操作"><a href="#📦-缓存操作" class="headerlink" title="📦 缓存操作"></a>📦 缓存操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn cache list        # 查看缓存</span><br><span class="line">yarn cache clean       # 清理缓存</span><br></pre></td></tr></table></figure><hr><h3 id="🧼-一键重装依赖（常用命令）"><a href="#🧼-一键重装依赖（常用命令）" class="headerlink" title="🧼 一键重装依赖（常用命令）"></a>🧼 一键重装依赖（常用命令）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -rf node_modules yarn.lock</span><br><span class="line">yarn</span><br></pre></td></tr></table></figure><hr><h3 id="🔎-查看信息"><a href="#🔎-查看信息" class="headerlink" title="🔎 查看信息"></a>🔎 查看信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn list              # 查看已安装依赖树</span><br><span class="line">yarn info 包名         # 查看包的详情</span><br></pre></td></tr></table></figure><hr><h2 id="🧠-五、项目什么时候用-Yarn-好？"><a href="#🧠-五、项目什么时候用-Yarn-好？" class="headerlink" title="🧠 五、项目什么时候用 Yarn 好？"></a>🧠 五、项目什么时候用 Yarn 好？</h2><ul><li>团队协作时：yarn.lock 能保证依赖版本一致</li><li>CI&#x2F;CD 自动部署：更快更稳</li><li>项目依赖多、装包慢：Yarn 并发性能好</li><li>出现 npm 报错时，切换 yarn 可能避坑</li></ul><hr><h2 id="✅-总结：-1"><a href="#✅-总结：-1" class="headerlink" title="✅ 总结："></a>✅ 总结：</h2><p>Yarn 是更快、更可靠的 npm 替代方案，命令更清晰，安装更快，锁定更稳定。</p><hr><h3 id="⚡-想快速上手-Yarn？"><a href="#⚡-想快速上手-Yarn？" class="headerlink" title="⚡ 想快速上手 Yarn？"></a>⚡ 想快速上手 Yarn？</h3><p>你只需要记住这 5 条就够用了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yarn                 # 安装依赖</span><br><span class="line">yarn add xxx         # 添加依赖</span><br><span class="line">yarn remove xxx      # 删除依赖</span><br><span class="line">yarn run xxx         # 执行脚本</span><br><span class="line">yarn cache clean     # 清缓存</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端扫盲 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vuex 原理及案例</title>
      <link href="/2025/04/03/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/VUE/vuex/"/>
      <url>/2025/04/03/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/VUE/vuex/</url>
      
        <content type="html"><![CDATA[<h2 id="Vuex-基本原理"><a href="#Vuex-基本原理" class="headerlink" title="Vuex 基本原理"></a>Vuex 基本原理</h2><p>Vuex 是专门为 Vue.js 设计的状态管理库，它的核心思想是集中式存储管理应用的所有组件状态，并以响应式的方式进行数据管理与交互。</p><hr><h3 id="一、Vuex-核心概念与功能"><a href="#一、Vuex-核心概念与功能" class="headerlink" title="一、Vuex 核心概念与功能"></a>一、Vuex 核心概念与功能</h3><p>Vuex 核心由以下几个部分组成：</p><ol><li><p><strong>State（状态）</strong><br>单一数据源，用于存储全局状态。</p></li><li><p><strong>Getters（派生状态）</strong><br>类似于计算属性，用于从状态中派生出新的状态。</p></li><li><p><strong>Mutations（变更）</strong><br>修改状态的唯一方式，同步操作。</p></li><li><p><strong>Actions（动作）</strong><br>提交 Mutation，而不是直接变更状态，可以包含异步操作。</p></li><li><p><strong>Modules（模块）</strong><br>对 store 状态进行拆分，避免单一状态树过于复杂。</p></li></ol><hr><h3 id="二、Vuex-工作流程"><a href="#二、Vuex-工作流程" class="headerlink" title="二、Vuex 工作流程"></a>二、Vuex 工作流程</h3><p>Vuex 的基本运作原理可以简单概括为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">组件（Components）</span><br><span class="line">    ↓ 提交（dispatch）</span><br><span class="line">Actions（异步业务逻辑）</span><br><span class="line">    ↓ 提交（commit）</span><br><span class="line">Mutations（唯一修改状态的方式）</span><br><span class="line">    ↓ 修改</span><br><span class="line">State（全局唯一状态）</span><br><span class="line">    ↓ 响应式更新</span><br><span class="line">组件（Components）</span><br></pre></td></tr></table></figure><p>详细流程：</p><ul><li>组件触发事件后调用 <strong>actions</strong>；</li><li><strong>actions</strong> 内执行异步请求或其他逻辑，随后提交 <strong>mutations</strong>；</li><li><strong>mutations</strong> 修改 state，Vuex 会通知所有依赖该 state 的组件进行响应式更新；</li><li>组件实时渲染 state 数据变化。</li></ul><hr><h3 id="三、Vuex-响应式原理（核心）"><a href="#三、Vuex-响应式原理（核心）" class="headerlink" title="三、Vuex 响应式原理（核心）"></a>三、Vuex 响应式原理（核心）</h3><p>Vuex 本质是利用了 Vue 内部提供的响应式系统。</p><ul><li><p>Vuex 内部利用了 Vue 的实例来存储 state（状态）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>当 state 中数据变化时，Vue 会通过 <strong>getter&#x2F;setter</strong> 来检测，并自动通知所有依赖这个状态的组件重新渲染。</p></li><li><p>Vuex 的 store 实例将状态托管在 Vue 实例内部，并暴露 state 给组件，组件使用 computed 属性绑定到 Vuex 状态，从而实现响应式更新。</p></li></ul><hr><h3 id="四、核心源码解析（简化版）"><a href="#四、核心源码解析（简化版）" class="headerlink" title="四、核心源码解析（简化版）"></a>四、核心源码解析（简化版）</h3><p>以下是 Vuex 底层的简化源码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Store</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="comment">// 响应式state</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_vm</span> = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">      <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">$$state</span>: options.<span class="property">state</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_mutations</span> = options.<span class="property">mutations</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_actions</span> = options.<span class="property">actions</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">getters</span> = &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实现 getters</span></span><br><span class="line">    <span class="keyword">if</span> (options.<span class="property">getters</span>) &#123;</span><br><span class="line">      <span class="title class_">Object</span>.<span class="title function_">keys</span>(options.<span class="property">getters</span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="variable language_">this</span>.<span class="property">getters</span>, key, &#123;</span><br><span class="line">          <span class="attr">get</span>: <span class="function">() =&gt;</span> options.<span class="property">getters</span>[key](<span class="variable language_">this</span>.<span class="property">state</span>)</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取状态</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">state</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_vm</span>.<span class="property">_data</span>.<span class="property">$$state</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// commit 方法触发 mutations</span></span><br><span class="line">  commit = <span class="function">(<span class="params">type, payload</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_mutations</span>[type]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_mutations</span>[type](<span class="variable language_">this</span>.<span class="property">state</span>, payload);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// dispatch 方法触发 actions</span></span><br><span class="line">  dispatch = <span class="function">(<span class="params">type, payload</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_actions</span>[type]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_actions</span>[type](&#123;</span><br><span class="line">        <span class="attr">state</span>: <span class="variable language_">this</span>.<span class="property">state</span>,</span><br><span class="line">        <span class="attr">commit</span>: <span class="variable language_">this</span>.<span class="property">commit</span>,</span><br><span class="line">        <span class="attr">dispatch</span>: <span class="variable language_">this</span>.<span class="property">dispatch</span></span><br><span class="line">      &#125;, payload);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="五、为什么要使用-Vuex？"><a href="#五、为什么要使用-Vuex？" class="headerlink" title="五、为什么要使用 Vuex？"></a>五、为什么要使用 Vuex？</h3><ul><li><strong>统一的状态管理</strong>：便于状态的追踪、调试和管理；</li><li><strong>状态共享</strong>：在不同组件间高效共享状态；</li><li><strong>解决组件间通信复杂性</strong>：避免组件之间频繁传递 props 或通过事件通信；</li><li><strong>方便调试和日志记录</strong>：配合 devtools 插件进行状态回溯与调试；</li><li><strong>易于扩展与维护</strong>：状态逻辑和 UI 分离，代码结构更加清晰。</li></ul><hr><h3 id="六、适合使用-Vuex-的场景"><a href="#六、适合使用-Vuex-的场景" class="headerlink" title="六、适合使用 Vuex 的场景"></a>六、适合使用 Vuex 的场景</h3><ul><li>需要共享的全局状态；</li><li>状态在多个组件之间频繁交互；</li><li>数据来源复杂（如存在异步请求，数据计算较多）；</li><li>中大型项目，数据流向较复杂。</li></ul><hr><h2 id="Vuex-应用场景及案例"><a href="#Vuex-应用场景及案例" class="headerlink" title="Vuex 应用场景及案例"></a>Vuex 应用场景及案例</h2><p>Vuex 是 Vue.js 中用于状态管理的库，适用于中大型应用中的状态管理，特别是当应用状态需要在多个组件间共享或跨越多个层级时。它能够集中管理应用的状态、行为和计算属性，避免了多层嵌套的状态传递问题。</p><h3 id="📌-一、Vuex-应用场景"><a href="#📌-一、Vuex-应用场景" class="headerlink" title="📌 一、Vuex 应用场景"></a>📌 一、Vuex 应用场景</h3><ol><li><p><strong>全局共享的状态</strong><br>当多个组件需要共享同一份数据时，Vuex 提供了一种集中式管理的方式，避免了频繁地通过 props 和 events 进行通信。</p></li><li><p><strong>多个组件之间的复杂数据流</strong><br>在需要跨越多个组件层级、组件之间没有直接关系时，Vuex 可以通过 store 来管理状态，避免层层传递 props 或事件。</p></li><li><p><strong>需要处理异步数据的场景</strong><br>例如，数据请求、用户登录、实时更新等，需要对异步操作进行管理时，Vuex 的 actions 能帮助我们集中处理异步操作和状态变更。</p></li><li><p><strong>应用需要调试和回溯的场景</strong><br>使用 Vuex 可以通过 Vue DevTools 方便地调试状态的变化，回溯到特定的操作步骤，这在开发过程中十分有用。</p></li><li><p><strong>中大型应用的状态管理</strong><br>在大型应用中，Vuex 作为状态管理工具能够提高代码的可维护性、可扩展性，并减少代码重复。</p></li></ol><hr><h3 id="📌-二、Vuex-示例案例"><a href="#📌-二、Vuex-示例案例" class="headerlink" title="📌 二、Vuex 示例案例"></a>📌 二、Vuex 示例案例</h3><p>以下是一个简单的 Vuex 示例，展示了如何使用 Vuex 管理共享状态、处理异步操作和更新状态。</p><h4 id="1-Vuex-Store-的定义"><a href="#1-Vuex-Store-的定义" class="headerlink" title="1. Vuex Store 的定义"></a>1. <strong>Vuex Store 的定义</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span>,  <span class="comment">// 存储应用的状态</span></span><br><span class="line">    <span class="attr">user</span>: <span class="literal">null</span>,  <span class="comment">// 存储用户信息</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="title function_">increment</span>(<span class="params">state</span>) &#123;</span><br><span class="line">      state.<span class="property">count</span>++;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">setUser</span>(<span class="params">state, user</span>) &#123;</span><br><span class="line">      state.<span class="property">user</span> = user;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="title function_">fetchUser</span>(<span class="params">&#123; commit &#125;</span>) &#123;</span><br><span class="line">      <span class="comment">// 模拟异步操作，例如通过 API 获取用户数据</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> user = &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;John Doe&#x27;</span> &#125;;</span><br><span class="line">        <span class="title function_">commit</span>(<span class="string">&#x27;setUser&#x27;</span>, user);</span><br><span class="line">      &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="title function_">userName</span>(<span class="params">state</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.<span class="property">user</span> ? state.<span class="property">user</span>.<span class="property">name</span> : <span class="string">&#x27;Guest&#x27;</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">count</span>(<span class="params">state</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.<span class="property">count</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/neoisok/assets@main/images%2F2025%2F04%2F03%2F20250403153600768-b1aa99e2ecf6795bb11482f19e76a5b3.png" width=600><h4 id="2-组件中使用-Vuex"><a href="#2-组件中使用-Vuex" class="headerlink" title="2. 组件中使用 Vuex"></a>2. <strong>组件中使用 Vuex</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>User: &#123;&#123; userName &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span>Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;fetchUser&quot;</span>&gt;</span>Fetch User<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; mapState, mapGetters, mapActions, mapMutations &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">computed</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    ...<span class="title function_">mapState</span>([<span class="string">&#x27;count&#x27;</span>, <span class="string">&#x27;user&#x27;</span>]),</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    ...<span class="title function_">mapGetters</span>([<span class="string">&#x27;userName&#x27;</span>])</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    ...<span class="title function_">mapActions</span>([<span class="string">&#x27;fetchUser&#x27;</span>]),</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    ...<span class="title function_">mapMutations</span>([<span class="string">&#x27;increment&#x27;</span>]),</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="3-简要解释"><a href="#3-简要解释" class="headerlink" title="3. 简要解释"></a>3. <strong>简要解释</strong></h4><ul><li><strong>State</strong>: <code>count</code> 和 <code>user</code> 是共享的状态，<code>count</code> 用于计数，<code>user</code> 存储用户信息。</li><li><strong>Mutations</strong>: <code>increment</code> 用于同步修改 <code>count</code>，<code>setUser</code> 用于修改 <code>user</code>。</li><li><strong>Actions</strong>: <code>fetchUser</code> 是一个异步操作，模拟获取用户数据并提交到 mutation。</li><li><strong>Getters</strong>: <code>userName</code> 用于从 <code>user</code> 中派生出用户名，<code>count</code> 用于获取 <code>count</code> 值。</li></ul><h4 id="4-示例操作"><a href="#4-示例操作" class="headerlink" title="4. 示例操作"></a>4. <strong>示例操作</strong></h4><ul><li>点击 <strong>Increment</strong> 按钮会调用 <code>increment</code> 方法，触发 <code>mutations</code> 更新 <code>count</code>。</li><li>点击 <strong>Fetch User</strong> 会调用 <code>fetchUser</code> 动作，模拟异步获取用户数据并提交 mutation 更新用户信息。</li></ul><h3 id="📌-三、更多应用场景"><a href="#📌-三、更多应用场景" class="headerlink" title="📌 三、更多应用场景"></a>📌 三、更多应用场景</h3><h4 id="1-购物车管理"><a href="#1-购物车管理" class="headerlink" title="1. 购物车管理"></a>1. <strong>购物车管理</strong></h4><p>在电商网站中，购物车状态（如商品数量、总价等）通常是应用的核心状态。Vuex 可以用来集中管理购物车状态。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">cart</span>: []</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="title function_">addToCart</span>(<span class="params">state, product</span>) &#123;</span><br><span class="line">      state.<span class="property">cart</span>.<span class="title function_">push</span>(product);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">removeFromCart</span>(<span class="params">state, productId</span>) &#123;</span><br><span class="line">      state.<span class="property">cart</span> = state.<span class="property">cart</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">product</span> =&gt;</span> product.<span class="property">id</span> !== productId);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="title function_">checkout</span>(<span class="params">&#123; commit, state &#125;</span>) &#123;</span><br><span class="line">      <span class="comment">// 模拟结算操作</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Checkout successful&#x27;</span>);</span><br><span class="line">        <span class="title function_">commit</span>(<span class="string">&#x27;clearCart&#x27;</span>);</span><br><span class="line">      &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="title function_">cartItems</span>(<span class="params">state</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.<span class="property">cart</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">cartTotal</span>(<span class="params">state</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.<span class="property">cart</span>.<span class="title function_">reduce</span>(<span class="function">(<span class="params">total, item</span>) =&gt;</span> total + item.<span class="property">price</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="2-用户认证与授权"><a href="#2-用户认证与授权" class="headerlink" title="2. 用户认证与授权"></a>2. <strong>用户认证与授权</strong></h4><p>在用户登录、退出等场景中，Vuex 可用来管理用户的登录状态、权限等信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">isAuthenticated</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">user</span>: <span class="literal">null</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="title function_">login</span>(<span class="params">state, user</span>) &#123;</span><br><span class="line">      state.<span class="property">isAuthenticated</span> = <span class="literal">true</span>;</span><br><span class="line">      state.<span class="property">user</span> = user;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">logout</span>(<span class="params">state</span>) &#123;</span><br><span class="line">      state.<span class="property">isAuthenticated</span> = <span class="literal">false</span>;</span><br><span class="line">      state.<span class="property">user</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="title function_">login</span>(<span class="params">&#123; commit &#125;, credentials</span>) &#123;</span><br><span class="line">      <span class="comment">// 模拟登录</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> user = &#123; <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>, <span class="attr">role</span>: <span class="string">&#x27;admin&#x27;</span> &#125;;</span><br><span class="line">        <span class="title function_">commit</span>(<span class="string">&#x27;login&#x27;</span>, user);</span><br><span class="line">      &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">logout</span>(<span class="params">&#123; commit &#125;</span>) &#123;</span><br><span class="line">      <span class="title function_">commit</span>(<span class="string">&#x27;logout&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="title function_">isAuthenticated</span>(<span class="params">state</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.<span class="property">isAuthenticated</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">currentUser</span>(<span class="params">state</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.<span class="property">user</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><h3 id="📌-四、总结"><a href="#📌-四、总结" class="headerlink" title="📌 四、总结"></a>📌 四、总结</h3><p>Vuex 适用于以下情况：</p><ul><li>多个组件共享状态；</li><li>状态需要被多个组件访问或修改；</li><li>需要管理复杂的异步操作；</li><li>需要在多个层级的组件中传递数据。</li></ul><p>在以上应用场景下，Vuex 通过集中管理应用的状态、行为和计算属性，帮助开发者更好地管理和调试复杂的 Vue 应用。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 前端 </category>
          
          <category> vue </category>
          
          <category> vuex </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven 多模块项目（Multi-Module）</title>
      <link href="/2025/03/28/%E6%8A%80%E6%9C%AF/java/%E6%A1%86%E6%9E%B6/Maven/Maven%20%E5%A4%9A%E6%A8%A1%E5%9D%97%E9%A1%B9%E7%9B%AE%EF%BC%88Multi-Module%EF%BC%89/"/>
      <url>/2025/03/28/%E6%8A%80%E6%9C%AF/java/%E6%A1%86%E6%9E%B6/Maven/Maven%20%E5%A4%9A%E6%A8%A1%E5%9D%97%E9%A1%B9%E7%9B%AE%EF%BC%88Multi-Module%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="🏗️-Maven-多模块项目（Multi-Module）"><a href="#🏗️-Maven-多模块项目（Multi-Module）" class="headerlink" title="🏗️ Maven 多模块项目（Multi-Module）"></a>🏗️ Maven 多模块项目（Multi-Module）</h1><hr><h2 id="1️⃣-父子项目结构设计"><a href="#1️⃣-父子项目结构设计" class="headerlink" title="1️⃣ 父子项目结构设计"></a>1️⃣ 父子项目结构设计</h2><h3 id="✅-结构示意图："><a href="#✅-结构示意图：" class="headerlink" title="✅ 结构示意图："></a>✅ 结构示意图：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">multi-module-parent/</span><br><span class="line">├── pom.xml             ← 父模块（聚合器 + 版本控制）</span><br><span class="line">├── module-a/</span><br><span class="line">│   └── pom.xml         ← 子模块A（如 API 层）</span><br><span class="line">├── module-b/</span><br><span class="line">│   └── pom.xml         ← 子模块B（如 Service 层）</span><br></pre></td></tr></table></figure><h3 id="✅-父模块（Parent-POM）特点："><a href="#✅-父模块（Parent-POM）特点：" class="headerlink" title="✅ 父模块（Parent POM）特点："></a>✅ 父模块（Parent POM）特点：</h3><ul><li>类型为 <code>pom</code></li><li>用来统一版本管理、依赖版本、插件版本</li><li>一般不包含实际代码</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="✅-子模块的-pom-xml-需要："><a href="#✅-子模块的-pom-xml-需要：" class="headerlink" title="✅ 子模块的 pom.xml 需要："></a>✅ 子模块的 <code>pom.xml</code> 需要：</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.neo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>multi-module-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="2️⃣-聚合（Aggregation）vs-继承（Inheritance）"><a href="#2️⃣-聚合（Aggregation）vs-继承（Inheritance）" class="headerlink" title="2️⃣ 聚合（Aggregation）vs 继承（Inheritance）"></a>2️⃣ 聚合（Aggregation）vs 继承（Inheritance）</h2><table><thead><tr><th>区别点</th><th>聚合 Aggregation</th><th>继承 Inheritance</th></tr></thead><tbody><tr><td>定义</td><td>在父模块中 <code>&lt;modules&gt;</code> 声明子模块</td><td>子模块在 <code>&lt;parent&gt;</code> 指向父模块</td></tr><tr><td>作用</td><td>用于一次性构建多个模块</td><td>用于复用 POM 中的版本、依赖、插件配置</td></tr><tr><td>是否必须写</td><td>父模块需要写 <code>&lt;modules&gt;</code></td><td>子模块需要写 <code>&lt;parent&gt;</code></td></tr><tr><td>构建影响</td><td><code>mvn install</code> 会构建所有模块</td><td>仅靠继承不会构建，需要聚合才能批量构建</td></tr></tbody></table><h3 id="✅-示例（父模块）："><a href="#✅-示例（父模块）：" class="headerlink" title="✅ 示例（父模块）："></a>✅ 示例（父模块）：</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">module</span>&gt;</span>module-a<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">module</span>&gt;</span>module-b<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="3️⃣-多模块构建顺序控制"><a href="#3️⃣-多模块构建顺序控制" class="headerlink" title="3️⃣ 多模块构建顺序控制"></a>3️⃣ 多模块构建顺序控制</h2><p>Maven 默认会<strong>自动计算模块之间的依赖关系</strong>，确保：</p><blockquote><p><strong>先构建被依赖的模块，再构建依赖它的模块</strong></p></blockquote><hr><h3 id="✅-举个例子："><a href="#✅-举个例子：" class="headerlink" title="✅ 举个例子："></a>✅ 举个例子：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A（依赖 B）</span><br><span class="line">B（依赖 C）</span><br><span class="line">C（最底层）</span><br></pre></td></tr></table></figure><blockquote><p>Maven 构建顺序是：C → B → A</p></blockquote><p>📌 使用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean install</span><br></pre></td></tr></table></figure><p>就会自动按依赖关系构建好所有模块。</p><hr><h3 id="❗-注意："><a href="#❗-注意：" class="headerlink" title="❗ 注意："></a>❗ 注意：</h3><p>如果你写了 <code>&lt;modules&gt;</code> 顺序是 A、B、C，Maven 仍然会自动识别依赖关系，按正确顺序构建！</p><hr><h2 id="🛠-实用命令小结："><a href="#🛠-实用命令小结：" class="headerlink" title="🛠 实用命令小结："></a>🛠 实用命令小结：</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>mvn clean install</code></td><td>在父模块目录构建所有模块</td></tr><tr><td><code>mvn install -pl module-b</code></td><td>只构建指定模块（含依赖）</td></tr><tr><td><code>mvn install -pl module-b -am</code></td><td>同时构建模块及其依赖模块</td></tr><tr><td><code>mvn install -pl module-a -am -amd</code></td><td>同时构建依赖模块和被依赖模块</td></tr></tbody></table><hr><h2 id="✅-口诀："><a href="#✅-口诀：" class="headerlink" title="✅ 口诀："></a>✅ 口诀：</h2><blockquote><p>聚合管构建，继承管配置；<br>顺序靠依赖，声明看结构；<br>父子联动用，模块拆得巧。</p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> java </category>
          
          <category> 框架 </category>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven 依赖管理深入理解</title>
      <link href="/2025/03/28/%E6%8A%80%E6%9C%AF/java/%E6%A1%86%E6%9E%B6/Maven/Maven%20%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
      <url>/2025/03/28/%E6%8A%80%E6%9C%AF/java/%E6%A1%86%E6%9E%B6/Maven/Maven%20%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="📦-Maven-依赖管理深入理解"><a href="#📦-Maven-依赖管理深入理解" class="headerlink" title="📦 Maven 依赖管理深入理解"></a>📦 Maven 依赖管理深入理解</h1><hr><h2 id="1️⃣-本地仓库-中央仓库-私服仓库"><a href="#1️⃣-本地仓库-中央仓库-私服仓库" class="headerlink" title="1️⃣ 本地仓库 &#x2F; 中央仓库 &#x2F; 私服仓库"></a>1️⃣ 本地仓库 &#x2F; 中央仓库 &#x2F; 私服仓库</h2><h3 id="✅-本地仓库（Local-Repository）"><a href="#✅-本地仓库（Local-Repository）" class="headerlink" title="✅ 本地仓库（Local Repository）"></a>✅ 本地仓库（Local Repository）</h3><ul><li>默认位置：<code>~/.m2/repository</code></li><li>每次执行 Maven 命令，优先从本地仓库查找依赖</li><li>下载成功的依赖将缓存在此处（不会重复下载）</li></ul><hr><h3 id="✅-中央仓库（Maven-Central）"><a href="#✅-中央仓库（Maven-Central）" class="headerlink" title="✅ 中央仓库（Maven Central）"></a>✅ 中央仓库（Maven Central）</h3><ul><li>默认远程仓库，地址：<a href="https://repo.maven.apache.org/maven2/">https://repo.maven.apache.org/maven2/</a></li><li>超级 POM 中内置，不写任何配置也能访问</li><li>缺失的依赖默认从这里下载到本地仓库</li></ul><hr><h3 id="✅-私服仓库（Nexus、Artifactory）"><a href="#✅-私服仓库（Nexus、Artifactory）" class="headerlink" title="✅ 私服仓库（Nexus、Artifactory）"></a>✅ 私服仓库（Nexus、Artifactory）</h3><ul><li>企业级常见：统一缓存、权限控制、私有发布</li><li>配置方式：写入 <code>~/.m2/settings.xml</code> 中的 <code>&lt;mirrors&gt;</code> 或 <code>&lt;profiles&gt;</code>：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://nexus.company.com/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="2️⃣-依赖传递与冲突解决"><a href="#2️⃣-依赖传递与冲突解决" class="headerlink" title="2️⃣ 依赖传递与冲突解决"></a>2️⃣ 依赖传递与冲突解决</h2><h3 id="✅-依赖传递（Transitive-Dependency）"><a href="#✅-依赖传递（Transitive-Dependency）" class="headerlink" title="✅ 依赖传递（Transitive Dependency）"></a>✅ 依赖传递（Transitive Dependency）</h3><blockquote><p>Maven 会自动引入依赖的依赖（最多支持无限级）</p></blockquote><p>🧱 示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">项目A → 引入 spring-web</span><br><span class="line">        → spring-web 自动引入 spring-core → spring-jcl</span><br></pre></td></tr></table></figure><p>你不需要手动写每一级依赖。</p><hr><h3 id="✅-冲突解决规则"><a href="#✅-冲突解决规则" class="headerlink" title="✅ 冲突解决规则"></a>✅ 冲突解决规则</h3><hr><h4 id="🔍-实际-Maven-的判定规则是："><a href="#🔍-实际-Maven-的判定规则是：" class="headerlink" title="🔍 实际 Maven 的判定规则是："></a>🔍 实际 Maven 的判定规则是：</h4><h5 id="✅-距离优先（Nearest-First）"><a href="#✅-距离优先（Nearest-First）" class="headerlink" title="✅ 距离优先（Nearest First）"></a>✅ 距离优先（Nearest First）</h5><ul><li>谁离根项目（项目 A）路径更短，谁胜</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">├── B（依赖 log4j:1.2.17）    ← 距离 = 2</span><br><span class="line">│</span><br><span class="line">└── C</span><br><span class="line">     └── D</span><br><span class="line">         └── log4j:2.17.0     ← 距离 = 4</span><br></pre></td></tr></table></figure><p>在这个例子里：</p><ul><li>log4j:1.2.17 的路径是：A → B → log4j（共 2 层）</li><li>log4j:2.17.0 的路径是：A → C → D → log4j（共 4 层）</li></ul><p>✅ 所以最终使用：<strong>log4j:1.2.17</strong>（距离近）</p><h5 id="✅-顺序优先（First-Declaration-Wins）"><a href="#✅-顺序优先（First-Declaration-Wins）" class="headerlink" title="✅ 顺序优先（First Declaration Wins）"></a>✅ 顺序优先（First Declaration Wins）</h5><ul><li>如果距离一样，谁<strong>先出现在依赖树中</strong>，谁胜出（通常是依赖声明顺序）</li></ul><p>📌 举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">项目A</span><br><span class="line">├── B（log4j:1.2.17）</span><br><span class="line">└── C（log4j:2.17.0）</span><br><span class="line"></span><br><span class="line">→ A 最终使用 log4j:1.2.17（因为 B 先出现在依赖树中）</span><br></pre></td></tr></table></figure><hr><h3 id="🔍-查看依赖冲突命令："><a href="#🔍-查看依赖冲突命令：" class="headerlink" title="🔍 查看依赖冲突命令："></a>🔍 查看依赖冲突命令：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn dependency:tree</span><br></pre></td></tr></table></figure><p>可以加 <code>-Dverbose</code> 显示冲突信息。</p><hr><h2 id="3️⃣-依赖范围（scope）"><a href="#3️⃣-依赖范围（scope）" class="headerlink" title="3️⃣ 依赖范围（scope）"></a>3️⃣ 依赖范围（scope）</h2><p>控制依赖在构建生命周期中何时可用，是否打进包里：</p><table><thead><tr><th>范围</th><th>用途</th><th>编译可用</th><th>测试可用</th><th>运行可用</th><th>打进包</th></tr></thead><tbody><tr><td><code>compile</code>（默认）</td><td>常规依赖</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td><code>provided</code></td><td>编译需要，运行由容器提供（如 Servlet）</td><td>✅</td><td>✅</td><td>❌</td><td>❌</td></tr><tr><td><code>runtime</code></td><td>编译不需要，运行需要</td><td>❌</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td><code>test</code></td><td>仅测试代码用（如 JUnit）</td><td>❌</td><td>✅</td><td>❌</td><td>❌</td></tr><tr><td><code>system</code>（不推荐）</td><td>使用本地 jar 包</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td><code>import</code></td><td>仅用于 <code>&lt;dependencyManagement&gt;</code> 引入 BOM</td><td>-</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><p>📌 示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="4️⃣-排除依赖（exclusions）"><a href="#4️⃣-排除依赖（exclusions）" class="headerlink" title="4️⃣ 排除依赖（exclusions）"></a>4️⃣ 排除依赖（exclusions）</h2><p>用来解决<strong>传递依赖冲突</strong>或剔除无用&#x2F;冲突组件。</p><p>📌 示例：排除 spring-boot-starter 中的 logback</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h2><ol><li>手动引入冲突依赖，运行 <code>mvn dependency:tree</code> 观察谁胜出</li><li>修改 <code>scope</code> 为 test，演示构建产物中是否包含</li><li>用 exclusions 排除一个传递依赖，看效果</li><li>演示切换中央仓库 → 私服仓库的 settings 配置行为</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> java </category>
          
          <category> 框架 </category>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>win10系统换成Ubuntu系统</title>
      <link href="/2025/03/28/%E6%8A%80%E6%9C%AF/%E8%BF%90%E7%BB%B4/Linux/Maven%20%E6%8F%92%E4%BB%B6%E7%AE%80%E4%BB%8B/"/>
      <url>/2025/03/28/%E6%8A%80%E6%9C%AF/%E8%BF%90%E7%BB%B4/Linux/Maven%20%E6%8F%92%E4%BB%B6%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我有一台安装了win10的电脑主机闲置，想将其换成Ubuntu系统，作为服务器使用</p><h2 id="mac下制作Ubuntu系统USB启动盘"><a href="#mac下制作Ubuntu系统USB启动盘" class="headerlink" title="mac下制作Ubuntu系统USB启动盘"></a>mac下制作Ubuntu系统USB启动盘</h2><p>准备一个U盘<br>下载Ubuntu镜像，官网下载很慢可以上阿里云华为等国内镜像网站下载<br>macos安装balenaEtcher Mac版<br><img src="https://cdn.jsdelivr.net/gh/neoisok/assets@main/images%2F2025%2F03%2F28%2F20250328215415372-780d5dbfe84e070fb561afe86c796b35.png"><br>选择镜像-&gt;选择U盘-&gt;开始烧录<br><img src="https://cdn.jsdelivr.net/gh/neoisok/assets@main/images%2F2025%2F03%2F28%2F20250328220141061-94e5ed6cbbbfa9bba49fa2aadfdcd704.png"><br><img src="https://cdn.jsdelivr.net/gh/neoisok/assets@main/images%2F2025%2F03%2F28%2F20250328220141061-94e5ed6cbbbfa9bba49fa2aadfdcd704.png" width=600px></p><h2 id="安装Ubuntu系统"><a href="#安装Ubuntu系统" class="headerlink" title="安装Ubuntu系统"></a>安装Ubuntu系统</h2><p>插入U盘重启win10系统，intel nuc 按F10 选择U盘为启动盘<br>选择安装Ubuntu系统<br>选择最小化安装 minimized</p><h2 id="配置ssh和代理"><a href="#配置ssh和代理" class="headerlink" title="配置ssh和代理"></a>配置ssh和代理</h2><p>固定ip并且</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 运维 </category>
          
          <category> Ubuntu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven项目构建生命周期</title>
      <link href="/2025/03/28/%E6%8A%80%E6%9C%AF/java/%E6%A1%86%E6%9E%B6/Maven/Maven%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2025/03/28/%E6%8A%80%E6%9C%AF/java/%E6%A1%86%E6%9E%B6/Maven/Maven%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="Maven-项目构建生命周期（Build-Lifecycle）"><a href="#Maven-项目构建生命周期（Build-Lifecycle）" class="headerlink" title="Maven 项目构建生命周期（Build Lifecycle）"></a>Maven 项目构建生命周期（Build Lifecycle）</h2><hr><h3 id="一、什么是生命周期（Lifecycle）？"><a href="#一、什么是生命周期（Lifecycle）？" class="headerlink" title="一、什么是生命周期（Lifecycle）？"></a>一、什么是生命周期（Lifecycle）？</h3><blockquote><p>生命周期是 Maven 的核心机制之一，定义了 <strong>项目从清理到打包再到部署的全过程</strong>，是由一系列有序的构建阶段（Phase）组成的。</p></blockquote><p>简单理解就是：你运行一个 Maven 命令，比如 <code>mvn install</code>，Maven 会自动按照一个预定义的顺序，执行从编译、测试、打包到安装的所有阶段。</p><hr><h3 id="二、Maven-的三大内置生命周期"><a href="#二、Maven-的三大内置生命周期" class="headerlink" title="二、Maven 的三大内置生命周期"></a>二、Maven 的三大内置生命周期</h3><table><thead><tr><th>生命周期名称</th><th>作用说明</th></tr></thead><tbody><tr><td><strong>default</strong>（默认生命周期）</td><td>项目的编译、测试、打包、部署等</td></tr><tr><td><strong>clean</strong></td><td>清理项目（删除之前构建的产物）</td></tr><tr><td><strong>site</strong></td><td>生成项目文档、报告等</td></tr></tbody></table><hr><h3 id="三、默认生命周期（default-lifecycle）"><a href="#三、默认生命周期（default-lifecycle）" class="headerlink" title="三、默认生命周期（default lifecycle）"></a>三、默认生命周期（default lifecycle）</h3><p>Maven 的构建流程由多个“阶段”（Phase）组成，这些阶段是<strong>有顺序的</strong>，执行其中一个阶段会连带执行之前的所有阶段。</p><h4 id="主要构建阶段如下："><a href="#主要构建阶段如下：" class="headerlink" title="主要构建阶段如下："></a>主要构建阶段如下：</h4><table><thead><tr><th>阶段名（Phase）</th><th>功能说明</th></tr></thead><tbody><tr><td><strong>validate</strong></td><td>验证项目是否正确，例如目录结构、必要信息是否完整</td></tr><tr><td><strong>compile</strong></td><td>编译主源码（src&#x2F;main&#x2F;java）</td></tr><tr><td><strong>test</strong></td><td>编译并运行单元测试（src&#x2F;test&#x2F;java）</td></tr><tr><td><strong>package</strong></td><td>打包编译后的代码（如 jar&#x2F;war）</td></tr><tr><td><strong>verify</strong></td><td>运行集成测试，验证包是否有效</td></tr><tr><td><strong>install</strong></td><td>安装到本地 Maven 仓库，供本机其他项目使用</td></tr><tr><td><strong>deploy</strong></td><td>发布到远程仓库，供团队共享使用（通常结合 CI&#x2F;CD）</td></tr></tbody></table><blockquote><p>📝 示例：<code>mvn install</code> 会依次执行：<code>validate → compile → test → package → verify → install</code></p></blockquote><hr><h3 id="四、clean-生命周期"><a href="#四、clean-生命周期" class="headerlink" title="四、clean 生命周期"></a>四、clean 生命周期</h3><p>用于清理之前构建的文件，主要阶段：</p><table><thead><tr><th>阶段</th><th>说明</th></tr></thead><tbody><tr><td><strong>pre-clean</strong></td><td>清理前的准备工作（插件扩展用）</td></tr><tr><td><strong>clean</strong></td><td>删除 <code>target/</code> 目录（编译产物）</td></tr><tr><td><strong>post-clean</strong></td><td>清理后的收尾操作</td></tr></tbody></table><blockquote><p>常用命令：<code>mvn clean</code> — 清理旧文件，避免构建污染。</p></blockquote><hr><h3 id="五、site-生命周期（可选模块）"><a href="#五、site-生命周期（可选模块）" class="headerlink" title="五、site 生命周期（可选模块）"></a>五、site 生命周期（可选模块）</h3><p>用于生成项目站点文档（文档网站、测试覆盖率、依赖报告等）：</p><table><thead><tr><th>阶段</th><th>说明</th></tr></thead><tbody><tr><td><strong>pre-site</strong></td><td>准备生成站点</td></tr><tr><td><strong>site</strong></td><td>生成文档网站</td></tr><tr><td><strong>post-site</strong></td><td>站点生成后的处理</td></tr><tr><td><strong>site-deploy</strong></td><td>部署站点到服务器</td></tr></tbody></table><hr><h3 id="六、生命周期、阶段与插件三者关系"><a href="#六、生命周期、阶段与插件三者关系" class="headerlink" title="六、生命周期、阶段与插件三者关系"></a>六、生命周期、阶段与插件三者关系</h3><p>生命周期 ≠ 阶段 ≠ 插件<br>Maven 实际上只是框架，<strong>真正执行工作的都是插件</strong>。</p><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean</span><br></pre></td></tr></table></figure><p>执行的是 <code>clean</code> 生命周期的 <code>clean</code> 阶段，具体操作由 <code>maven-clean-plugin</code> 实现。</p><p>下面是对**“六、生命周期、阶段与插件三者关系”<strong>的</strong>详细讲解**，包括概念区分、调用机制、示例分析、常见误区等</p><hr><h4 id="1️⃣-三者核心定义"><a href="#1️⃣-三者核心定义" class="headerlink" title="1️⃣ 三者核心定义"></a>1️⃣ 三者核心定义</h4><table><thead><tr><th>概念</th><th>定义</th><th>举例</th></tr></thead><tbody><tr><td><strong>生命周期</strong>（Lifecycle）</td><td>一组预定义的构建阶段，用于组织项目构建过程</td><td><code>default</code>、<code>clean</code>、<code>site</code></td></tr><tr><td><strong>阶段</strong>（Phase）</td><td>生命周期中的一个构建步骤，会被按顺序执行</td><td><code>compile</code>、<code>test</code>、<code>package</code>、<code>install</code> 等</td></tr><tr><td><strong>插件</strong>（Plugin）</td><td>执行具体构建行为的工具，是 Maven 的扩展机制</td><td><code>maven-compiler-plugin</code>、<code>maven-surefire-plugin</code> 等</td></tr></tbody></table><p>➡️ <strong>阶段是生命周期的一部分，插件是实际干活的角色。</strong></p><hr><h4 id="2️⃣-三者调用关系：你执行阶段，Maven调用插件"><a href="#2️⃣-三者调用关系：你执行阶段，Maven调用插件" class="headerlink" title="2️⃣ 三者调用关系：你执行阶段，Maven调用插件"></a>2️⃣ 三者调用关系：<strong>你执行阶段，Maven调用插件</strong></h4><p>比如执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn package</span><br></pre></td></tr></table></figure><ul><li>触发的是 <code>default</code> 生命周期中的 <code>package</code> 阶段</li><li>Maven 会找该阶段默认绑定的插件和目标（goal）</li><li>执行 <code>maven-jar-plugin:jar</code> 来打包生成 <code>.jar</code> 文件</li></ul><hr><h4 id="3️⃣-插件中的目标（Goal）"><a href="#3️⃣-插件中的目标（Goal）" class="headerlink" title="3️⃣ 插件中的目标（Goal）"></a>3️⃣ 插件中的目标（Goal）</h4><p>每个插件有一个或多个 <strong>目标（goal）</strong>，是插件中的具体任务单位。</p><p>例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">phase</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>表示：在 <code>compile</code> 阶段执行 <code>maven-compiler-plugin</code> 插件的 <code>compile</code> 目标。</p><hr><h4 id="4️⃣-阶段与插件绑定关系（默认）"><a href="#4️⃣-阶段与插件绑定关系（默认）" class="headerlink" title="4️⃣ 阶段与插件绑定关系（默认）"></a>4️⃣ 阶段与插件绑定关系（默认）</h4><table><thead><tr><th>阶段（Phase）</th><th>默认绑定插件及目标（Goal）</th></tr></thead><tbody><tr><td>compile</td><td><code>maven-compiler-plugin:compile</code></td></tr><tr><td>test</td><td><code>maven-surefire-plugin:test</code></td></tr><tr><td>package</td><td><code>maven-jar-plugin:jar</code> &#x2F; <code>maven-war-plugin:war</code></td></tr><tr><td>install</td><td><code>maven-install-plugin:install</code></td></tr><tr><td>deploy</td><td><code>maven-deploy-plugin:deploy</code></td></tr></tbody></table><p>这些绑定都是<strong>默认绑定</strong>，也可以在 POM 中自定义绑定其他插件或替换默认插件。</p><hr><h4 id="5️⃣-可视化总结关系图："><a href="#5️⃣-可视化总结关系图：" class="headerlink" title="5️⃣ 可视化总结关系图："></a>5️⃣ 可视化总结关系图：</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[生命周期 Lifecycle]</span><br><span class="line">         ↓</span><br><span class="line"> ┌──────────────┐</span><br><span class="line"> │    阶段 Phase   │ → 按顺序执行（compile → test → package）</span><br><span class="line"> └──────────────┘</span><br><span class="line">         ↓</span><br><span class="line">[插件 Plugin + 目标 Goal]  ← 真正执行具体操作</span><br></pre></td></tr></table></figure><hr><h4 id="6️⃣-常见误区澄清"><a href="#6️⃣-常见误区澄清" class="headerlink" title="6️⃣ 常见误区澄清"></a>6️⃣ 常见误区澄清</h4><table><thead><tr><th>误区</th><th>正确认知</th></tr></thead><tbody><tr><td>以为 <code>mvn compile</code> 是插件命令</td><td>❌ 不是插件，而是执行“阶段”</td></tr><tr><td>插件必须写在 POM 里才执行</td><td>❌ 有默认插件绑定，非必须</td></tr><tr><td>执行某阶段只执行该阶段</td><td>❌ 会连带执行前面所有阶段</td></tr></tbody></table><hr><h4 id="7️⃣-实践建议：查看阶段与插件绑定关系"><a href="#7️⃣-实践建议：查看阶段与插件绑定关系" class="headerlink" title="7️⃣ 实践建议：查看阶段与插件绑定关系"></a>7️⃣ 实践建议：查看阶段与插件绑定关系</h4><p>你可以通过以下命令查看完整的生命周期绑定：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn <span class="built_in">help</span>:describe -Dcmd=compile</span><br></pre></td></tr></table></figure><p>或查看某个插件目标的详细信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn <span class="built_in">help</span>:describe -Dplugin=compiler -Dfull</span><br></pre></td></tr></table></figure><hr><h3 id="七、常用构建命令速查表"><a href="#七、常用构建命令速查表" class="headerlink" title="七、常用构建命令速查表"></a>七、常用构建命令速查表</h3><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td><code>mvn clean</code></td><td>清理项目</td></tr><tr><td><code>mvn compile</code></td><td>编译源代码</td></tr><tr><td><code>mvn test</code></td><td>执行单元测试</td></tr><tr><td><code>mvn package</code></td><td>打包</td></tr><tr><td><code>mvn install</code></td><td>安装到本地仓库</td></tr><tr><td><code>mvn deploy</code></td><td>发布到远程仓库</td></tr></tbody></table><hr>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> java </category>
          
          <category> 框架 </category>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven 插件简介</title>
      <link href="/2025/03/28/%E6%8A%80%E6%9C%AF/java/%E6%A1%86%E6%9E%B6/Maven/Maven%20%E6%8F%92%E4%BB%B6%E7%AE%80%E4%BB%8B/"/>
      <url>/2025/03/28/%E6%8A%80%E6%9C%AF/java/%E6%A1%86%E6%9E%B6/Maven/Maven%20%E6%8F%92%E4%BB%B6%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="插件执行时机"><a href="#插件执行时机" class="headerlink" title="插件执行时机"></a>插件执行时机</h1><blockquote><p>插件是怎么被“触发执行”的？需要什么条件？执行时机是什么？</p></blockquote><h2 id="🔑-一、插件的两种执行方式"><a href="#🔑-一、插件的两种执行方式" class="headerlink" title="🔑 一、插件的两种执行方式"></a>🔑 一、插件的两种执行方式</h2><h3 id="✅-方式一：命令行直接调用插件目标（goal）"><a href="#✅-方式一：命令行直接调用插件目标（goal）" class="headerlink" title="✅ 方式一：命令行直接调用插件目标（goal）"></a>✅ 方式一：<strong>命令行直接调用插件目标（goal）</strong></h3><p>你手动执行插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mvn [plugin-name]:[goal-name]</span><br><span class="line">mvn <span class="built_in">exec</span>:java -Dexec.mainClass=com.example.Main</span><br><span class="line">mvn antrun:run</span><br><span class="line">mvn myplugin:mygoal</span><br></pre></td></tr></table></figure><blockquote><p>这种方式叫做：<strong>直接调用目标（Direct goal invocation）</strong></p></blockquote><p>插件在命令执行时立即触发，仅执行该插件目标，不涉及生命周期。</p><hr><h3 id="✅-方式二：插件绑定到生命周期阶段自动执行"><a href="#✅-方式二：插件绑定到生命周期阶段自动执行" class="headerlink" title="✅ 方式二：插件绑定到生命周期阶段自动执行"></a>✅ 方式二：<strong>插件绑定到生命周期阶段自动执行</strong></h3><p>你执行生命周期命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mvn compile</span><br><span class="line">mvn package</span><br><span class="line">mvn install</span><br></pre></td></tr></table></figure><blockquote><p>Maven 会自动执行 <strong>绑定到这些阶段的插件目标</strong></p></blockquote><h4 id="举个例子："><a href="#举个例子：" class="headerlink" title="举个例子："></a>举个例子：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn package</span><br></pre></td></tr></table></figure><p>Maven 会自动执行这些阶段（生命周期）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">validate → compile → test → package</span><br></pre></td></tr></table></figure><p>而每个阶段都有绑定的插件目标，例如：</p><table><thead><tr><th>阶段</th><th>执行插件</th><th>执行目标</th></tr></thead><tbody><tr><td><code>compile</code></td><td><code>maven-compiler-plugin</code></td><td><code>compile</code></td></tr><tr><td><code>test</code></td><td><code>maven-surefire-plugin</code></td><td><code>test</code></td></tr><tr><td><code>package</code></td><td><code>maven-jar-plugin</code>（或 war）</td><td><code>jar</code> &#x2F; <code>war</code></td></tr></tbody></table><p>这些插件是在<strong>执行阶段时自动被触发的</strong>。</p><hr><h2 id="🧱-二、插件执行条件一览表"><a href="#🧱-二、插件执行条件一览表" class="headerlink" title="🧱 二、插件执行条件一览表"></a>🧱 二、插件执行条件一览表</h2><table><thead><tr><th>插件配置方式</th><th>插件何时执行？</th><th>举例</th></tr></thead><tbody><tr><td>未绑定生命周期、命令行直接调用</td><td>只有你手动执行时才会运行</td><td><code>mvn exec:java</code></td></tr><tr><td>默认绑定（生命周期绑定了默认插件）</td><td>执行生命周期阶段命令时自动执行</td><td><code>mvn compile</code> 会调用 <code>maven-compiler-plugin</code></td></tr><tr><td>自定义绑定（通过 <code>&lt;executions&gt;</code> 配置）</td><td>绑定的阶段触发时执行该插件</td><td><code>mvn package</code> 会触发你绑定到 package 的插件</td></tr><tr><td>没有绑定也没有调用</td><td>永远不会执行</td><td>插件写了但没人用</td></tr></tbody></table><hr><ol><li>配置一个 <code>antrun</code> 插件，不绑定生命周期</li><li>执行 <code>mvn compile</code> → 不会执行插件</li><li>改成绑定到 <code>compile</code> 阶段</li><li>再执行 <code>mvn compile</code> → 插件被自动执行！</li></ol><hr><h1 id="插件分类"><a href="#插件分类" class="headerlink" title="插件分类"></a>插件分类</h1><h2 id="🧩-一、从功能维度分：Maven-插件的两大类"><a href="#🧩-一、从功能维度分：Maven-插件的两大类" class="headerlink" title="🧩 一、从功能维度分：Maven 插件的两大类"></a>🧩 一、从功能维度分：Maven 插件的两大类</h2><table><thead><tr><th>分类</th><th>配置位置</th><th>何时执行</th><th>说明</th></tr></thead><tbody><tr><td><strong>构建插件（Build Plugins）</strong></td><td><code>&lt;build&gt;&lt;plugins&gt;</code></td><td>构建时执行（compile、test、package 等）</td><td>参与生命周期流程</td></tr><tr><td><strong>报告插件（Reporting Plugins）</strong></td><td><code>&lt;reporting&gt;</code></td><td>执行 <code>mvn site</code> 时执行</td><td>生成项目文档和报告</td></tr></tbody></table><hr><h3 id="✅-构建插件（Build-Plugin）"><a href="#✅-构建插件（Build-Plugin）" class="headerlink" title="✅ 构建插件（Build Plugin）"></a>✅ 构建插件（Build Plugin）</h3><ul><li>执行时机：构建生命周期中，如 <code>mvn compile</code>、<code>mvn test</code>、<code>mvn package</code></li><li>配置位置：<code>&lt;build&gt;&lt;plugins&gt;</code></li><li>可通过 <code>&lt;executions&gt;</code> 绑定生命周期阶段</li><li>可以通过命令行手动调用目标（如 <code>mvn exec:java</code>）</li></ul><p>📌 示例插件：</p><table><thead><tr><th>插件</th><th>功能</th></tr></thead><tbody><tr><td><code>maven-compiler-plugin</code></td><td>编译 Java 代码</td></tr><tr><td><code>maven-surefire-plugin</code></td><td>运行单元测试</td></tr><tr><td><code>maven-jar-plugin</code> &#x2F; <code>maven-war-plugin</code></td><td>打包成 jar&#x2F;war</td></tr><tr><td><code>exec-maven-plugin</code></td><td>运行 Java 程序</td></tr><tr><td><code>maven-deploy-plugin</code></td><td>发布构建产物到远程仓库</td></tr></tbody></table><hr><h3 id="✅-报告插件（Reporting-Plugin）"><a href="#✅-报告插件（Reporting-Plugin）" class="headerlink" title="✅ 报告插件（Reporting Plugin）"></a>✅ 报告插件（Reporting Plugin）</h3><ul><li>执行时机：<code>mvn site</code> 执行时</li><li>配置位置：<code>&lt;reporting&gt;</code> 标签下</li><li>主要用于生成站点报告（依赖树、测试覆盖率、项目信息等）</li></ul><p>📌 示例插件：</p><table><thead><tr><th>插件</th><th>功能</th></tr></thead><tbody><tr><td><code>maven-project-info-reports-plugin</code></td><td>生成项目信息报告（依赖树、开发者、许可证等）</td></tr><tr><td><code>maven-surefire-report-plugin</code></td><td>测试报告</td></tr><tr><td><code>maven-javadoc-plugin</code></td><td>JavaDoc API 文档</td></tr><tr><td><code>maven-pmd-plugin</code></td><td>代码质量检查报告</td></tr></tbody></table><blockquote><p>注意：如果你用命令行执行报告插件的某个目标（如 <code>mvn javadoc:javadoc</code>），它不会使用 <code>&lt;reporting&gt;</code> 中的配置，而是使用 <code>&lt;build&gt;</code> 中的。</p></blockquote><hr><h2 id="🧠-二、从触发方式维度分：Maven-插件的执行分类"><a href="#🧠-二、从触发方式维度分：Maven-插件的执行分类" class="headerlink" title="🧠 二、从触发方式维度分：Maven 插件的执行分类"></a>🧠 二、从触发方式维度分：Maven 插件的执行分类</h2><table><thead><tr><th>类别</th><th>特点</th><th>触发方式</th><th>示例</th></tr></thead><tbody><tr><td><strong>生命周期绑定插件</strong></td><td>被绑定到某个阶段自动执行</td><td><code>mvn compile</code> <code>mvn package</code></td><td><code>maven-compiler-plugin</code>, <code>maven-surefire-plugin</code></td></tr><tr><td><strong>手动调用插件</strong></td><td>只能通过命令行手动调用目标</td><td><code>mvn dependency:tree</code></td><td><code>maven-dependency-plugin</code>, <code>exec-maven-plugin</code></td></tr><tr><td><strong>报告生成插件</strong></td><td>用于生成 HTML 报告</td><td><code>mvn site</code></td><td><code>maven-project-info-reports-plugin</code></td></tr></tbody></table><hr><h2 id="🔍-三、特殊分类（按功能细分）"><a href="#🔍-三、特殊分类（按功能细分）" class="headerlink" title="🔍 三、特殊分类（按功能细分）"></a>🔍 三、特殊分类（按功能细分）</h2><h3 id="🔨-编译与打包类"><a href="#🔨-编译与打包类" class="headerlink" title="🔨 编译与打包类"></a>🔨 编译与打包类</h3><ul><li><code>maven-compiler-plugin</code></li><li><code>maven-jar-plugin</code></li><li><code>maven-war-plugin</code></li><li><code>maven-assembly-plugin</code></li><li><code>maven-shade-plugin</code></li></ul><h3 id="🧪-测试类"><a href="#🧪-测试类" class="headerlink" title="🧪 测试类"></a>🧪 测试类</h3><ul><li><code>maven-surefire-plugin</code>（单元测试）</li><li><code>maven-failsafe-plugin</code>（集成测试）</li></ul><h3 id="📦-发布与依赖管理类"><a href="#📦-发布与依赖管理类" class="headerlink" title="📦 发布与依赖管理类"></a>📦 发布与依赖管理类</h3><ul><li><code>maven-install-plugin</code></li><li><code>maven-deploy-plugin</code></li><li><code>maven-dependency-plugin</code></li></ul><h3 id="📊-报告与文档类"><a href="#📊-报告与文档类" class="headerlink" title="📊 报告与文档类"></a>📊 报告与文档类</h3><ul><li><code>maven-javadoc-plugin</code></li><li><code>maven-site-plugin</code></li><li><code>maven-pmd-plugin</code></li><li><code>maven-checkstyle-plugin</code></li></ul><h3 id="🛠️-运行执行类"><a href="#🛠️-运行执行类" class="headerlink" title="🛠️ 运行执行类"></a>🛠️ 运行执行类</h3><ul><li><code>exec-maven-plugin</code></li><li><code>antrun-maven-plugin</code></li></ul><hr><h2 id="✅-总结一句话："><a href="#✅-总结一句话：" class="headerlink" title="✅ 总结一句话："></a>✅ 总结一句话：</h2><blockquote><p>Maven 插件从大的方向分为：</p><ul><li><strong>构建插件</strong>（参与 lifecycle）</li><li><strong>报告插件</strong>（参与 site 报告）</li></ul><p>然后又可以按功能细分为：编译、测试、打包、文档、发布、执行类等。</p></blockquote><hr><h1 id="插件CLI执行"><a href="#插件CLI执行" class="headerlink" title="插件CLI执行"></a>插件CLI执行</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mvn [plugin-prefix]:[goal]</span><br><span class="line">mvn javadoc:javadoc </span><br></pre></td></tr></table></figure><p>它的结构是：</p><table><thead><tr><th>部分</th><th>含义</th></tr></thead><tbody><tr><td><code>javadoc</code>（前半）</td><td>插件前缀（plugin prefix）</td></tr><tr><td><code>javadoc</code>（后半）</td><td>插件目标（goal）</td></tr></tbody></table><p>javadoc 这个前缀，是 Maven 根据 插件的 artifactId 映射的默认前缀<br>实际使用的插件是：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-javadoc-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br></pre></td></tr></table></figure><p>你没有写 <code>maven-javadoc-plugin:javadoc</code>，但 Maven 会自动通过前缀 <code>javadoc</code> 去找这个插件。</p><h2 id="🔍-Maven-是怎么知道-javadoc-前缀对应哪个插件的？"><a href="#🔍-Maven-是怎么知道-javadoc-前缀对应哪个插件的？" class="headerlink" title="🔍 Maven 是怎么知道 javadoc 前缀对应哪个插件的？"></a>🔍 Maven 是怎么知道 <code>javadoc</code> 前缀对应哪个插件的？</h2><p>它查的是插件 <code>META-INF/maven/plugin.xml</code> 中的 <code>&lt;goalPrefix&gt;</code> 字段。</p><p>比如 <code>maven-javadoc-plugin</code> 插件里就定义了：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">goalPrefix</span>&gt;</span>javadoc<span class="tag">&lt;/<span class="name">goalPrefix</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所以你才能用 <code>mvn javadoc:javadoc</code> 简写命令。</p><hr><h2 id="✅-怎么确认某个前缀对应哪个插件？"><a href="#✅-怎么确认某个前缀对应哪个插件？" class="headerlink" title="✅ 怎么确认某个前缀对应哪个插件？"></a>✅ 怎么确认某个前缀对应哪个插件？</h2><p>使用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn <span class="built_in">help</span>:describe -Dplugin=javadoc</span><br></pre></td></tr></table></figure><p>输出中你会看到：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Name: Maven Javadoc Plugin</span><br><span class="line">Prefix: javadoc</span><br><span class="line">Group Id: org.apache.maven.plugins</span><br><span class="line">Artifact Id: maven-javadoc-plugin</span><br><span class="line">Version: ...</span><br></pre></td></tr></table></figure><hr><h1 id="查询插件详细信息"><a href="#查询插件详细信息" class="headerlink" title="查询插件详细信息"></a>查询插件详细信息</h1><p>当需要查询某个插件的信息时候执行，执行完会输出一堆信息代表什么意思呢<br>mvn help:describe -Dplugin&#x3D;javadoc</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">(base) ➜  ~ mvn help:describe -Dplugin=javadoc</span><br><span class="line"></span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] ------------------&lt; org.apache.maven:standalone-pom &gt;-------------------</span><br><span class="line">[INFO] Building Maven Stub Project (No POM) 1</span><br><span class="line">[INFO] --------------------------------[ pom ]---------------------------------</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- help:3.5.1:describe (default-cli) @ standalone-pom ---</span><br><span class="line">Downloading from central: https://repo.maven.apache.org/maven2/org/apache/maven/plugins/maven-javadoc-plugin/maven-metadata.xml</span><br><span class="line">Downloaded from central: https://repo.maven.apache.org/maven2/org/apache/maven/plugins/maven-javadoc-plugin/maven-metadata.xml (1.6 kB at 4.7 kB/s)</span><br><span class="line">Downloading from central: https://repo.maven.apache.org/maven2/org/apache/maven/plugins/maven-javadoc-plugin/3.11.2/maven-javadoc-plugin-3.11.2.pom</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line">Name: Apache Maven Javadoc Plugin</span><br><span class="line">Description: The Apache Maven Javadoc Plugin is a plugin that uses the</span><br><span class="line">  javadoc tool for generating javadocs for the specified project.</span><br><span class="line">Group Id: org.apache.maven.plugins</span><br><span class="line">Artifact Id: maven-javadoc-plugin</span><br><span class="line">Version: 3.11.2</span><br><span class="line">Goal Prefix: javadoc</span><br><span class="line"></span><br><span class="line">This plugin has 17 goals:</span><br><span class="line"></span><br><span class="line">javadoc:aggregate</span><br><span class="line">  Description: Generates documentation for the Java code in an aggregator</span><br><span class="line">    project using the standard Javadoc Tool . Since version 3.1.0 an aggregated</span><br><span class="line">    report is created for every module of a Maven multimodule project.</span><br><span class="line">  Note: This goal should be used as a Maven report.</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">For more information, run &#x27;mvn help:describe [...] -Ddetail&#x27;</span><br><span class="line"></span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  7.184 s</span><br><span class="line">[INFO] Finished at: 2025-03-28T10:25:41+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><hr><h2 id="🔍-一、Scanning-for-projects-是在干嘛？"><a href="#🔍-一、Scanning-for-projects-是在干嘛？" class="headerlink" title="🔍 一、Scanning for projects... 是在干嘛？"></a>🔍 一、<code>Scanning for projects...</code> 是在干嘛？</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[INFO] Scanning for projects...</span><br></pre></td></tr></table></figure><p>这是 Maven 的标准启动流程中的第一步，它会：</p><h3 id="✅-尝试在当前目录下查找是否存在一个-Maven-项目"><a href="#✅-尝试在当前目录下查找是否存在一个-Maven-项目" class="headerlink" title="✅ 尝试在当前目录下查找是否存在一个 Maven 项目"></a>✅ 尝试在<strong>当前目录下</strong>查找是否存在一个 Maven 项目</h3><ul><li>它会扫描当前目录及其父目录，看有没有 <code>pom.xml</code></li><li>如果没有，就会创建一个 <strong>默认的占位项目（Stub Project）</strong>，这个项目是虚拟的，不写磁盘，不留痕迹，不用删除。输出你看到的：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[INFO] Building Maven Stub Project (No POM) 1</span><br></pre></td></tr></table></figure><p>📌 你当前目录下<strong>没有 <code>pom.xml</code></strong>，所以 Maven就自动构造了一个“空项目”来执行你的 <code>help</code> 命令。</p><hr><h2 id="📦-二、为什么要从中央仓库下载插件？"><a href="#📦-二、为什么要从中央仓库下载插件？" class="headerlink" title="📦 二、为什么要从中央仓库下载插件？"></a>📦 二、为什么要从中央仓库下载插件？</h2><p>你执行的命令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn <span class="built_in">help</span>:describe -Dplugin=javadoc</span><br></pre></td></tr></table></figure><p>这条命令的含义是：</p><blockquote><p>👉 请告诉我 <strong>前缀为 <code>javadoc</code></strong> 的插件信息（如它绑定的目标、支持的参数等）</p></blockquote><h3 id="🔽-于是-Maven-要做什么？"><a href="#🔽-于是-Maven-要做什么？" class="headerlink" title="🔽 于是 Maven 要做什么？"></a>🔽 于是 Maven 要做什么？</h3><ol><li>先查你本地仓库（<code>~/.m2/repository</code>）有没有 <code>maven-javadoc-plugin</code></li><li>没有找到或版本不完整，就会去 <strong>中央仓库</strong> 下载</li><li>下载的是：</li></ol><table><thead><tr><th>下载内容</th><th>作用</th></tr></thead><tbody><tr><td><code>maven-metadata.xml</code></td><td>获取该插件的可用版本列表</td></tr><tr><td><code>maven-javadoc-plugin-3.11.2.pom</code></td><td>获取插件描述文件，包括 <code>&lt;goalPrefix&gt;</code></td></tr><tr><td><code>plugin.xml</code>（在 jar 包内）</td><td>提供目标、参数等详细信息，Maven 会读取它生成 describe 输出</td></tr></tbody></table><hr><h2 id="📂-三、下载的这些文件保存到哪里？"><a href="#📂-三、下载的这些文件保存到哪里？" class="headerlink" title="📂 三、下载的这些文件保存到哪里？"></a>📂 三、下载的这些文件保存到哪里？</h2><p>下载到你本地的 Maven 仓库路径：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.m2/repository/org/apache/maven/plugins/maven-javadoc-plugin/3.11.2/</span><br></pre></td></tr></table></figure><p>你可以直接去这个路径下看到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">maven-javadoc-plugin-3.11.2.jar</span><br><span class="line">maven-javadoc-plugin-3.11.2.pom</span><br></pre></td></tr></table></figure><hr><h2 id="✅-四、补充说明：即使你只是查个帮助，它也需要插件本体"><a href="#✅-四、补充说明：即使你只是查个帮助，它也需要插件本体" class="headerlink" title="✅ 四、补充说明：即使你只是查个帮助，它也需要插件本体"></a>✅ 四、补充说明：即使你只是查个帮助，它也需要插件本体</h2><p>这是因为：</p><ul><li><code>help:describe</code> 命令要解析插件的 <code>plugin.xml</code>（包含所有参数说明）</li><li>这个文件在插件 jar 包中</li><li>所以必须下载插件本体</li></ul><hr><h2 id="✅-总结一句话"><a href="#✅-总结一句话" class="headerlink" title="✅ 总结一句话"></a>✅ 总结一句话</h2><blockquote><p>Maven 每次执行命令前，都会扫描当前目录查找项目（<code>pom.xml</code>）<br>如果没有，就创建临时项目继续执行<br>如果你请求插件信息，而本地没有插件，就会从中央仓库下载<br>下载内容默认存储在本地仓库：<code>~/.m2/repository</code>，下次不会重复下载</p></blockquote><hr><h2 id="🎯-问题：为什么执行-mvn-help-describe-没有构建项目，最后还显示："><a href="#🎯-问题：为什么执行-mvn-help-describe-没有构建项目，最后还显示：" class="headerlink" title="🎯 问题：为什么执行 mvn help:describe 没有构建项目，最后还显示："></a>🎯 问题：为什么执行 <code>mvn help:describe</code> 没有构建项目，最后还显示：</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[INFO] BUILD SUCCESS</span><br></pre></td></tr></table></figure><p>是不是很像你做了一件“没啥好构建”的事，结果却说“构建成功”？那这个“BUILD”到底构建了啥？</p><hr><h2 id="✅-实际上，这个-BUILD-SUCCESS-是-Maven-的通用提示语"><a href="#✅-实际上，这个-BUILD-SUCCESS-是-Maven-的通用提示语" class="headerlink" title="✅ 实际上，这个 BUILD SUCCESS 是 Maven 的通用提示语"></a>✅ 实际上，这个 <strong>BUILD SUCCESS 是 Maven 的通用提示语</strong></h2><p>无论你执行的命令是不是构建类命令（如 <code>compile</code>、<code>package</code>），Maven 在整个流程顺利完成时，都会统一输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[INFO] BUILD SUCCESS</span><br></pre></td></tr></table></figure><p>它的含义其实更接近于：</p><blockquote><p>🟢 “这条 Maven 命令执行成功，没有错误发生。”</p></blockquote><p>并不代表你“真的构建了一个项目”或“打了个包”。</p><hr><h2 id="🧠-举个例子帮助你理解："><a href="#🧠-举个例子帮助你理解：" class="headerlink" title="🧠 举个例子帮助你理解："></a>🧠 举个例子帮助你理解：</h2><table><thead><tr><th>执行命令</th><th>实际干的事</th><th>是否输出 BUILD SUCCESS</th></tr></thead><tbody><tr><td><code>mvn compile</code></td><td>编译项目代码</td><td>✅</td></tr><tr><td><code>mvn package</code></td><td>打包成 jar&#x2F;war</td><td>✅</td></tr><tr><td><code>mvn help:describe -Dplugin=compiler</code></td><td>查询插件信息</td><td>✅</td></tr><tr><td><code>mvn dependency:tree</code></td><td>打印依赖树</td><td>✅</td></tr><tr><td><code>mvn clean</code></td><td>删除 <code>target</code> 目录</td><td>✅</td></tr></tbody></table><p>只要命令执行<strong>没有报错、退出码为 0</strong>，就会显示 <code>BUILD SUCCESS</code>。</p><hr><h2 id="🛠️-那如果出错会看到什么？"><a href="#🛠️-那如果出错会看到什么？" class="headerlink" title="🛠️ 那如果出错会看到什么？"></a>🛠️ 那如果出错会看到什么？</h2><p>比如拼错插件名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn foo:bar</span><br></pre></td></tr></table></figure><p>你会看到：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ERROR] No plugin found for prefix &#x27;foo&#x27;...</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD FAILURE</span><br></pre></td></tr></table></figure><hr><blockquote><p><code>BUILD SUCCESS</code> ≠ 真正构建了项目，而是表示：<strong>Maven 本次命令流程执行成功，没出错。</strong></p></blockquote><hr><h1 id="🧰-mvn-help-describe-常用命令速查"><a href="#🧰-mvn-help-describe-常用命令速查" class="headerlink" title="🧰 mvn help:describe 常用命令速查"></a>🧰 <code>mvn help:describe</code> 常用命令速查</h1><hr><h2 id="✅-1-查看某个插件的基本信息（不指定目标）"><a href="#✅-1-查看某个插件的基本信息（不指定目标）" class="headerlink" title="✅ 1. 查看某个插件的基本信息（不指定目标）"></a>✅ 1. 查看某个插件的基本信息（不指定目标）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn <span class="built_in">help</span>:describe -Dplugin=compiler</span><br></pre></td></tr></table></figure><p>输出内容：</p><ul><li>插件名称、前缀（prefix）</li><li>groupId &#x2F; artifactId &#x2F; version</li><li>支持的目标（goals）</li></ul><hr><h2 id="✅-2-查看插件某个目标（goal）的详细参数（常用）"><a href="#✅-2-查看插件某个目标（goal）的详细参数（常用）" class="headerlink" title="✅ 2. 查看插件某个目标（goal）的详细参数（常用）"></a>✅ 2. 查看插件某个目标（goal）的详细参数（常用）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn <span class="built_in">help</span>:describe -Dplugin=compiler -Dgoal=compile -Ddetail</span><br></pre></td></tr></table></figure><p>输出内容：</p><ul><li><code>compile</code> 目标的参数列表</li><li>参数名、类型、是否必填、默认值、配置方式（CLI or POM）</li><li>有效的表达式（如 <code>$&#123;project.build.sourceDirectory&#125;</code>）</li></ul><hr><h2 id="✅-3-查看插件使用的版本（你当前项目中实际使用的）"><a href="#✅-3-查看插件使用的版本（你当前项目中实际使用的）" class="headerlink" title="✅ 3. 查看插件使用的版本（你当前项目中实际使用的）"></a>✅ 3. 查看插件使用的版本（你当前项目中实际使用的）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn <span class="built_in">help</span>:describe -Dplugin=compiler -Ddetail</span><br></pre></td></tr></table></figure><p>Maven 会自动解析插件来自哪里，显示当前版本。</p><p>🧠 如果你没有手动指定 <code>&lt;version&gt;</code>，它也会显示默认使用的版本（来自超级 POM 或 pluginManagement）</p><hr><h2 id="✅-4-查某个插件命令的完整结构"><a href="#✅-4-查某个插件命令的完整结构" class="headerlink" title="✅ 4. 查某个插件命令的完整结构"></a>✅ 4. 查某个插件命令的完整结构</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn <span class="built_in">help</span>:describe -Dplugin=<span class="built_in">exec</span> -Dgoal=java -Ddetail</span><br></pre></td></tr></table></figure><p>可以看到 <code>exec:java</code> 的所有支持参数，比如 <code>mainClass</code>、<code>arguments</code> 等，非常适合调试 CLI 运行问题。</p><hr><h2 id="✅-5-查命令背后的插件是谁（前缀映射）"><a href="#✅-5-查命令背后的插件是谁（前缀映射）" class="headerlink" title="✅ 5. 查命令背后的插件是谁（前缀映射）"></a>✅ 5. 查命令背后的插件是谁（前缀映射）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn <span class="built_in">help</span>:describe -Dplugin=javadoc</span><br></pre></td></tr></table></figure><p>输出内容包含：</p><ul><li>plugin prefix：javadoc</li><li>groupId&#x2F;artifactId：<code>org.apache.maven.plugins:maven-javadoc-plugin</code></li><li>所有目标（goals）</li></ul><p>📌 适合解释 “mvn javadoc:javadoc” 背后到底是谁在干活。</p><hr><h2 id="只知道-artifactId-时的处理技巧"><a href="#只知道-artifactId-时的处理技巧" class="headerlink" title="只知道 artifactId 时的处理技巧"></a>只知道 artifactId 时的处理技巧</h2><p>你知道它叫 <code>maven-compiler-plugin</code>，Maven 默认插件都在同一个 group 下，可以写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn <span class="built_in">help</span>:describe -Dplugin=org.apache.maven.plugins:maven-compiler-plugin</span><br></pre></td></tr></table></figure><p>🔍 输出会告诉你：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Name: Maven Compiler Plugin</span><br><span class="line">Prefix: compiler</span><br><span class="line">Group Id: org.apache.maven.plugins</span><br><span class="line">Artifact Id: maven-compiler-plugin</span><br></pre></td></tr></table></figure><p>现在你就知道它的前缀是 <code>compiler</code> 了，可以写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn <span class="built_in">help</span>:describe -Dplugin=compiler -Dgoal=compile -Ddetail</span><br></pre></td></tr></table></figure><hr><h2 id="📋-进阶技巧提示"><a href="#📋-进阶技巧提示" class="headerlink" title="📋 进阶技巧提示"></a>📋 进阶技巧提示</h2><h3 id="✅-想查询多个插件？循环执行："><a href="#✅-想查询多个插件？循环执行：" class="headerlink" title="✅ 想查询多个插件？循环执行："></a>✅ 想查询多个插件？循环执行：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> plugin <span class="keyword">in</span> compiler surefire jar site; <span class="keyword">do</span></span><br><span class="line">  mvn <span class="built_in">help</span>:describe -Dplugin=<span class="variable">$plugin</span> -Ddetail</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h3 id="✅-搭配-mvn-help-effective-pom-使用"><a href="#✅-搭配-mvn-help-effective-pom-使用" class="headerlink" title="✅ 搭配 mvn help:effective-pom 使用"></a>✅ 搭配 <code>mvn help:effective-pom</code> 使用</h3><p>先查看实际插件版本，再查该插件的参数定义。</p><hr><h2 id="🧠-总结一句话："><a href="#🧠-总结一句话：" class="headerlink" title="🧠 总结一句话："></a>🧠 总结一句话：</h2><blockquote><p><code>mvn help:describe</code> 是调试 Maven 插件的利器，能帮你：</p><ul><li>查插件来源</li><li>看支持哪些目标（goals）</li><li>每个目标支持哪些参数（含默认值、表达式）</li><li>判断插件版本是否匹配</li></ul></blockquote><hr><h1 id="mvn-命令参数的含义"><a href="#mvn-命令参数的含义" class="headerlink" title="mvn 命令参数的含义"></a>mvn 命令参数的含义</h1><h2 id="🧩-一、-D-参数到底是什么？"><a href="#🧩-一、-D-参数到底是什么？" class="headerlink" title="🧩 一、-D 参数到底是什么？"></a>🧩 一、<code>-D</code> 参数到底是什么？</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn compile -Dkey=value</span><br></pre></td></tr></table></figure><p>这个 <code>-D</code> 是 JVM 的标准参数格式，在 Maven 中：</p><blockquote><p>✅ 用于向 Maven 或插件传递<strong>系统属性（System Property）</strong></p></blockquote><p>常见用途：</p><ul><li>给插件传递参数（如 <code>-Dexec.mainClass=...</code>）</li><li>控制 profile 激活（如 <code>-Denv=prod</code>）</li><li>覆盖 POM 中的 <code>$&#123;property&#125;</code> 变量</li></ul><p>📌 例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mvn <span class="built_in">exec</span>:java -Dexec.mainClass=com.example.Main</span><br><span class="line">mvn <span class="built_in">help</span>:describe -Dplugin=compiler</span><br></pre></td></tr></table></figure><hr><h2 id="🔍-二、除了-D，Maven-命令还支持哪些参数？"><a href="#🔍-二、除了-D，Maven-命令还支持哪些参数？" class="headerlink" title="🔍 二、除了 -D，Maven 命令还支持哪些参数？"></a>🔍 二、除了 <code>-D</code>，Maven 命令还支持哪些参数？</h2><h3 id="✅-常用参数分类速查表："><a href="#✅-常用参数分类速查表：" class="headerlink" title="✅ 常用参数分类速查表："></a>✅ 常用参数分类速查表：</h3><table><thead><tr><th>参数</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td><code>-D</code></td><td>设置系统属性</td><td><code>-DskipTests=true</code></td></tr><tr><td><code>-P</code></td><td>激活 Profile</td><td><code>-Pdev</code></td></tr><tr><td><code>-pl</code></td><td>指定模块构建（multi-module 项目）</td><td><code>-pl service-a</code></td></tr><tr><td><code>-am</code></td><td>同时构建依赖模块</td><td><code>-pl web -am</code></td></tr><tr><td><code>-f</code></td><td>指定 POM 文件路径</td><td><code>-f ../some-other-pom.xml</code></td></tr><tr><td><code>-U</code></td><td>强制更新远程仓库 SNAPSHOT</td><td><code>-U</code></td></tr><tr><td><code>-X</code></td><td>打印调试日志</td><td><code>-X</code></td></tr><tr><td><code>-e</code></td><td>显示完整异常栈</td><td><code>-e</code></td></tr><tr><td><code>-B</code></td><td>批处理模式（适合脚本中使用）</td><td><code>-B</code></td></tr><tr><td><code>-q</code></td><td>静默模式（Quiet）</td><td><code>-q</code></td></tr><tr><td><code>-s</code></td><td>指定 <code>settings.xml</code> 文件</td><td><code>-s ~/.m2/mysettings.xml</code></td></tr><tr><td><code>-gs</code></td><td>指定全局 <code>settings.xml</code> 文件</td><td><code>-gs /path/to/settings.xml</code></td></tr><tr><td><code>-rf</code></td><td>从指定模块重新构建</td><td><code>-rf service-a</code></td></tr><tr><td><code>-T</code></td><td>并行构建线程数（如 <code>-T 4C</code>）</td><td><code>-T 2</code>、<code>-T 1C</code></td></tr><tr><td><code>--fail-at-end</code></td><td>构建失败后继续剩下模块</td><td>-</td></tr></tbody></table><hr><h2 id="🛠️-四、实用组合示例："><a href="#🛠️-四、实用组合示例：" class="headerlink" title="🛠️ 四、实用组合示例："></a>🛠️ 四、实用组合示例：</h2><table><thead><tr><th>目的</th><th>示例</th></tr></thead><tbody><tr><td>跳过测试打包</td><td><code>mvn clean package -DskipTests=true</code></td></tr><tr><td>运行指定 profile 的打包流程</td><td><code>mvn package -Pprod</code></td></tr><tr><td>执行 main 方法</td><td><code>mvn exec:java -Dexec.mainClass=com.example.Main</code></td></tr><tr><td>查看插件信息</td><td><code>mvn help:describe -Dplugin=compiler -Dgoal=compile -Ddetail</code></td></tr><tr><td>多模块只构建一部分</td><td><code>mvn install -pl api -am</code></td></tr><tr><td>用测试 settings 构建</td><td><code>mvn deploy -s test-settings.xml</code></td></tr></tbody></table><hr><h2 id="✅-总结"><a href="#✅-总结" class="headerlink" title="✅ 总结"></a>✅ 总结</h2><blockquote><p><code>-D</code> 是最常用的系统属性传参，但 Maven 命令支持 <strong>丰富的参数组合</strong>，你可以控制 profile、模块、线程数、输出模式等，非常适合灵活构建和调试。</p></blockquote><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><hr><h2 id="超级POM在哪个目录"><a href="#超级POM在哪个目录" class="headerlink" title="超级POM在哪个目录"></a>超级POM在哪个目录</h2><p>超级 POM 并不直接以文件形式存储在你的磁盘中。<br>它是 Maven 内部的默认资源，打包在 Maven 的核心 Jar 包里。</p><h2 id="在当前项目下执行mvn命令和在任何一个其他地方执行mvn命令有什么区别"><a href="#在当前项目下执行mvn命令和在任何一个其他地方执行mvn命令有什么区别" class="headerlink" title="在当前项目下执行mvn命令和在任何一个其他地方执行mvn命令有什么区别"></a>在当前项目下执行mvn命令和在任何一个其他地方执行mvn命令有什么区别</h2><p>✅ 在项目目录下执行 mvn 命令：<br>Maven 会读取当前目录的 pom.xml，按你的项目配置执行构建、依赖管理、插件绑定等。</p><p>✅ 在非项目目录下执行：<br>Maven 没找到 pom.xml，只能执行不依赖项目结构的命令（如 help:describe、dependency:get），否则会报错或生成一个临时的“Stub 项目”。</p><p>有 POM 就构建你的项目，没 POM 就只能玩工具命令。</p><h2 id="settings文件和超级POM和普通的POM什么关系"><a href="#settings文件和超级POM和普通的POM什么关系" class="headerlink" title="settings文件和超级POM和普通的POM什么关系"></a>settings文件和超级POM和普通的POM什么关系</h2><p>✅ settings.xml 是用户级 &#x2F; 全局配置文件<br>✅ 超级 POM 是 Maven 提供的默认项目模板<br>✅ 项目 POM 是你当前项目自己的构建定义<br>👉 真正的 Maven 构建行为，是这三者共同作用、分工明确，而且有明确的优先级关系</p><hr><h3 id="🧠-三者核心作用对比表"><a href="#🧠-三者核心作用对比表" class="headerlink" title="🧠 三者核心作用对比表"></a>🧠 三者核心作用对比表</h3><table><thead><tr><th>维度</th><th><code>settings.xml</code></th><th><strong>超级 POM</strong></th><th><strong>项目 POM (<code>pom.xml</code>)</strong></th></tr></thead><tbody><tr><td>角色</td><td>用户或环境级配置</td><td>Maven 内置默认模板</td><td>项目自定义配置</td></tr><tr><td>控制范围</td><td>仓库、代理、镜像、profile 激活等</td><td>生命周期默认配置、插件绑定、中央仓库</td><td>项目的依赖、插件、模块、构建</td></tr><tr><td>配置位置</td><td><code>~/.m2/settings.xml</code> 或 Maven 安装目录</td><td>Maven 的内部 JAR 包中</td><td>当前项目根目录</td></tr><tr><td>是否可见</td><td>✅ 可以编辑</td><td>❌ 不可直接编辑</td><td>✅ 你自己写的</td></tr><tr><td>是否必须</td><td>❌ 可选</td><td>✅ 始终存在</td><td>✅ Maven 项目的核心</td></tr><tr><td>典型用途</td><td>配置私服仓库、镜像源、激活 profile</td><td>定义默认插件行为、目录结构</td><td>声明依赖、执行目标、构建产物等</td></tr></tbody></table><hr><h3 id="🔄-三者的继承-覆盖关系（优先级）"><a href="#🔄-三者的继承-覆盖关系（优先级）" class="headerlink" title="🔄 三者的继承 &#x2F; 覆盖关系（优先级）"></a>🔄 三者的继承 &#x2F; 覆盖关系（优先级）</h3><p>Maven 的执行逻辑中，这三者有如下关系：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+</span><br><span class="line">|  settings.xml      | ← 环境控制（镜像、私服、Profile 激活）</span><br><span class="line">+--------------------+</span><br><span class="line">          ↓</span><br><span class="line">+--------------------+</span><br><span class="line">|  超级 POM          | ← 默认行为（中央仓库、默认插件绑定）</span><br><span class="line">+--------------------+</span><br><span class="line">          ↓</span><br><span class="line">+--------------------+</span><br><span class="line">|  项目 POM (你写的) | ← 构建计划、依赖声明、插件配置</span><br><span class="line">+--------------------+</span><br></pre></td></tr></table></figure><p>👉 项目 POM 可以覆盖超级 POM 的设置<br>👉 settings.xml 可以控制环境行为，但<strong>不能声明依赖</strong></p><hr><h3 id="🎯-举几个典型对比场景："><a href="#🎯-举几个典型对比场景：" class="headerlink" title="🎯 举几个典型对比场景："></a>🎯 举几个典型对比场景：</h3><table><thead><tr><th>配置项</th><th>写在哪里</th><th>说明</th></tr></thead><tbody><tr><td>使用私服 Nexus</td><td>✅ <code>settings.xml</code> → 配置 <code>&lt;mirrors&gt;</code></td><td></td></tr><tr><td>默认构建插件行为（如 jar）</td><td>🧩 超级 POM 已绑定</td><td>项目 POM 可以覆盖插件版本</td></tr><tr><td>引入某个依赖（如 Spring Boot）</td><td>✅ 项目 POM</td><td>不能写在 <code>settings.xml</code></td></tr><tr><td>使用 JDK 版本</td><td>✅ 项目 POM <code>&lt;properties&gt;</code></td><td><code>settings.xml</code> 不负责构建参数</td></tr></tbody></table><hr><h2 id="怎么看当前项目用了哪些插件？”"><a href="#怎么看当前项目用了哪些插件？”" class="headerlink" title="怎么看当前项目用了哪些插件？”"></a>怎么看当前项目用了哪些插件？”</h2><h3 id="✅-一句话速答："><a href="#✅-一句话速答：" class="headerlink" title="✅ 一句话速答："></a>✅ 一句话速答：</h3><blockquote><p>使用 <code>mvn help:effective-pom</code> 命令，可以看到当前项目<strong>生效的所有插件</strong>（包括显式写的 + 继承的 + 默认的）。</p></blockquote><hr><h3 id="🧩-方法一：用-mvn-help-effective-pom"><a href="#🧩-方法一：用-mvn-help-effective-pom" class="headerlink" title="🧩 方法一：用 mvn help:effective-pom"></a>🧩 方法一：用 <code>mvn help:effective-pom</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn <span class="built_in">help</span>:effective-pom</span><br></pre></td></tr></table></figure><p>它会输出合并后的完整 POM 内容，包括：</p><ul><li>你自己写在 <code>&lt;plugins&gt;</code> 和 <code>&lt;pluginManagement&gt;</code> 中的插件</li><li>父 POM 中继承的插件</li><li>超级 POM 自动引入的插件（如 <code>maven-compiler-plugin</code>, <code>maven-jar-plugin</code>）</li></ul><p>📌 搜索关键词：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugins&gt;</span><br></pre></td></tr></table></figure><p>可以快速定位所有插件配置。</p><hr><h3 id="🛠-方法二：从-target-目录的-effective-pom-xml-查看（如果生成了）"><a href="#🛠-方法二：从-target-目录的-effective-pom-xml-查看（如果生成了）" class="headerlink" title="🛠 方法二：从 target 目录的 effective-pom.xml 查看（如果生成了）"></a>🛠 方法二：从 <code>target</code> 目录的 <code>effective-pom.xml</code> 查看（如果生成了）</h3><p>部分构建工具（如 IDEA）或 CI 流水线也可能会生成合并后的 POM：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target/effective-pom.xml</span><br></pre></td></tr></table></figure><p>可以直接查看里面所有 plugin 配置。</p><hr><h3 id="🔍-方法三：查看构建日志时的插件调用（动态观察）"><a href="#🔍-方法三：查看构建日志时的插件调用（动态观察）" class="headerlink" title="🔍 方法三：查看构建日志时的插件调用（动态观察）"></a>🔍 方法三：查看构建日志时的插件调用（动态观察）</h3><p>执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn package -X</span><br></pre></td></tr></table></figure><p>或加 <code>-X</code> 查看完整日志，控制台中会显示：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[INFO] --- maven-compiler-plugin:3.10.1:compile (default-compile) @ your-project ---</span><br><span class="line">[INFO] --- maven-jar-plugin:3.2.2:jar (default-jar) @ your-project ---</span><br></pre></td></tr></table></figure><p>这能看到<strong>哪些插件在生命周期中被调用了、调用的是哪个目标</strong>，非常适合观察实际构建流程。</p><hr><h3 id="✅-实践："><a href="#✅-实践：" class="headerlink" title="✅ 实践："></a>✅ 实践：</h3><ol><li>写一个最简单的 POM（不配置任何插件）</li><li>执行：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn <span class="built_in">help</span>:effective-pom</span><br></pre></td></tr></table></figure></li><li>观察仍然有很多插件（默认从超级 POM继承）</li><li>加上自定义插件，观察插件列表发生变化</li></ol><hr><h3 id="✅-总结-1"><a href="#✅-总结-1" class="headerlink" title="✅ 总结"></a>✅ 总结</h3><blockquote><p>查看当前项目用了哪些插件，最权威的方式是用：<br><strong><code>mvn help:effective-pom</code> → 查看 <code>&lt;plugins&gt;</code> 部分</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> java </category>
          
          <category> 框架 </category>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test1</title>
      <link href="/2025/03/27/test1/"/>
      <url>/2025/03/27/test1/</url>
      
        <content type="html"><![CDATA[<p>Mybatis是一个orm框架</p>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2025/03/27/test/"/>
      <url>/2025/03/27/test/</url>
      
        <content type="html"><![CDATA[<p>11223<br>Springboot 是一个开箱即用的框架</p>]]></content>
      
      
      <categories>
          
          <category> Springboot </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Snipaste + Hexo + GitHub + jsDelivr CDN 图床方案</title>
      <link href="/2025/03/27/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/Snipaste%20+%20Hexo%20+%20GitHub%20+%20jsDelivr%20CDN%20%E5%9B%BE%E5%BA%8A%E6%96%B9%E6%A1%88/"/>
      <url>/2025/03/27/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/Snipaste%20+%20Hexo%20+%20GitHub%20+%20jsDelivr%20CDN%20%E5%9B%BE%E5%BA%8A%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>完美的组合来了！你想在 <strong>macOS</strong> 上打造一个：</p><p>🚀 高效截图 → 自动上传 GitHub → 自动生成 CDN 图链 → Markdown 直接贴图</p><p>我为你设计了一套完整的 “Snipaste + Hexo + GitHub + jsDelivr CDN 图床方案”，让你<strong>截图即图床，图链即插用！</strong></p><hr><h2 id="✅-一图概览"><a href="#✅-一图概览" class="headerlink" title="✅ 一图概览"></a>✅ 一图概览</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Snipaste（截图标注）📸</span><br><span class="line">   ↓（复制到剪贴板）</span><br><span class="line">PicGo（自动上传）🚀</span><br><span class="line">   ↓（上传到 GitHub 图床）</span><br><span class="line">jsDelivr（CDN 加速）⚡</span><br><span class="line">   ↓</span><br><span class="line">Hexo Markdown 插图 ✅</span><br></pre></td></tr></table></figure><hr><h2 id="🧱-你需要的工具（全免费）"><a href="#🧱-你需要的工具（全免费）" class="headerlink" title="🧱 你需要的工具（全免费）"></a>🧱 你需要的工具（全免费）</h2><table><thead><tr><th>工具</th><th>用途</th><th>是否必须</th></tr></thead><tbody><tr><td><strong>Snipaste</strong></td><td>截图 + 标记（带贴图）</td><td>✅</td></tr><tr><td><strong>PicGo</strong></td><td>图床上传工具</td><td>✅</td></tr><tr><td><strong>GitHub</strong></td><td>图床存储（公开仓库）</td><td>✅</td></tr><tr><td><strong>jsDelivr</strong></td><td>CDN 加速 GitHub 图链</td><td>✅</td></tr><tr><td><strong>Hexo</strong></td><td>博客系统</td><td>✅</td></tr></tbody></table><hr><h2 id="🛠️-Step-by-Step-全流程配置"><a href="#🛠️-Step-by-Step-全流程配置" class="headerlink" title="🛠️ Step-by-Step 全流程配置"></a>🛠️ Step-by-Step 全流程配置</h2><hr><h3 id="📸-Step-1：安装-Snipaste-for-macOS"><a href="#📸-Step-1：安装-Snipaste-for-macOS" class="headerlink" title="📸 Step 1：安装 Snipaste for macOS"></a>📸 Step 1：安装 Snipaste for macOS</h3><ul><li>官网：<a href="https://snipaste.com/">https://snipaste.com</a></li><li>支持快捷键截图、标注、钉图</li><li>设置截图快捷键（如 <code>⌘ + Shift + A</code>）</li></ul><p>✅ <strong>截图后可自动复制到剪贴板（设置中开启）</strong></p><hr><h3 id="🚀-Step-2：安装-PicGo-配置-GitHub-图床"><a href="#🚀-Step-2：安装-PicGo-配置-GitHub-图床" class="headerlink" title="🚀 Step 2：安装 PicGo + 配置 GitHub 图床"></a>🚀 Step 2：安装 PicGo + 配置 GitHub 图床</h3><h4 id="安装-PicGo："><a href="#安装-PicGo：" class="headerlink" title="安装 PicGo："></a>安装 PicGo：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install --cask picgo</span><br></pre></td></tr></table></figure><p>或从官网下载：<a href="https://picgo.github.io/">https://picgo.github.io/</a></p><p>最近PicGo打开后一直提示安装更新的版本，于是去<code>gitHub</code>下载了最新版本，安装后打开，弹窗提示信息：<code>**文件已损坏，您应该将它移到废纸篓。**</code></p><h3 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h3><h4 id="1-打开终端输入"><a href="#1-打开终端输入" class="headerlink" title="1.打开终端输入"></a>1.打开终端输入</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> xattr -d com.apple.quarantine <span class="string">&quot;/Applications/PicGo.app&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># /Applications/PicGo.app 为程序安装的路径</span></span><br></pre></td></tr></table></figure><h4 id="2-根据终端提示输入登录密码，重新打开就可以了"><a href="#2-根据终端提示输入登录密码，重新打开就可以了" class="headerlink" title="2.根据终端提示输入登录密码，重新打开就可以了"></a>2.根据终端提示输入登录密码，重新打开就可以了</h4><h4 id="配置图床："><a href="#配置图床：" class="headerlink" title="配置图床："></a>配置图床：</h4><p>打开 PicGo → 图床设置 → 选择 <code>GitHub 图床</code>，填写以下信息：</p><table><thead><tr><th>项目</th><th>示例</th></tr></thead><tbody><tr><td>仓库名</td><td><code>你的用户名/hexo-img</code>（新建公开仓库）</td></tr><tr><td>分支</td><td><code>main</code></td></tr><tr><td>Token</td><td>GitHub Personal Access Token（含 repo 权限）</td></tr><tr><td>存储路径</td><td><code>img/</code>（可选）</td></tr><tr><td>自定义域名（CDN）不配CDN不用写</td><td><code>https://cdn.jsdelivr.net/gh/你的用户名/hexo-img@main</code></td></tr></tbody></table><p>👉 设置完成后，上传的每张图都会用 jsDelivr 加速图链 ✅</p><hr><h3 id="🎯-Step-3：绑定上传快捷键"><a href="#🎯-Step-3：绑定上传快捷键" class="headerlink" title="🎯 Step 3：绑定上传快捷键"></a>🎯 Step 3：绑定上传快捷键</h3><ul><li>打开 PicGo → 快捷键设置 → 设置「上传剪贴板图片」快捷键，例如：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Control + Option + P</span><br></pre></td></tr></table></figure><hr><h3 id="🧪-Step-4：测试上传"><a href="#🧪-Step-4：测试上传" class="headerlink" title="🧪 Step 4：测试上传"></a>🧪 Step 4：测试上传</h3><ol><li>用 Snipaste 截图 + 标注，完成后复制到剪贴板</li><li>按快捷键 <code>Ctrl + Opt + P</code></li><li>图片自动上传 GitHub，返回加速图链！</li></ol><p>示例输出图链：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](<span class="link">https://cdn.jsdelivr.net/gh/yourname/hexo-img@main/img/2025-03-27-hello.png</span>)</span><br></pre></td></tr></table></figure><p>粘贴到 Hexo Markdown 即可插图！</p><hr><h2 id="🧠-Tips：图片更新怎么处理？"><a href="#🧠-Tips：图片更新怎么处理？" class="headerlink" title="🧠 Tips：图片更新怎么处理？"></a>🧠 Tips：图片更新怎么处理？</h2><p>CDN 有缓存，如果你更新了图片但地址没变，可使用以下方式刷新：</p><table><thead><tr><th>方法</th><th>示例</th></tr></thead><tbody><tr><td>改文件名</td><td><code>cover-v2.png</code> 或 <code>cover-20250328.png</code></td></tr><tr><td>加参数</td><td><code>?v=2</code> → <code>cover.png?v=2</code>，可强制刷新</td></tr><tr><td>删除重传</td><td>直接从 GitHub 删除旧图，再上传新图</td></tr></tbody></table><hr><h2 id="🧰-Bonus：图床仓库推荐结构"><a href="#🧰-Bonus：图床仓库推荐结构" class="headerlink" title="🧰 Bonus：图床仓库推荐结构"></a>🧰 Bonus：图床仓库推荐结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo-img/</span><br><span class="line">├── img/</span><br><span class="line">│   ├── 2025-03/</span><br><span class="line">│   │   ├── pic-01.png</span><br><span class="line">│   │   └── cover-v2.png</span><br></pre></td></tr></table></figure><p>这样路径结构清晰，适合长期管理。</p><p>PicGo 支持动态路径！你可以设置路径自动按日期分类：</p><h4 id="🔧-PicGo-设置示例："><a href="#🔧-PicGo-设置示例：" class="headerlink" title="🔧 PicGo 设置示例："></a>🔧 PicGo 设置示例：</h4><p>打开 PicGo → 图床设置 → GitHub 图床 → 存储路径 填写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img/$&#123;year&#125;-$&#123;month&#125;/</span><br></pre></td></tr></table></figure><p>上面这个方法不靠谱，需要用到一个插件<a href="https://github.com/melon95/picgo-plugin-custom-path"><strong>picgo-plugin-custom-path</strong></a></p><p><strong>但是文件名有点长</strong></p><p><img src="https://cdn.jsdelivr.net/gh/neoisok/assets@main/images%2F2025%2F03%2F27%2F20250327234848693-f76bf6ed2a29672c38cd6101f3aaad75.png"></p><p>文件重命名开启<br><img src="https://cdn.jsdelivr.net/gh/neoisok/assets@main/images%2F2025%2F03%2F27%2F20250327234915338-5714bb2951fc86c47ab288ce853fe1fc.png" width=600></p><h2 id="📦-最终使用体验"><a href="#📦-最终使用体验" class="headerlink" title="📦 最终使用体验"></a>📦 最终使用体验</h2><table><thead><tr><th>动作</th><th>操作方式</th></tr></thead><tbody><tr><td>截图 + 标注</td><td>用 Snipaste <code>⌘ + Shift + A</code></td></tr><tr><td>上传图床</td><td><code>Ctrl + Option + P</code>（剪贴板上传）</td></tr><tr><td>粘贴图链</td><td>⌘ + V 粘贴 → Hexo 文章即可显示 ✅</td></tr><tr><td>图链走 CDN 加速</td><td>jsDelivr 提供全球 CDN，国内速度飞快</td></tr></tbody></table><hr><h2 id="✅-总结配置清单"><a href="#✅-总结配置清单" class="headerlink" title="✅ 总结配置清单"></a>✅ 总结配置清单</h2><table><thead><tr><th>工具</th><th>下载地址</th></tr></thead><tbody><tr><td>Snipaste</td><td><a href="https://snipaste.com/">https://snipaste.com</a></td></tr><tr><td>PicGo</td><td><a href="https://picgo.github.io/">https://picgo.github.io</a></td></tr><tr><td>GitHub 图床</td><td><a href="https://github.com/">https://github.com</a></td></tr><tr><td>jsDelivr CDN</td><td><a href="https://www.jsdelivr.com/">https://www.jsdelivr.com</a></td></tr></tbody></table><hr>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 图床 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git 操作详解</title>
      <link href="/2025/03/27/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/git%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3/"/>
      <url>/2025/03/27/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/git%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="git清除缓存"><a href="#git清除缓存" class="headerlink" title="git清除缓存"></a>git清除缓存</h1><p>你遇到的这个问题，是由于之前<strong>嵌套了 git 仓库</strong>，删除了 <code>themes/butterfly/.git</code> 后，又执行了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add themes/butterfly</span><br><span class="line">git commit -m &quot;添加 Butterfly 主题（非子模块）&quot;</span><br></pre></td></tr></table></figure><p>此时你的本地仓库正常了，但在 GitHub 上仍显示 Butterfly 文件夹为空，这是因为：</p><ul><li>Git 对嵌套仓库只保存了一个指针（子模块链接）。</li><li>当你删除 <code>.git</code> 文件夹后，实际上内容<strong>并未真正提交</strong>到远程仓库，Git 仍然只记录了主题文件夹的引用。</li></ul><p><strong>出现奇怪问题之后</strong></p><ul><li>彻底从 git 的缓存中移除旧引用。</li><li>然后重新执行 <code>git add</code> 和 <code>git commit</code> 提交所有文件。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached themes/butterfly -r</span><br><span class="line">git add themes/butterfly</span><br><span class="line">git commit -m &quot;重新添加 Butterfly 主题文件&quot;</span><br><span class="line">git push origin main</span><br></pre></td></tr></table></figure><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><hr><h2 id="🧱-一、仓库初始化-基础操作"><a href="#🧱-一、仓库初始化-基础操作" class="headerlink" title="🧱 一、仓库初始化 &amp; 基础操作"></a>🧱 一、仓库初始化 &amp; 基础操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git init                      <span class="comment"># 初始化本地 Git 仓库</span></span><br><span class="line">git <span class="built_in">clone</span> &lt;repo_url&gt;         <span class="comment"># 克隆远程仓库</span></span><br><span class="line">git status                   <span class="comment"># 查看当前状态（改动、未提交）</span></span><br><span class="line">git add &lt;file&gt;               <span class="comment"># 将文件加入暂存区（可以 . 表示全部）</span></span><br><span class="line">git commit -m <span class="string">&quot;备注信息&quot;</span>     <span class="comment"># 提交代码并添加说明</span></span><br></pre></td></tr></table></figure><hr><h2 id="🌿-二、分支操作"><a href="#🌿-二、分支操作" class="headerlink" title="🌿 二、分支操作"></a>🌿 二、分支操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git branch                   <span class="comment"># 查看本地所有分支</span></span><br><span class="line">git branch &lt;branch-name&gt;     <span class="comment"># 新建分支</span></span><br><span class="line">git checkout &lt;branch-name&gt;   <span class="comment"># 切换到分支</span></span><br><span class="line">git checkout -b &lt;branch-name&gt; <span class="comment"># 新建并切换</span></span><br><span class="line">git merge &lt;branch-name&gt;      <span class="comment"># 合并某分支到当前分支</span></span><br><span class="line">git branch -d &lt;branch-name&gt;  <span class="comment"># 删除本地分支</span></span><br></pre></td></tr></table></figure><hr><h2 id="🔁-三、远程操作"><a href="#🔁-三、远程操作" class="headerlink" title="🔁 三、远程操作"></a>🔁 三、远程操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git remote -v                                <span class="comment"># 查看远程仓库地址</span></span><br><span class="line">git remote add origin &lt;url&gt;                  <span class="comment"># 添加远程仓库地址</span></span><br><span class="line">git push origin &lt;branch&gt;                     <span class="comment"># 推送当前分支到远程仓库</span></span><br><span class="line">git pull origin &lt;branch&gt;                     <span class="comment"># 拉取远程分支并合并</span></span><br><span class="line">git fetch                                    <span class="comment"># 拉取远程所有更新（不合并）</span></span><br><span class="line">git push -u origin &lt;branch&gt;                  <span class="comment"># 首次推送并关联分支</span></span><br></pre></td></tr></table></figure><hr><h2 id="🔍-四、查看历史-差异"><a href="#🔍-四、查看历史-差异" class="headerlink" title="🔍 四、查看历史 &amp; 差异"></a>🔍 四、查看历史 &amp; 差异</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span>                          <span class="comment"># 查看提交历史</span></span><br><span class="line">git <span class="built_in">log</span> --oneline --graph        <span class="comment"># 简洁的图形化提交历史</span></span><br><span class="line">git diff                         <span class="comment"># 查看工作区与暂存区差异</span></span><br><span class="line">git diff &lt;branch1&gt; &lt;branch2&gt;     <span class="comment"># 比较两个分支差异</span></span><br></pre></td></tr></table></figure><hr><h2 id="🧼-五、撤销操作（常用救命命令）"><a href="#🧼-五、撤销操作（常用救命命令）" class="headerlink" title="🧼 五、撤销操作（常用救命命令）"></a>🧼 五、撤销操作（常用救命命令）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- &lt;file&gt;           <span class="comment"># 撤销对某文件的修改</span></span><br><span class="line">git reset HEAD &lt;file&gt;            <span class="comment"># 取消暂存（撤回 git add）</span></span><br><span class="line">git reset --hard HEAD            <span class="comment"># 撤销所有修改并恢复到最后一次提交状态 ❗危险</span></span><br><span class="line">git clean -fd                    <span class="comment"># 删除所有未追踪文件（慎用）</span></span><br></pre></td></tr></table></figure><hr><h2 id="💥-六、冲突解决"><a href="#💥-六、冲突解决" class="headerlink" title="💥 六、冲突解决"></a>💥 六、冲突解决</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 出现冲突时：</span></span><br><span class="line"><span class="comment"># 1. 手动修改冲突文件</span></span><br><span class="line"><span class="comment"># 2. 然后：</span></span><br><span class="line">git add &lt;file&gt;                   <span class="comment"># 标记冲突已解决</span></span><br><span class="line">git commit                      <span class="comment"># 提交合并后的结果</span></span><br></pre></td></tr></table></figure><hr><h2 id="🪄-七、标签（打版本）"><a href="#🪄-七、标签（打版本）" class="headerlink" title="🪄 七、标签（打版本）"></a>🪄 七、标签（打版本）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git tag                          <span class="comment"># 查看标签</span></span><br><span class="line">git tag v1.0.0                   <span class="comment"># 创建标签</span></span><br><span class="line">git tag -d v1.0.0                <span class="comment"># 删除标签</span></span><br><span class="line">git push origin v1.0.0           <span class="comment"># 推送标签</span></span><br></pre></td></tr></table></figure><hr><h2 id="🔐-八、配置常用信息"><a href="#🔐-八、配置常用信息" class="headerlink" title="🔐 八、配置常用信息"></a>🔐 八、配置常用信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;Neo&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;neo@example.com&quot;</span></span><br><span class="line">git config --global core.editor <span class="string">&quot;code --wait&quot;</span>  <span class="comment"># 设置默认编辑器为 VSCode</span></span><br></pre></td></tr></table></figure><hr><h2 id="🧠-Bonus：推荐-Git-分支命名规范（可用于多人协作）"><a href="#🧠-Bonus：推荐-Git-分支命名规范（可用于多人协作）" class="headerlink" title="🧠 Bonus：推荐 Git 分支命名规范（可用于多人协作）"></a>🧠 Bonus：推荐 Git 分支命名规范（可用于多人协作）</h2><table><thead><tr><th>类型</th><th>示例</th><th>用途</th></tr></thead><tbody><tr><td><code>feat/xxx</code></td><td><code>feat/login-api</code></td><td>新功能</td></tr><tr><td><code>fix/xxx</code></td><td><code>fix/login-bug</code></td><td>修复 bug</td></tr><tr><td><code>hotfix/xxx</code></td><td><code>hotfix/crash-on-launch</code></td><td>紧急修复</td></tr><tr><td><code>test/xxx</code></td><td><code>test/new-framework</code></td><td>实验性分支</td></tr><tr><td><code>release/x.y.z</code></td><td><code>release/1.0.0</code></td><td>预发版本</td></tr><tr><td><code>docs/xxx</code></td><td><code>docs/api-readme</code></td><td>文档修改</td></tr></tbody></table><hr><h1 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title="cherry pick"></a>cherry pick</h1><p>嘿嘿 Neo，问得太准了！<code>cherry-pick</code> 是 Git 中非常实用、<strong>但又稍微高级一点的命令</strong>，用于把<strong>某个提交（commit）从一个分支“精确复制”到另一个分支</strong>。</p><hr><h2 id="🍒-一、什么是-git-cherry-pick？"><a href="#🍒-一、什么是-git-cherry-pick？" class="headerlink" title="🍒 一、什么是 git cherry-pick？"></a>🍒 一、什么是 <code>git cherry-pick</code>？</h2><p><code>git cherry-pick</code> 的作用是：<br>👉 <strong>选择一个或多个特定提交（commit），应用到当前分支上</strong>，而不是整个分支的 merge。</p><p>非常适用于这样的场景：</p><p>💡“我在 <code>dev</code> 分支修了一个 bug，现在想把这个修复也同步到 <code>release</code> 分支，但不想把整个 dev 分支合并过来。”</p><hr><h2 id="✅-二、基本语法"><a href="#✅-二、基本语法" class="headerlink" title="✅ 二、基本语法"></a>✅ 二、基本语法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick &lt;commit-id&gt;</span><br></pre></td></tr></table></figure><p>比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout release</span><br><span class="line">git cherry-pick a1b2c3d4</span><br></pre></td></tr></table></figure><p>这会把 <code>a1b2c3d4</code> 这个提交“复制”一份应用到 <code>release</code> 分支上。</p><hr><h2 id="🧩-三、进阶用法"><a href="#🧩-三、进阶用法" class="headerlink" title="🧩 三、进阶用法"></a>🧩 三、进阶用法</h2><h3 id="1-多个-commit-一起-cherry-pick："><a href="#1-多个-commit-一起-cherry-pick：" class="headerlink" title="1. 多个 commit 一起 cherry-pick："></a>1. 多个 commit 一起 cherry-pick：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick &lt;commit1&gt; &lt;commit2&gt; &lt;commit3&gt;</span><br></pre></td></tr></table></figure><h3 id="2-范围-cherry-pick（不包含起始-commit）："><a href="#2-范围-cherry-pick（不包含起始-commit）：" class="headerlink" title="2. 范围 cherry-pick（不包含起始 commit）："></a>2. 范围 cherry-pick（不包含起始 commit）：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick A^..C</span><br></pre></td></tr></table></figure><p>意思是：从 A 的下一个 commit 到 C（包括 C）</p><hr><h2 id="⚔️-四、cherry-pick-时可能遇到冲突怎么办？"><a href="#⚔️-四、cherry-pick-时可能遇到冲突怎么办？" class="headerlink" title="⚔️ 四、cherry-pick 时可能遇到冲突怎么办？"></a>⚔️ 四、cherry-pick 时可能遇到冲突怎么办？</h2><ol><li>如果冲突了，Git 会提示你冲突文件</li><li>手动修改这些文件，解决冲突</li><li>然后执行：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git cherry-pick --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure><ol><li>如果想放弃这次 cherry-pick：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick --abort</span><br></pre></td></tr></table></figure><hr><h2 id="💡-五、常见使用场景总结"><a href="#💡-五、常见使用场景总结" class="headerlink" title="💡 五、常见使用场景总结"></a>💡 五、常见使用场景总结</h2><table><thead><tr><th>场景</th><th>是否适合 cherry-pick</th></tr></thead><tbody><tr><td>从 <code>dev</code> 拿一个修复提交到 <code>release</code></td><td>✅ 非常适合</td></tr><tr><td>拿多个提交跨分支迁移</td><td>✅ OK，但注意顺序和冲突</td></tr><tr><td>想同步整个分支</td><td>❌ 应该用 <code>merge</code> 或 <code>rebase</code></td></tr><tr><td>做热修复 patch</td><td>✅ 用 cherry-pick 很自然</td></tr></tbody></table><hr><h2 id="👀-六、如何找-commit-id？"><a href="#👀-六、如何找-commit-id？" class="headerlink" title="👀 六、如何找 commit-id？"></a>👀 六、如何找 commit-id？</h2><p>执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --graph --oneline --all</span><br></pre></td></tr></table></figure><p>可以看到所有提交的 ID（短哈希），然后 cherry-pick 你需要的那个。</p><hr><h2 id="✨-七、IDEA-中如何-cherry-pick？"><a href="#✨-七、IDEA-中如何-cherry-pick？" class="headerlink" title="✨ 七、IDEA 中如何 cherry-pick？"></a>✨ 七、IDEA 中如何 cherry-pick？</h2><ol><li>打开 <code>Git &gt; Log</code></li><li>右键某个提交 → <code>Cherry-pick</code></li><li>自动切换到当前分支并执行 cherry-pick</li><li>有冲突的话 IDEA 会提示你合并</li></ol><hr><h2 id="✅-小结"><a href="#✅-小结" class="headerlink" title="✅ 小结"></a>✅ 小结</h2><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><code>git cherry-pick &lt;commit&gt;</code></td><td>把某个提交复制到当前分支</td></tr><tr><td><code>git cherry-pick --abort</code></td><td>取消 cherry-pick 操作</td></tr><tr><td><code>git cherry-pick --continue</code></td><td>解决冲突后继续操作</td></tr></tbody></table><hr><h1 id="🧠-Git-高阶命令合集（推荐收藏）"><a href="#🧠-Git-高阶命令合集（推荐收藏）" class="headerlink" title="🧠 Git 高阶命令合集（推荐收藏）"></a>🧠 Git 高阶命令合集（推荐收藏）</h1><hr><h3 id="1️⃣-git-rebase（变基）"><a href="#1️⃣-git-rebase（变基）" class="headerlink" title="1️⃣ git rebase（变基）"></a>1️⃣ <code>git rebase</code>（变基）</h3><p>✨ 让提交历史更干净，线性合并分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature</span><br><span class="line">git rebase main</span><br></pre></td></tr></table></figure><p>意思是：把 feature 分支的提交“搬到” main 分支后面。</p><p>配合交互式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~5   <span class="comment"># 交互式 rebase 最近 5 次提交</span></span><br></pre></td></tr></table></figure><p>可做：</p><ul><li>合并多个提交（squash）</li><li>修改提交说明（reword）</li><li>删除提交（drop）</li><li>改提交顺序</li></ul><hr><h3 id="2️⃣-git-stash（临时保存工作区）"><a href="#2️⃣-git-stash（临时保存工作区）" class="headerlink" title="2️⃣ git stash（临时保存工作区）"></a>2️⃣ <code>git stash</code>（临时保存工作区）</h3><p>🔧 当你工作一半，突然要切分支处理 bug，但又不想提交</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git stash         <span class="comment"># 保存当前改动</span></span><br><span class="line">git stash list    <span class="comment"># 查看所有 stash</span></span><br><span class="line">git stash pop     <span class="comment"># 恢复最近一次 stash 并删除</span></span><br><span class="line">git stash apply   <span class="comment"># 恢复但不删除</span></span><br></pre></td></tr></table></figure><hr><h3 id="3️⃣-git-reflog（Git-的后悔药）"><a href="#3️⃣-git-reflog（Git-的后悔药）" class="headerlink" title="3️⃣ git reflog（Git 的后悔药）"></a>3️⃣ <code>git reflog</code>（Git 的后悔药）</h3><p>🧠 误删分支、误 reset 后的救命命令！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure><ul><li>能看到所有 HEAD 的移动记录</li><li>例如：你误删了分支或重置了 HEAD，可以找回 commit：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard &lt;某个旧的commit-id&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="4️⃣-git-reset（强力撤销）"><a href="#4️⃣-git-reset（强力撤销）" class="headerlink" title="4️⃣ git reset（强力撤销）"></a>4️⃣ <code>git reset</code>（强力撤销）</h3><p>🚨 撤销提交、回退代码、回滚状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft HEAD~1     <span class="comment"># 撤销最近一次提交（保留代码）</span></span><br><span class="line">git reset --mixed HEAD~1    <span class="comment"># 撤销提交+取消暂存</span></span><br><span class="line">git reset --hard HEAD~1     <span class="comment"># 撤销提交+取消暂存+还原代码</span></span><br></pre></td></tr></table></figure><p>❗ <code>--hard</code> 是最危险的，别轻易动！</p><hr><h3 id="5️⃣-git-clean（清理未跟踪文件）"><a href="#5️⃣-git-clean（清理未跟踪文件）" class="headerlink" title="5️⃣ git clean（清理未跟踪文件）"></a>5️⃣ <code>git clean</code>（清理未跟踪文件）</h3><p>🧹 删除所有没被 Git 跟踪的文件，比如 <code>.DS_Store</code>、缓存等</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean -fd</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>-f</code> force</li><li><code>-d</code> 目录也删</li></ul><hr><h3 id="6️⃣-git-blame（谁改的）"><a href="#6️⃣-git-blame（谁改的）" class="headerlink" title="6️⃣ git blame（谁改的）"></a>6️⃣ <code>git blame</code>（谁改的）</h3><p>🕵️ 查某一行是谁在什么时候提交的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git blame 文件名</span><br></pre></td></tr></table></figure><p>也可以查某一行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git blame -L 15,25 文件名   <span class="comment"># 查第15到25行</span></span><br></pre></td></tr></table></figure><hr><h3 id="7️⃣-git-bisect（二分定位-bug）"><a href="#7️⃣-git-bisect（二分定位-bug）" class="headerlink" title="7️⃣ git bisect（二分定位 bug）"></a>7️⃣ <code>git bisect</code>（二分定位 bug）</h3><p>🪓 自动帮你在一堆提交中定位是哪次提交引入了 bug</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git bisect start</span><br><span class="line">git bisect bad              <span class="comment"># 当前是有 bug 的版本</span></span><br><span class="line">git bisect good v1.0.0      <span class="comment"># v1.0.0 是正常的版本</span></span><br></pre></td></tr></table></figure><p>之后 Git 会一步步二分你历史的提交，让你判断哪个是好哪个是坏，直到定位到“坏提交”。</p><hr><h3 id="8️⃣-git-log-高级玩法（格式化历史）"><a href="#8️⃣-git-log-高级玩法（格式化历史）" class="headerlink" title="8️⃣ git log 高级玩法（格式化历史）"></a>8️⃣ <code>git log</code> 高级玩法（格式化历史）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline --graph --decorate --all</span><br></pre></td></tr></table></figure><p>🌳 查看完整分支图，非常清晰直观：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* a1b2c3 (HEAD -&gt; feature)</span><br><span class="line">| * d4e5f6 (main)</span><br><span class="line">|/</span><br><span class="line">* 123abc</span><br></pre></td></tr></table></figure><hr><h3 id="9️⃣-git-commit-amend（修改上一次提交）"><a href="#9️⃣-git-commit-amend（修改上一次提交）" class="headerlink" title="9️⃣ git commit --amend（修改上一次提交）"></a>9️⃣ <code>git commit --amend</code>（修改上一次提交）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><ul><li>修改提交说明</li><li>或者补加文件（漏了个文件）</li></ul><hr><h3 id="🔟-git-remote-prune-origin（清理无效远程分支）"><a href="#🔟-git-remote-prune-origin（清理无效远程分支）" class="headerlink" title="🔟 git remote prune origin（清理无效远程分支）"></a>🔟 <code>git remote prune origin</code>（清理无效远程分支）</h3><p>🔪 删除那些远程已经删了但本地还看的见的“残影分支”</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote prune origin</span><br></pre></td></tr></table></figure><hr><h2 id="🚀-Bonus：别忘了-Git-的命令可以组合！"><a href="#🚀-Bonus：别忘了-Git-的命令可以组合！" class="headerlink" title="🚀 Bonus：别忘了 Git 的命令可以组合！"></a>🚀 Bonus：别忘了 Git 的命令可以组合！</h2><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --author=neo --since=<span class="string">&quot;1 week ago&quot;</span> --oneline</span><br></pre></td></tr></table></figure><p>看一周内 Neo 提交了什么 👀</p><hr><p>Neo，这个问题问得非常到位，<code>.gitignore</code> 的行为有点“套路”，咱来给你彻底讲透 👇</p><hr><h1 id="😵-为什么-DS-Store-已经写进-gitignore-了，git-status-里还是有？"><a href="#😵-为什么-DS-Store-已经写进-gitignore-了，git-status-里还是有？" class="headerlink" title="😵 为什么 .DS_Store 已经写进 .gitignore 了，git status 里还是有？"></a>😵 为什么 <code>.DS_Store</code> 已经写进 <code>.gitignore</code> 了，<code>git status</code> 里还是有？</h1><hr><h3 id="✅-所以有两种情况你得分清楚："><a href="#✅-所以有两种情况你得分清楚：" class="headerlink" title="✅ 所以有两种情况你得分清楚："></a>✅ 所以有两种情况你得分清楚：</h3><table><thead><tr><th>情况</th><th>会不会被忽略？</th></tr></thead><tbody><tr><td>文件还没被 Git 跟踪过</td><td>✅ 会忽略（git status 不显示）</td></tr><tr><td>文件 <strong>已经被 Git 跟踪过（add 或 commit 过）</strong></td><td>❌ 不会忽略，必须手动移除！</td></tr></tbody></table><hr><h2 id="🔍-判断-DS-Store-是否已经被-Git-跟踪："><a href="#🔍-判断-DS-Store-是否已经被-Git-跟踪：" class="headerlink" title="🔍 判断 .DS_Store 是否已经被 Git 跟踪："></a>🔍 判断 <code>.DS_Store</code> 是否已经被 Git 跟踪：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git ls-files | grep .DS_Store</span><br></pre></td></tr></table></figure><p>如果输出有 <code>.DS_Store</code>，说明它<strong>已经被 Git 加进版本库</strong>，就算你 <code>.gitignore</code> 了也没用。</p><hr><h2 id="✅-解决方案：从-Git-跟踪中移除-DS-Store"><a href="#✅-解决方案：从-Git-跟踪中移除-DS-Store" class="headerlink" title="✅ 解决方案：从 Git 跟踪中移除 .DS_Store"></a>✅ 解决方案：从 Git 跟踪中移除 <code>.DS_Store</code></h2><p>这一步可以“清洗干净”旧的 <code>.DS_Store</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从 Git 索引中移除，但保留文件本身（不删除磁盘文件）</span></span><br><span class="line">git <span class="built_in">rm</span> -r --cached .DS_Store</span><br></pre></td></tr></table></figure><p>如果你项目中很多地方有 <code>.DS_Store</code>，可以这么来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name .DS_Store -print0 | xargs -0 git <span class="built_in">rm</span> --cached</span><br></pre></td></tr></table></figure><p>然后：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;chore: remove tracked .DS_Store files&quot;</span></span><br></pre></td></tr></table></figure><p><strong>之后就不会再出现在 git status 了！</strong></p><hr><h2 id="✅-最终你需要这两件事配套完成："><a href="#✅-最终你需要这两件事配套完成：" class="headerlink" title="✅ 最终你需要这两件事配套完成："></a>✅ 最终你需要这两件事配套完成：</h2><h3 id="1-gitignore-文件中写："><a href="#1-gitignore-文件中写：" class="headerlink" title="1. .gitignore 文件中写："></a>1. <code>.gitignore</code> 文件中写：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">**/.DS_Store</span><br></pre></td></tr></table></figure><h3 id="2-手动移除已跟踪的-DS-Store："><a href="#2-手动移除已跟踪的-DS-Store：" class="headerlink" title="2. 手动移除已跟踪的 .DS_Store："></a>2. 手动移除已跟踪的 <code>.DS_Store</code>：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> -r --cached .DS_Store</span><br><span class="line">git commit -m <span class="string">&quot;remove .DS_Store from repo&quot;</span></span><br></pre></td></tr></table></figure><hr><h1 id="有不同的分支，需要指定如何调和它们"><a href="#有不同的分支，需要指定如何调和它们" class="headerlink" title="有不同的分支，需要指定如何调和它们"></a>有不同的分支，需要指定如何调和它们</h1><p>以下报错解决方案</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">hint: You have divergent branches and need to specify how to reconcile them.</span><br><span class="line">hint: You can do so by running one of the following commands sometime before</span><br><span class="line">hint: your next pull:</span><br><span class="line">hint: </span><br><span class="line">hint:   git config pull.rebase false  # merge</span><br><span class="line">hint:   git config pull.rebase true   # rebase</span><br><span class="line">hint:   git config pull.ff only       # fast-forward only</span><br><span class="line">hint: </span><br><span class="line">hint: You can replace &quot;git config&quot; with &quot;git config --global&quot; to set a default</span><br><span class="line">hint: preference for all repositories. You can also pass --rebase, --no-rebase,</span><br><span class="line">hint: or --ff-only on the command line to override the configured default per</span><br><span class="line">hint: invocation.</span><br><span class="line">fatal: Need to specify how to reconcile divergent branches.</span><br></pre></td></tr></table></figure><h2 id="🧼-最后建议：也别让以后生成-DS-Store"><a href="#🧼-最后建议：也别让以后生成-DS-Store" class="headerlink" title="🧼 最后建议：也别让以后生成 .DS_Store"></a>🧼 最后建议：也别让以后生成 <code>.DS_Store</code></h2><p>你可以加一个全局 <code>.gitignore</code>，让所有 Git 项目都忽略它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.excludesfile ~/.gitignore_global</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;.DS_Store&quot;</span> &gt;&gt; ~/.gitignore_global</span><br></pre></td></tr></table></figure><hr><h2 id="✅-解决方案一：自动合并（推荐，适合大多数情况）"><a href="#✅-解决方案一：自动合并（推荐，适合大多数情况）" class="headerlink" title="✅ 解决方案一：自动合并（推荐，适合大多数情况）"></a>✅ 解决方案一：自动合并（推荐，适合大多数情况）</h2><p>你可以设置默认的 pull 策略为 <strong>merge</strong>（合并）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config pull.rebase <span class="literal">false</span>   <span class="comment"># 当前项目设置为 merge</span></span><br><span class="line"><span class="comment"># 或全局设置：</span></span><br><span class="line">git config --global pull.rebase <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>然后重新执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><p>Git 会帮你合并远程分支和你的本地分支，然后你就能正常 push 了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><hr><h2 id="✅-解决方案二：使用-rebase（更清爽的提交历史）"><a href="#✅-解决方案二：使用-rebase（更清爽的提交历史）" class="headerlink" title="✅ 解决方案二：使用 rebase（更清爽的提交历史）"></a>✅ 解决方案二：使用 <code>rebase</code>（更清爽的提交历史）</h2><p>你也可以选择用 <code>rebase</code>，意思是“把你的提交放在远程的提交后面”。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config pull.rebase <span class="literal">true</span></span><br><span class="line">git pull</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>✅ 提交历史更线性，没有多余的 merge commit<br>❗ 如果代码冲突，手动解决后要 <code>git rebase --continue</code></p><hr><h2 id="✅-解决方案三：强推（不建议，除非你知道你在干啥）"><a href="#✅-解决方案三：强推（不建议，除非你知道你在干啥）" class="headerlink" title="✅ 解决方案三：强推（不建议，除非你知道你在干啥）"></a>✅ 解决方案三：强推（不建议，除非你知道你在干啥）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master --force</span><br></pre></td></tr></table></figure><p>🚨 这会把远程的历史 <strong>强制替换成你本地的版本</strong>，可能会覆盖别人提交的内容。仅适用于你自己完全控制的分支！</p><hr><h2 id="🧠-小知识：为什么会-divergent？"><a href="#🧠-小知识：为什么会-divergent？" class="headerlink" title="🧠 小知识：为什么会 divergent？"></a>🧠 小知识：为什么会 divergent？</h2><p>Divergent branches 意思是：</p><ul><li>你本地有提交</li><li>远程也有提交</li><li>两边提交历史不一致，Git 不知道该怎么合并</li></ul><hr><h2 id="💡-你现在该怎么做？"><a href="#💡-你现在该怎么做？" class="headerlink" title="💡 你现在该怎么做？"></a>💡 你现在该怎么做？</h2><ol><li><strong>推荐做法：合并式 pull → push</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config pull.rebase <span class="literal">false</span></span><br><span class="line">git pull</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><ol><li><strong>如果喜欢更干净的历史（高级玩家）：rebase 后再 push</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config pull.rebase <span class="literal">true</span></span><br><span class="line">git pull</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><hr><h2 id="✅-最后推荐（全局设置一劳永逸）"><a href="#✅-最后推荐（全局设置一劳永逸）" class="headerlink" title="✅ 最后推荐（全局设置一劳永逸）"></a>✅ 最后推荐（全局设置一劳永逸）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global pull.rebase <span class="literal">false</span>   <span class="comment"># 默认用 merge 模式</span></span><br></pre></td></tr></table></figure><p>太棒啦 Neo！既然你都提出了这个需求，那我就直接给你整一份干净利落的 🎯<strong>Git 高级命令实战训练营清单</strong>，包含：</p><ul><li>场景设定 ✅</li><li>命令目标 ✅</li><li>练手任务 ✅</li><li>附带注意事项 ✅</li></ul><hr><h1 id="🚀-场景实战"><a href="#🚀-场景实战" class="headerlink" title="🚀 场景实战"></a>🚀 场景实战</h1><hr><h2 id="1️⃣-场景：合并冲突后撤销操作"><a href="#1️⃣-场景：合并冲突后撤销操作" class="headerlink" title="1️⃣ 场景：合并冲突后撤销操作"></a>1️⃣ 场景：<strong>合并冲突后撤销操作</strong></h2><p>💥 你执行了 <code>git merge feature</code>，结果一堆文件冲突，还没开始改就后悔了……</p><h3 id="🎯-目标："><a href="#🎯-目标：" class="headerlink" title="🎯 目标："></a>🎯 目标：</h3><ul><li>撤销 merge 操作</li><li>回到合并之前的状态</li></ul><h3 id="🛠-操作："><a href="#🛠-操作：" class="headerlink" title="🛠 操作："></a>🛠 操作：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git merge feature         <span class="comment"># 模拟合并产生冲突</span></span><br><span class="line">git merge --abort         <span class="comment"># 🧨 立刻撤销合并，回到之前状态</span></span><br></pre></td></tr></table></figure><h3 id="📌-注意事项："><a href="#📌-注意事项：" class="headerlink" title="📌 注意事项："></a>📌 注意事项：</h3><ul><li>只适用于<strong>还没解决冲突前</strong>的撤销</li><li>如果你已经解决了一部分冲突，要用：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD</span><br></pre></td></tr></table></figure><hr><h2 id="2️⃣-场景：找回误删分支或回滚版本"><a href="#2️⃣-场景：找回误删分支或回滚版本" class="headerlink" title="2️⃣ 场景：找回误删分支或回滚版本"></a>2️⃣ 场景：<strong>找回误删分支或回滚版本</strong></h2><p>😭 手滑 <code>git branch -D bugfix-xxx</code>，现在想要找回</p><h3 id="🎯-目标：-1"><a href="#🎯-目标：-1" class="headerlink" title="🎯 目标："></a>🎯 目标：</h3><ul><li>找回你删掉的分支或误操作的提交</li></ul><h3 id="🛠-操作：-1"><a href="#🛠-操作：-1" class="headerlink" title="🛠 操作："></a>🛠 操作：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reflog                <span class="comment"># 找到分支最后的 commit 哈希</span></span><br><span class="line">git checkout -b bugfix-xxx &lt;commit-id&gt;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b bugfix-xxx d4f2a7c</span><br></pre></td></tr></table></figure><h3 id="📌-小贴士："><a href="#📌-小贴士：" class="headerlink" title="📌 小贴士："></a>📌 小贴士：</h3><ul><li><code>git reflog</code> 是 Git 的黑匣子，啥都能找回来（只要还没 gc）</li></ul><hr><h2 id="3️⃣-场景：多人协作开发时同步主分支并-rebase-提交"><a href="#3️⃣-场景：多人协作开发时同步主分支并-rebase-提交" class="headerlink" title="3️⃣ 场景：多人协作开发时同步主分支并 rebase 提交"></a>3️⃣ 场景：<strong>多人协作开发时同步主分支并 rebase 提交</strong></h2><p>🧑‍🤝‍🧑 你在 <code>feature-xxx</code> 上开发，结果 <code>main</code> 分支更新了，想保持历史干净就不能直接 merge</p><h3 id="🎯-目标：-2"><a href="#🎯-目标：-2" class="headerlink" title="🎯 目标："></a>🎯 目标：</h3><ul><li>把主分支的最新提交合并进你的功能分支</li><li>使用 <code>rebase</code> 而不是 <code>merge</code></li></ul><h3 id="🛠-操作：-2"><a href="#🛠-操作：-2" class="headerlink" title="🛠 操作："></a>🛠 操作：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature-xxx</span><br><span class="line">git fetch origin</span><br><span class="line">git rebase origin/main</span><br></pre></td></tr></table></figure><p>如果有冲突：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解决冲突后：</span></span><br><span class="line">git add .</span><br><span class="line">git rebase --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure><h3 id="📌-注意事项：-1"><a href="#📌-注意事项：-1" class="headerlink" title="📌 注意事项："></a>📌 注意事项：</h3><ul><li>不要在公共分支 rebase（会让别人 history 混乱）</li><li>rebase 是让提交更“像一条直线”，但操作前建议备份一份分支</li></ul><hr><h2 id="4️⃣-场景：Cherry-pick-热修复-commit-到多个分支"><a href="#4️⃣-场景：Cherry-pick-热修复-commit-到多个分支" class="headerlink" title="4️⃣ 场景：Cherry-pick 热修复 commit 到多个分支"></a>4️⃣ 场景：<strong>Cherry-pick 热修复 commit 到多个分支</strong></h2><p>🚨 线上生产出了问题，你在 <code>hotfix/fix-404</code> 分支修好了，现在要把这个 bugfix 提交同步到 <code>main</code> 和 <code>release/1.0</code></p><h3 id="🎯-目标：-3"><a href="#🎯-目标：-3" class="headerlink" title="🎯 目标："></a>🎯 目标：</h3><ul><li>精确复制某个提交到其他分支</li></ul><h3 id="🛠-操作：-3"><a href="#🛠-操作：-3" class="headerlink" title="🛠 操作："></a>🛠 操作：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline             <span class="comment"># 找到那个 fix 的 commit id</span></span><br><span class="line">git checkout main</span><br><span class="line">git cherry-pick &lt;commit-id&gt;</span><br><span class="line">git checkout release/1.0</span><br><span class="line">git cherry-pick &lt;commit-id&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="5️⃣-场景：多个小-commit-打成一个，准备发-PR"><a href="#5️⃣-场景：多个小-commit-打成一个，准备发-PR" class="headerlink" title="5️⃣ 场景：多个小 commit 打成一个，准备发 PR"></a>5️⃣ 场景：<strong>多个小 commit 打成一个，准备发 PR</strong></h2><p>✅ 你在开发中提交了 5 个小碎提交，现在准备发 PR，想压缩成一个漂亮的 commit</p><h3 id="🎯-目标：-4"><a href="#🎯-目标：-4" class="headerlink" title="🎯 目标："></a>🎯 目标：</h3><ul><li>squash 压缩多个 commit</li><li>美化提交历史</li></ul><h3 id="🛠-操作：-4"><a href="#🛠-操作：-4" class="headerlink" title="🛠 操作："></a>🛠 操作：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline            <span class="comment"># 看你要压缩几个</span></span><br><span class="line">git rebase -i HEAD~5         <span class="comment"># 交互式 rebase 最近5个提交</span></span><br></pre></td></tr></table></figure><p>然后在编辑界面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pick  123abc  初始提交</span><br><span class="line">squash 456def  修复 typo</span><br><span class="line">squash 789aaa  增加校验</span><br><span class="line">squash abc999  重构函数</span><br><span class="line">squash xyz333  修改注释</span><br></pre></td></tr></table></figure><p>保存后输入新的 commit message，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">feat: 完善登录功能 &amp; 代码优化</span><br></pre></td></tr></table></figure><p>然后：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -f origin feature/login</span><br></pre></td></tr></table></figure><p>注意：你改了历史，需要用 <code>-f</code> 强推 ⚠️</p><hr><h2 id="✅-速查表："><a href="#✅-速查表：" class="headerlink" title="✅ 速查表："></a>✅ 速查表：</h2><table><thead><tr><th>场景</th><th>关键命令</th></tr></thead><tbody><tr><td>撤销冲突合并</td><td><code>git merge --abort</code></td></tr><tr><td>找回误删分支</td><td><code>git reflog</code> + <code>git checkout -b</code></td></tr><tr><td>同步主分支 + Rebase</td><td><code>git rebase origin/main</code></td></tr><tr><td>精确复制修复 commit</td><td><code>git cherry-pick &lt;id&gt;</code></td></tr><tr><td>多个提交压缩成一个提交</td><td><code>git rebase -i HEAD~N</code></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring整合mybatis</title>
      <link href="/2025/03/27/%E6%8A%80%E6%9C%AF/java/%E6%A1%86%E6%9E%B6/SpringBoot%E6%95%B4%E5%90%88mybatis/"/>
      <url>/2025/03/27/%E6%8A%80%E6%9C%AF/java/%E6%A1%86%E6%9E%B6/SpringBoot%E6%95%B4%E5%90%88mybatis/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring整合mybatis简单配置"><a href="#Spring整合mybatis简单配置" class="headerlink" title="Spring整合mybatis简单配置"></a>Spring整合mybatis简单配置</h2><ol><li>pom引入mybatis的starter</li><li>配置数据库连接池</li><li>Springboot配置文件里配置mybatis相关参数</li><li>编写自己的dao以及mapper配置文件</li></ol><p>配置datasource，比如用druid链接池配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    #druid相关配置</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">    driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">    #配置数据库连接</span><br><span class="line">    druid:</span><br><span class="line">      url: jdbc:mysql://localhost:3306/test-db?useUnicode=true&amp;allowMultiQueries=true&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">      username: root</span><br><span class="line">      password: 123456</span><br><span class="line">      initial-size: 10</span><br><span class="line">      max-active: 100</span><br><span class="line">      min-idle: 10</span><br><span class="line">      max-wait: 60000</span><br><span class="line">      pool-prepared-statements: true</span><br><span class="line">      max-pool-prepared-statement-per-connection-size: 20</span><br><span class="line">      time-between-eviction-runs-millis: 60000</span><br><span class="line">      min-evictable-idle-time-millis: 300000</span><br><span class="line">      validation-query: SELECT 1 FROM DUAL</span><br><span class="line">      test-while-idle: true</span><br><span class="line">      test-on-borrow: false</span><br><span class="line">      test-on-return: false</span><br><span class="line">      connectionInitSqls: set names utf8mb4</span><br></pre></td></tr></table></figure><p>配置mybatis参数，指定mapper文件路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mybatis:</span><br><span class="line">  mapper-locations: classpath:mapper/*.xml</span><br></pre></td></tr></table></figure><p>定义dao接口，并加上@Mapper注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserInfoDao</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">insert</span><span class="params">(UserInfoDO userInfoDO)</span></span><br><span class="line">    </span><br><span class="line">    UserInfoDO <span class="title function_">getById</span><span class="params">(<span class="type">long</span> id)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">update</span><span class="params">(UserInfoDO userInfoDO)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="type">long</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置mapper文件，写好sql与dao接口的映射关系，其中namespace是对应的dao接口完整类名。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.hj.dao.UserInfoDao&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.hj.DO.UserInfoDO&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;userId&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userId&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.hhdd.DO.UserInfoDO&quot;</span>&gt;</span></span><br><span class="line">      insert ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getById&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.Long&quot;</span>&gt;</span></span><br><span class="line">        select ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.hj.DO.UserInfoDO&quot;</span>&gt;</span></span><br><span class="line">        update ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;delete&quot;</span>&gt;</span></span><br><span class="line">        delete ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>想spring容器中注册SqlSessionFactory，并根据mapper配置文件解析出dao与具体jdbc操作、resultMap与实体类的映射关系。</p><p>注册实现了CRUD的SqlSessionTemplate类</p><img src="https://cdn.jsdelivr.net/gh/neoisok/assets@main/images%2F2025%2F03%2F27%2FMyBatis%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" width="600">]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> java </category>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven 的基本原理与核心概念</title>
      <link href="/2025/03/27/%E6%8A%80%E6%9C%AF/java/%E6%A1%86%E6%9E%B6/Maven/%E7%90%86%E8%A7%A3Maven%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E4%B8%8E%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/"/>
      <url>/2025/03/27/%E6%8A%80%E6%9C%AF/java/%E6%A1%86%E6%9E%B6/Maven/%E7%90%86%E8%A7%A3Maven%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E4%B8%8E%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Maven-的基本原理与核心概念"><a href="#一、Maven-的基本原理与核心概念" class="headerlink" title="一、Maven 的基本原理与核心概念"></a>一、Maven 的基本原理与核心概念</h2><h3 id="1-Maven-是什么？"><a href="#1-Maven-是什么？" class="headerlink" title="1. Maven 是什么？"></a>1. Maven 是什么？</h3><blockquote><p>Maven 是一个基于 POM（Project Object Model）的项目管理与构建自动化工具，主要用于 Java 项目的依赖管理、构建流程、插件系统和生命周期管理。</p></blockquote><ul><li><strong>构建工具</strong>：可以将源码编译、打包、测试、部署。</li><li><strong>依赖管理工具</strong>：自动下载项目依赖（jar 包），并解决依赖冲突。</li><li><strong>项目标准化工具</strong>：统一项目结构与构建流程，提升团队协作效率。</li></ul><hr><h3 id="2-Maven-的三大核心功能"><a href="#2-Maven-的三大核心功能" class="headerlink" title="2. Maven 的三大核心功能"></a>2. Maven 的三大核心功能</h3><table><thead><tr><th>功能模块</th><th>说明</th></tr></thead><tbody><tr><td><strong>依赖管理</strong></td><td>自动下载、更新、版本控制 Jar 包，解决依赖传递</td></tr><tr><td><strong>生命周期管理</strong></td><td>定义项目构建的标准流程，如编译、测试、打包、部署</td></tr><tr><td><strong>插件机制</strong></td><td>插件实现所有构建行为，例如编译、测试、生成文档等</td></tr></tbody></table><hr><h3 id="3-Maven-的核心概念"><a href="#3-Maven-的核心概念" class="headerlink" title="3. Maven 的核心概念"></a>3. Maven 的核心概念</h3><h4 id="3-1-POM（Project-Object-Model）"><a href="#3-1-POM（Project-Object-Model）" class="headerlink" title="3.1 POM（Project Object Model）"></a>3.1 POM（Project Object Model）</h4><ul><li>Maven 项目的核心配置文件是 <code>pom.xml</code></li><li>使用 XML 结构描述项目依赖、插件、版本、构建方式等</li></ul><p>示例结构（简化版）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 添加依赖 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h4 id="3-2-坐标（Coordinates）"><a href="#3-2-坐标（Coordinates）" class="headerlink" title="3.2 坐标（Coordinates）"></a>3.2 坐标（Coordinates）</h4><p>Maven 使用一组坐标唯一标识一个构件（artifact）：</p><ul><li><code>groupId</code>：组织 ID（例如公司或开源组织）</li><li><code>artifactId</code>：项目名称或模块名称</li><li><code>version</code>：版本号</li><li><code>packaging</code>：打包类型（默认是 jar，也可以是 war）</li></ul><hr><h4 id="3-3-仓库（Repository）"><a href="#3-3-仓库（Repository）" class="headerlink" title="3.3 仓库（Repository）"></a>3.3 仓库（Repository）</h4><p>Maven 下载依赖的地方称为仓库，分为：</p><ul><li><strong>本地仓库</strong>：<code>~/.m2/repository</code>，首次下载后缓存</li><li><strong>中央仓库</strong>：默认公共仓库，<a href="https://repo.maven.apache.org/">https://repo.maven.apache.org</a></li><li><strong>私服仓库</strong>：企业内部搭建，如 Nexus、Artifactory</li></ul><hr><h4 id="3-4-生命周期（Lifecycle）"><a href="#3-4-生命周期（Lifecycle）" class="headerlink" title="3.4 生命周期（Lifecycle）"></a>3.4 生命周期（Lifecycle）</h4><p>Maven 构建项目遵循一定的生命周期，最常用的是默认生命周期：</p><table><thead><tr><th>阶段（Phase）</th><th>说明</th></tr></thead><tbody><tr><td><code>validate</code></td><td>验证项目结构是否完整</td></tr><tr><td><code>compile</code></td><td>编译 Java 源码</td></tr><tr><td><code>test</code></td><td>执行单元测试</td></tr><tr><td><code>package</code></td><td>打包成 jar&#x2F;war</td></tr><tr><td><code>install</code></td><td>安装到本地仓库</td></tr><tr><td><code>deploy</code></td><td>发布到远程仓库</td></tr></tbody></table><p>执行命令如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package</span><br></pre></td></tr></table></figure><hr><h4 id="3-5-插件（Plugin）"><a href="#3-5-插件（Plugin）" class="headerlink" title="3.5 插件（Plugin）"></a>3.5 插件（Plugin）</h4><p>插件是 Maven 的功能实现者，例如：</p><ul><li><code>maven-compiler-plugin</code>：编译 Java 源码</li><li><code>maven-surefire-plugin</code>：运行单元测试</li><li><code>maven-jar-plugin</code>：打包成 jar 文件</li></ul><hr><h4 id="3-6-依赖传递与范围（Scope）"><a href="#3-6-依赖传递与范围（Scope）" class="headerlink" title="3.6 依赖传递与范围（Scope）"></a>3.6 依赖传递与范围（Scope）</h4><p>依赖管理中常见问题：</p><ul><li>依赖传递：A 依赖 B，B 又依赖 C → A 自动引入 C</li><li>范围控制：<ul><li><code>compile</code>：默认，编译&#x2F;运行&#x2F;打包都可用</li><li><code>provided</code>：编译需要，运行时由容器提供（如 Servlet）</li><li><code>runtime</code>：运行时需要，如 JDBC 驱动</li><li><code>test</code>：只在测试阶段使用</li></ul></li></ul><hr><h3 id="4-Maven-的标准项目结构"><a href="#4-Maven-的标准项目结构" class="headerlink" title="4. Maven 的标准项目结构"></a>4. Maven 的标准项目结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">demo-app/</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src/</span><br><span class="line">    ├── main/</span><br><span class="line">    │   ├── java/        # 源码目录</span><br><span class="line">    │   └── resources/   # 配置文件目录</span><br><span class="line">    └── test/</span><br><span class="line">        └── java/        # 测试代码目录</span><br></pre></td></tr></table></figure><hr><h3 id="5-Maven-的工作流程（构建过程）"><a href="#5-Maven-的工作流程（构建过程）" class="headerlink" title="5. Maven 的工作流程（构建过程）"></a>5. Maven 的工作流程（构建过程）</h3><blockquote><p>开发者执行 Maven 命令 → 读取 pom.xml → 下载依赖 → 执行生命周期 → 生成产物</p></blockquote><p>流程图（建议制作成教学图）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[开发者执行命令]</span><br><span class="line">        ↓</span><br><span class="line"> [读取 pom.xml]</span><br><span class="line">        ↓</span><br><span class="line">[解析依赖关系树]</span><br><span class="line">        ↓</span><br><span class="line">[执行生命周期中各阶段]</span><br><span class="line">        ↓</span><br><span class="line"> [输出 jar/war 文件]</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> java </category>
          
          <category> 框架 </category>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 常用命令</title>
      <link href="/2025/03/19/%E6%8A%80%E6%9C%AF/%E8%BF%90%E7%BB%B4/%E5%AE%B9%E5%99%A8/Docker-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2025/03/19/%E6%8A%80%E6%9C%AF/%E8%BF%90%E7%BB%B4/%E5%AE%B9%E5%99%A8/Docker-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="windows下利用docker-搭建ubuntu-环境"><a href="#windows下利用docker-搭建ubuntu-环境" class="headerlink" title="windows下利用docker 搭建ubuntu 环境"></a>windows下利用docker 搭建ubuntu 环境</h2><h3 id="1、首先安装docker"><a href="#1、首先安装docker" class="headerlink" title="1、首先安装docker"></a><strong>1、首先安装docker</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker system df # 查看镜像、容器、数据卷占用空间</span><br><span class="line">docker images # 查看docker镜像 </span><br><span class="line">docker image ls # 查看镜像</span><br><span class="line">docker ps # 查看所有启动的容器</span><br><span class="line">docker ps -a # 查看所有容器</span><br><span class="line">docker rm -f id/name # 删除容器</span><br><span class="line">docker image rm ID # 删除镜像</span><br><span class="line">docker image prune # 删除虚悬镜像(dangling image)，由于新旧镜像同名，旧镜像名被取消，导致仓库名和标签均为&lt;none&gt;</span><br><span class="line"></span><br><span class="line">docker commit 26ea8c57c7bf ubuntupython3 # 从容器创建一个新的镜像，可以自己搭建一个ubuntu+python的开发环境，作为一个镜像，这样再次新建容器时可以以此为基础</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2、获取镜像"><a href="#2、获取镜像" class="headerlink" title="2、获取镜像"></a><strong>2、获取镜像</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker search ubuntu # 查找ubuntu镜像</span><br><span class="line">docker pull ubuntu # 默认安装latest版本</span><br><span class="line">docker pull ubuntu:16.04 # 指定版本</span><br></pre></td></tr></table></figure><h3 id="3、以镜像为基础启动并运行一个容器-：https-docs-docker-com-engine-reference-commandline-container-start"><a href="#3、以镜像为基础启动并运行一个容器-：https-docs-docker-com-engine-reference-commandline-container-start" class="headerlink" title="3、以镜像为基础启动并运行一个容器 ：https://docs.docker.com/engine/reference/commandline/container_start/"></a><strong>3、以镜像为基础启动并运行一个容器 ：<a href="https://docs.docker.com/engine/reference/commandline/container_start/">https://docs.docker.com/engine/reference/commandline/container_start/</a></strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm ubuntu:16.04 bash # -i 交互式操作 -t 终端 --rm 容器退出后将其删除</span><br><span class="line">docker run -itd ubuntu bash # 后台运行</span><br><span class="line">docker run --name=openvino -it ubuntu:18.04 # 指定名字</span><br><span class="line">docker run -it -v E:/data:/home/data ubuntu bash # 挂在宿主机文件目录，实现文件共享</span><br><span class="line">exit # 退出容器</span><br><span class="line">docker container start -i container_name # 重新启动</span><br><span class="line">docker container stop # 终止容器</span><br><span class="line">docker exec -it id/name bash # 进入容器</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker attach 必须attach 到一个已经运行的容器, 使用<span class="built_in">exit</span>会导致容器停止</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入退出的容器</span></span><br><span class="line">docker start openvino</span><br><span class="line">docker attach openvino</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">移除容器及其挂载卷，不会对镜像造成影响</span></span><br><span class="line">docker rm -v container_id</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">批量删除停止的容器</span></span><br><span class="line">docker rm -v $(docker ps -a -q -f status=exited)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改容器的挂载目录:提交现有容器为新镜像，然后重新运行它</span></span><br><span class="line">docker commit 5a3422adeead newimagename</span><br><span class="line">docker run -ti -v &quot;$PWD/dir1&quot;:/dir1 -v &quot;$PWD/dir2&quot;:/dir2 newimagename /bin/bash</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Docker文件系统和数据卷:https://zhuanlan.zhihu.com/p/73288338</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Docker中的数据可以存储在类似于虚拟机磁盘的介质中，称为数据卷（Data Volume）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通常存储在容器中的一般文件随着容器的删除而消失，而数据卷独立于容器存在，并不会随着容器的删除而删除</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">数据卷除了延长数据的生命周期，还可以用于容器间的数据共享</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建数据卷</span></span><br><span class="line">docker volume create volume_name</span><br><span class="line">docker run -it -v /data3 --name=volume2 image_id/image_name # 启动容器并创建一个数据卷</span><br><span class="line">docker run -it -v volume_name:/data4 --name=volume3 image_id/image_name # 指定数据卷挂载容器目录</span><br><span class="line">docker run -it -volumes_from 容器ID --name=volume4 image_id # 挂载其他容器的数据卷</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看所有数据卷</span></span><br><span class="line">docker volume ls</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除数据卷</span></span><br><span class="line">docker volume rm 数据卷名</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除所有无主的数据卷</span></span><br><span class="line">docker volume prune</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">挂载宿主机目录</span></span><br><span class="line">docker run -it --name=test -v /宿主机目录:/容器目录 image_id</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将数据卷的数据同步到宿主机：可以创建一个新容器挂载数据卷容器，同时挂载一个本地目录，通过<span class="built_in">cp</span>命名将数据拷贝到本地目录</span></span><br><span class="line">docker run –rm –volumes-from=volume2 –name=“volume8” -v /data/www/fjh3:/fjh3:rw 镜像ID cp –rf /data1 /fjh3</span><br><span class="line"></span><br><span class="line">ps # 显示进程信息</span><br><span class="line">top # 实时显示进程动态，输入q或者按ctrl c 退出</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4、ubuntu部分"><a href="#4、ubuntu部分" class="headerlink" title="4、ubuntu部分"></a><strong>4、ubuntu部分</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/os-release # 查看ubuntu版本</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">https://man.linuxde.net/apt-get apt-get命令</span></span><br><span class="line">apt-get update # 更新apt-get</span><br><span class="line">apt-get remove packagename # 保留配置文件</span><br><span class="line">apt-get purge packagename # 删除配置文件</span><br><span class="line">apt-get autoclean apt # 删除已删掉软件的备份</span><br><span class="line">apt-get clean # 删除安装软件的备份</span><br><span class="line">apt-get upgrade # 更新已安装的软件包</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装常用工具</span></span><br><span class="line">apt-get install -y vim</span><br><span class="line">apt-get install -y python3</span><br><span class="line">apt-get install -y python3-pip</span><br><span class="line">apt-get install -y git # 安装git　 git --version 查看版本</span><br><span class="line">apt-get install wget # wget 用于从指定的url下载文件</span><br><span class="line">apt-get install -y dos2unix</span><br></pre></td></tr></table></figure><h3 id="5、搭建开发环境"><a href="#5、搭建开发环境" class="headerlink" title="5、搭建开发环境"></a><strong>5、搭建开发环境</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Python环境：https://blog.csdn.net/m0_38124502/article/details/78090902</span></span><br><span class="line">pip freeze &gt;requirements.txt # 将当前项目的python环境导出</span><br><span class="line">pip install -r requirements.txt # 安装</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 源码安装主要有三个步骤：配置(configure)、编译(make)、安装(make install)</span></span></span><br><span class="line">./configure --help</span><br><span class="line">./configure --prefix=/usr/local # 指定安装目录</span><br><span class="line"></span><br><span class="line">pip3 install opencv-python</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 运维 </category>
          
          <category> 容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>管理</title>
      <link href="/2025/03/19/%E7%AE%A1%E7%90%86/%E7%AE%A1%E7%90%86/"/>
      <url>/2025/03/19/%E7%AE%A1%E7%90%86/%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>这里写管理博客</p>]]></content>
      
      
      <categories>
          
          <category> 管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/03/18/hello-world/"/>
      <url>/2025/03/18/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h3 id="categorys"><a href="#categorys" class="headerlink" title="categorys"></a>categorys</h3><ul><li>技术&#x2F;架构</li><li>技术&#x2F;前端</li><li>技术&#x2F;数据库</li><li>技术&#x2F;运维</li><li>技术&#x2F;java</li><li>技术&#x2F;java&#x2F;基础</li><li>技术&#x2F;java&#x2F;框架</li></ul>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
